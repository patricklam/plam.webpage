#!/usr/bin/python2.4
from __future__ import division, generators
import re, operator, os, urlparse

auto_msg = "<!--Automatically generated by Erik Demaine's notes.py script-->"
disclaimer = \
"""These are rough, personal lecture notes handwritten by Patrick Lam
used during lecture.  Their primary purpose is for reading/review by students
of the class.  Thanks to Erik Demaine for providing the software used to 
generate these pages."""

class_number = "ECE 750-T5"
class_title = "Static Analysis for Software Engineering"
class_webpage = "http://patricklam.ca/sase"
class_prof = "Patrick Lam"
class_prof_webpage = "http://patricklam.ca"
class_semester = "Fall 2008"
webroot = "http://patricklam.ca/sase/notes/"  ## include trailing /
main_dir = "."
original_dpi = 150
available_dpi = [50, 72, 100, 150]
imagemagick_convert = "convert"
jpeg2ps = None
world_readable_file = 0644
world_readable_dir = 0755

data_filename = {
  'title': "titles/%s%d",
  'extra': "extra/%s%d",
}
dpi_dir = "%ddpi"
dpi_dir_re = r"^(?P<dpi>\d+)dpi$"
dpi_dir_rec = re.compile (dpi_dir_re)
lecture_filename = "%s%d-%d.%s"
lecture_filename_re = \
  r"^(?P<type>[A-Z]+)(?P<lecture>\d+)-(?P<page>\d+).(?P<ext>jpe?g|gif|png)$"
lecture_filename_rec = re.compile (lecture_filename_re, re.IGNORECASE)

types = {
  'L': 'Lecture',
  'PS': 'Problem Session',
}

settings_basename = 'settings.py'
settings_filename = os.path.join (main_dir, settings_basename)
if os.path.exists (settings_filename): execfile (settings_filename)

##############################################################################

class LecturePage:
  def __init__ (self, type, lecture, page, dpi, ext):
    self.type = type
    self.lecture = lecture
    self.page = page
    self.dpi = dpi
    self.ext = ext
  def __cmp__ (self, other):
    return cmp ((self.type, self.lecture, self.page, self.dpi, self.ext),
                (other.type, other.lecture, other.page, other.dpi, other.ext))
  def change_lecture (self, lecture):
    return LecturePage (self.type, lecture, self.page, self.dpi, self.ext)
  def change_page (self, page):
    return LecturePage (self.type, self.lecture, page, self.dpi, self.ext)
  def change_dpi (self, dpi):
    return LecturePage (self.type, self.lecture, self.page, dpi, self.ext)
  def change_ext (self, ext):
    return LecturePage (self.type, self.lecture, self.page, self.dpi, ext)
  def postscript (self):
    return self.change_dpi (original_dpi).change_ext ("ps")
  def basename (self):
    return lecture_filename % (self.type, self.lecture, self.page, self.ext)
  def relative_filename (self):
    return os.path.join (dpi_dir % self.dpi, self.basename ())
  def filename (self):
    return os.path.join (main_dir, self.relative_filename ())
  def exists (self):
    return os.path.exists (self.filename ())
  def __str__ (self):
    return "<%s %d page %d at DPI %d in format %s>" % \
           (self.type, self.lecture, self.page, self.dpi, self.ext)

  def data (self, part):
    return lecture_data (self, part)
  def data_all (self, part):
    return self.data (part).for_all ()
  def data_page (self, part):
    return self.data (part).for_page (self.page)

  def minimize_lecture (self):
    for lecture in range (2):  ## allow start at 0 or 1
      lecturepage = self.change_lecture (lecture).minimize_page ()
      if lecturepage is not None: return lecturepage
    return None
  def minimize_page (self):
    for page in range (2):  ## allow start at 0 or 1
      lecturepage = self.change_page (page)
      if lecturepage.exists (): return lecturepage
    return None
  def maximize_page (self):
    lecturepage = self.minimize_page ()
    if lecturepage is None: return None
    page = lecturepage.page
    while self.change_page (page).exists ():
      page += 1
    return self.change_page (page - 1)
  def all_pages_of_lecture (self):
    page = self.minimize_page ()
    if page is None: return
    while page.exists ():
      yield page
      page = self.change_page (page.page + 1)
  def next_page (self):
    page = self.change_page (self.page + 1)
    if page.exists (): return page
    return self.change_lecture (self.lecture + 1).minimize_page ()
  def prev_page (self):
    page = self.change_page (self.page - 1)
    if page.exists (): return page
    return self.change_lecture (self.lecture - 1).maximize_page ()
  def next_lecture (self):
    return self.change_lecture (self.lecture + 1).minimize_page ()
  def prev_lecture (self):
    return self.change_lecture (self.lecture - 1).minimize_page ()

def parse_lecturepage_filename (filename):
  match = dpi_dir_rec.search (os.path.basename (os.path.dirname (filename)))
  if not match: return None
  dpi = int (match.group ("dpi"))

  match = lecture_filename_rec.search (os.path.basename (filename))
  if not match: return None
  lecturepage = LecturePage (match.group ('type'),
                             int (match.group ('lecture')),
                             int (match.group ('page')),
                             dpi, match.group ('ext'))
  if not os.path.samefile (filename, lecturepage.filename ()):
    raise "File seems to be in the wrong place: I thought the true '%s' " \
          "should have been the proper '%s'" % \
          (filename, lecturepage.filename ())
  return lecturepage

def all_lectures (lecturepages):
  lectures = sorted (lecturepages)
  i = 0
  while i+1 < len (lectures):
    if lectures[i].lecture == lectures[i+1].lecture:
      del lectures[i+1]
    else:
      i += 1
  return lectures

data_header_re = r'^pp?\s*([-\d,\s]+)\s*:\s*$'
data_header_rec = re.compile (data_header_re, re.IGNORECASE)
def page_range (text):
  count = text.count ("-")
  if count == 0: return [int (text)]
  if count > 1: raise "Double dash in %r" % text
  index = text.index ("-")
  return range (int (text[:index]), int (text[index+1:]) + 1)
class LectureData:
  def __init__ (self):
    self.as_list = []
    self.by_page = {}
  def __nonzero__ (self):
    return bool (self.as_list)
  def add (self, pages, text):
    for page in pages:
      if page not in self.by_page: self.by_page[page] = []
      self.by_page[page].append (text)
    self.as_list.append ((pages, text))
  def for_all (self):
    return self.by_page.get (None, [])
  def for_page (self, page):
    return self.by_page.get (page, [])
  def parse (class_, contents):
    data = class_ ()
    context = [None]
    text = ""
    for line in contents.split ("\n"):
      match = data_header_rec.search (line)
      if match:
        if text:
          data.add (context, text)
          text = ""
        context = reduce (operator.concat,
          [page_range (num.strip ()) for num in match.group (1).split (",")
           if num.strip ()])
      else:
        if text: text += "\n"
        text += line
    if text:
      data.add (context, text)
      text = ""
    return data
  parse = classmethod (parse)
lecture_data_map = dict ([(key, {}) for key in data_filename])
def lecture_data (lecture, part):
  lecture = (lecture.type, lecture.lecture)
  if lecture not in lecture_data_map[part]:
    filename = os.path.join (main_dir, data_filename[part] % lecture)
    if os.path.exists (filename):
      lecture_data_map[part][lecture] = \
        LectureData.parse (file (filename, "r").read ())
    else:
      lecture_data_map[part][lecture] = LectureData ()
  return lecture_data_map[part][lecture]

def needs_regeneration (src, dest):
  if not os.path.exists (dest): return True
  dest_stat = os.stat (dest)
  return dest_stat.st_size <= 0 or \
         os.stat (src).st_mtime > dest_stat.st_mtime

def rescale_image (src, dest, factor):
  if needs_regeneration (src, dest):
    print "\t%s -geometry %f%% %s %s" % (imagemagick_convert, factor * 100,
                                         src, dest)
    os.spawnlp (os.P_WAIT, imagemagick_convert, imagemagick_convert,
                "-geometry", "%f%%" % (factor * 100), src, dest)

def image_to_ps (src, dest, dpi):
  if needs_regeneration (src, dest):
    if os.path.splitext (src) [1].lower () in (".jpg", ".jpeg") and \
       jpeg2ps is not None:
      print "\t%s -r %d -o %s %s" % (jpeg2ps, dpi, dest, src)
      os.spawnlp (os.P_WAIT, jpeg2ps, jpeg2ps,
                  "-r", str (dpi), "-o", dest, src)
    else:
      ## xxx doesn't use dpi
      print "\t%s %s ps3:%s" % (imagemagick_convert, src, dest)
      os.spawnlp (os.P_WAIT, imagemagick_convert, imagemagick_convert,
                  src, "ps3:%s" % (dest))

def make_other_dpi (orig_lecturepages):
  all_lecturepages = []
  for lecturepage in orig_lecturepages:
    if lecturepage.dpi != original_dpi:
      raise "%s not in original DPI?" % lecturepage
    for dpi in available_dpi:
      target = lecturepage.change_dpi (dpi)
      all_lecturepages.append (target)
      if dpi == lecturepage.dpi: continue
      rescale_image (lecturepage.filename (), target.filename (),
                     dpi / lecturepage.dpi)
  ## Set permissions on new and old ones, just in case.
  for lecturepage in all_lecturepages:
    os.chmod (lecturepage.filename (), world_readable_file)
  return all_lecturepages

def make_postscript (lecturepages):
  for lecturepage in lecturepages:
    target = lecturepage.change_ext ("ps")
    image_to_ps (lecturepage.filename (), target.filename (), lecturepage.dpi)
    os.chmod (target.filename (), world_readable_file)

def compute_data ():
  return {'auto_msg': auto_msg,
          'disclaimer': disclaimer,
          'class_number': class_number,
          'class_title': class_title,
          'class_webpage': class_webpage,
          'class_prof': class_prof,
          'class_prof_webpage': class_prof_webpage,
          'class_semester': class_semester}

link_re = r'\b(HREF\s*=\s*")([^"]*)(")'
link_rec = re.compile (link_re, re.IGNORECASE)
def fix_relative_links (html):
  def fix_link (match):
    parsed = urlparse.urlparse (match.group (2))
    if parsed[0] == parsed[1] == '' and not parsed[2].startswith ('/'):
      return match.group (1) + webroot + match.group (2) + match.group (3)
    else:
      return match.group (0)
  return link_rec.sub (fix_link, html)

def make_html (lecturepages):
  data = compute_data ()
  for lecturepage in lecturepages:
    data['type'] = types[lecturepage.type]
    data['title'] = "<BR>\n".join (lecturepage.data_all ('title'))
    data['page_title'] = "<BR>\n".join (lecturepage.data_page ('title'))
    data['extra'] = fix_relative_links (
                      "<P>\n".join (lecturepage.data_all ('extra') +
                                    lecturepage.data_page ('extra')))
    data['lecture'] = lecturepage.lecture
    data['page'] = lecturepage.page
    data['dpi'] = lecturepage.dpi
    data['image'] = lecturepage.basename ()
    data['postscript'] = webroot + \
                         lecturepage.postscript ().relative_filename ()
    if data['title']:
      data['title'] = "<STRONG>%(type)s %(lecture)d:</STRONG> %(title)s" % data
    if data['page_title']:
      data['page_title'] = "<STRONG>Page %(page)d:</STRONG> %(page_title)s" % \
                          data
    buttons = []
    for button, text in \
        [(lecturepage.prev_lecture (), "&lt;&lt; prev lecture &lt;&lt;"),
         (lecturepage.prev_page (), "&lt; prev page &lt;"),
         (lecturepage.next_page (), "&gt; next page &gt;"),
         (lecturepage.next_lecture (), "&gt;&gt; next lecture &gt;&gt;")]:
      if button is not None:
        buttons.append (
          '<A HREF="%s">[%s]</A>' %
          (webroot + button.change_ext ("shtml").relative_filename (), text))
      else:
        buttons.append (text)
    buttons.append ('<A HREF="%s">[up to index]</A>' %
                    (webroot + dpi_dir % lecturepage.dpi + "/"))
    data['buttons'] = " -- ".join (buttons)
    data['dpis'] = "Switch to " + " or ".join (
       ['<A HREF="%s">%s</A>' %
        (webroot + lecturepage.change_ext ("shtml").change_dpi (dpi)
                              .relative_filename (),
         "%d DPI" % dpi)
        for dpi in available_dpi])
    html_filename = lecturepage.change_ext ("shtml").filename ()
    html_file = file (html_filename, "w")
    html_file.write ("""
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
%(auto_msg)s
<head>
<title>
%(class_number)s: %(class_title)s -- %(type)s %(lecture)d page %(page)d at %(dpi)d DPI -- %(class_prof)s</title>
<!--#include virtual="/sase/includes/header.html" -->

<div id="primarycontarea">
  <div id="primarycontent">
    <!-- InstanceBeginEditable name="primarycontent" -->
<H1><A HREF="%(class_webpage)s">%(class_number)s: %(class_title)s</A>
    (%(class_semester)s)</H1>
<H2><A HREF="%(class_prof_webpage)s">%(class_prof)s</A></H2>
<DIV STYLE="background-color: #FFFF80; color: black">
<H2>%(type)s %(lecture)d -- Page %(page)d -- %(dpi)d DPI</H2>
%(buttons)s
<P>
%(dpis)s
</DIV>
<P>
%(title)s
<P>
%(page_title)s
<P>
%(extra)s
<P>
<IMG SRC="%(image)s">
<P>
%(disclaimer)s
<P>
<DIV STYLE="background-color: #FFFF80; color: black">
<A HREF="%(postscript)s">Printable PostScript</A>
(requires Level-3 PostScript)
<P>
%(buttons)s
<P>
%(dpis)s

    <!-- InstanceEndEditable -->
  </div>
</div>

<!--#include virtual="/sase/includes/footer.html" -->
""" % data)
    html_file.close ()
    os.chmod (html_filename, world_readable_file)

def make_index_pages (lecturepages):
  type = type_of_many (lecturepages)
  lectures = all_lectures (lecturepages)
  data = compute_data ()
  data['type'] = types[type]
  for dpi in available_dpi:
    data['dpi'] = dpi
    data['dpis'] = "Switch to " + " or ".join (
       ['<A HREF="%s">%s</A>' %
        (webroot + dpi_dir % other_dpi, "%d DPI" % other_dpi)
        for other_dpi in available_dpi])
    index_filename = os.path.join (main_dir, dpi_dir % dpi, "index.shtml")
    index_file = file (index_filename, "w")
    index_file.write ("""
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
%(auto_msg)s
<head>
<title>
%(class_number)s: %(class_title)s -- %(type)s notes at %(dpi)d DPI -- %(class_prof)s
</title>
<!--#include virtual="/sase/includes/header.html" -->

<div id="primarycontarea">
  <div id="primarycontent">
    <!-- InstanceBeginEditable name="primarycontent" -->
<H1><A HREF="%(class_webpage)s">%(class_number)s: %(class_title)s</A>
    (%(class_semester)s)</H1>
<H2><A HREF="%(class_prof_webpage)s">%(class_prof)s</A></H2>
<DIV STYLE="background-color: #FFFF80; color: black">
<H2>%(type)s notes at %(dpi)d DPI</H2>
%(dpis)s
</DIV>
<P>
%(disclaimer)s
<UL>
""" % data)

    ##lecture = LecturePage (type, None, None, dpi, "html").minimize_lecture ()
    ##while lecture is not None:
    for lecture in lectures:
      lecture = lecture.change_dpi (dpi).change_ext ("shtml")
      pdfname = "pdf/L%s.pdf" % lecture.lecture
      if os.path.exists(pdfname):
        pdf = '<A HREF="../%s">[pdf]</A>' % pdfname
      else:
        pdf = ''
      index_file.write (
        '<LI> <A HREF="%s"><B>%s %d</B>:</A> %s -- %s pages %s\n' %
        (lecture.basename (), types[lecture.type], lecture.lecture,
         pdf, 
         "\n".join (lecture.data_all ('title')).strip (),
         ", ".join (
           ['<A HREF="%s">%d</A>' % (page.basename (), page.page)
            for page in lecture.all_pages_of_lecture ()])))
      if lecture.data ('extra'):
        index_file.write ('  <UL>\n')
        for pages, text in lecture.data ('extra').as_list:
          index_file.write ('  <LI> %s' % fix_relative_links (text))
          if pages != [None]:
            if len (pages) == 1:
              s = ""
            else:
              s = "s"
            index_file.write (' [page%s ' % s +
              ", ".join (
                ['<A HREF="%s">%d</A>' %
                 (lecture.change_page (page).basename (), page)
                 for page in pages]) +
              ']')
          index_file.write ('\n')
        index_file.write ('  </UL>\n')
      index_file.write ('<P>\n')
      ##lecture = lecture.next_lecture ()

    index_file.write ("""
</UL>
</BODY>
</HTML>
""" % data)
    index_file.close ()
    os.chmod (index_filename, world_readable_file)

def type_of_many (all_lecturepages):
  if not all_lecturepages: return None
  type = all_lecturepages[0].type
  for lecturepage in all_lecturepages:
    if lecturepage.type != type:
      warnings.warn ("Preparing index for type %r but type %r exists as well"
                     % (type, lecturepage.type))
  return type

def make_dpi_dirs ():
  for dpi in available_dpi:
    dir = os.path.join (main_dir, dpi_dir % dpi)
    if os.path.exists (dir):
      if not os.path.isdir (dir):
        raise "%s exists but isn't a directory" % dir
    else:
      os.mkdir (dir)
    os.chmod (dir, world_readable_dir)

def find_lecturepages (dpis):
  for dpi in dpis:
    for filename in os.listdir (os.path.join (main_dir, dpi_dir % dpi)):
      filename = os.path.join (main_dir, dpi_dir % dpi, filename)
      lecturepage = parse_lecturepage_filename (filename)
      if lecturepage is not None:
        yield lecturepage

def make_all ():
  make_dpi_dirs ()
  orig_lecturepages = list (find_lecturepages ([original_dpi]))
  all_lecturepages = make_other_dpi (orig_lecturepages)
  if not all_lecturepages:
    raise "I couldn't find any lecture pages"
  make_postscript (orig_lecturepages)
  make_html (all_lecturepages)
  make_index_pages (orig_lecturepages)

if __name__ == '__main__': make_all ()
