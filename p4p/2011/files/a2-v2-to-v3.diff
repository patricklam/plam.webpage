diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..ba62df5
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,8 @@
+*.o
+jpegr
+*.a
+montage.jpg
+out
+
+
+
diff --git a/README b/README
new file mode 100644
index 0000000..7743db3
--- /dev/null
+++ b/README
@@ -0,0 +1,5 @@
+I've moved the makefile to the root directory, out of src/.
+It's not perfect, but it's better. You can use either libjpeg-6b
+or libjpeg-8b with this version now. To change between them, 
+edit the makefile and change the definitions of OBJLIB, OBJH, and
+libjpega2.
\ No newline at end of file
diff --git a/car.jpg b/car.jpg
new file mode 100644
index 0000000..92eff56
Binary files /dev/null and b/car.jpg differ
diff --git a/lib/a2jpeg-6b/README b/lib/a2jpeg-6b/README
new file mode 100644
index 0000000..76e7464
--- /dev/null
+++ b/lib/a2jpeg-6b/README
@@ -0,0 +1,2 @@
+some source files copyed over from
+The Independent JPEG Group's JPEG software
diff --git a/lib/a2jpeg-6b/dither.c b/lib/a2jpeg-6b/dither.c
new file mode 100644
index 0000000..2eaeb31
--- /dev/null
+++ b/lib/a2jpeg-6b/dither.c
@@ -0,0 +1,193 @@
+/*
+ * ordered dither rotines
+ *
+ * stolen from The GIMP and trimmed for speed
+ *
+ */
+
+#include <stdlib.h>
+#include "dither.h"
+
+#define DITHER_LEVEL 8
+
+void (*dither_line)(unsigned char *, unsigned char *, int, int);
+
+static long     red_mult, green_mult;
+static long     red_dither[256];
+static long     green_dither[256];
+static long     blue_dither[256];
+static long     gray_dither[256];
+
+typedef unsigned long vector[DITHER_LEVEL];
+typedef vector  matrix[DITHER_LEVEL];
+
+#if DITHER_LEVEL == 8
+#define DITHER_MASK 7
+static matrix   DM =
+{
+    {0, 32, 8, 40, 2, 34, 10, 42},
+    {48, 16, 56, 24, 50, 18, 58, 26},
+    {12, 44, 4, 36, 14, 46, 6, 38},
+    {60, 28, 52, 20, 62, 30, 54, 22},
+    {3, 35, 11, 43, 1, 33, 9, 41},
+    {51, 19, 59, 27, 49, 17, 57, 25},
+    {15, 47, 7, 39, 13, 45, 5, 37},
+    {63, 31, 55, 23, 61, 29, 53, 21}
+};
+
+#endif
+
+#if DITHER_LEVEL == 4
+#define DITHER_MASK 3
+static matrix   DM =
+{
+    {0, 8, 2, 10},
+    {12, 4, 14, 6},
+    {3, 11, 1, 9},
+    {15, 7, 13, 5}
+};
+
+#endif
+
+void
+init_dither(int shades_r, int shades_g, int shades_b, int shades_gray)
+{
+    int             i, j;
+    unsigned char   low_shade, high_shade;
+    unsigned short  index;
+    float           red_colors_per_shade;
+    float           green_colors_per_shade;
+    float           blue_colors_per_shade;
+    float           gray_colors_per_shade;
+
+    red_mult = shades_g * shades_b;
+    green_mult = shades_b;
+
+    red_colors_per_shade = 256.0 / (shades_r - 1);
+    green_colors_per_shade = 256.0 / (shades_g - 1);
+    blue_colors_per_shade = 256.0 / (shades_b - 1);
+    gray_colors_per_shade = 256.0 / (shades_gray - 1);
+
+    /* this avoids a shift when checking these values */
+    for (i = 0; i < DITHER_LEVEL; i++)
+	for (j = 0; j < DITHER_LEVEL; j++)
+	    DM[i][j] *= 0x10000;
+
+    /*  setup arrays containing three bytes of information for red, green, & blue  */
+    /*  the arrays contain :
+     *    1st byte:    low end shade value
+     *    2nd byte:    high end shade value
+     *    3rd & 4th bytes:    ordered dither matrix index
+     */
+
+    for (i = 0; i < 256; i++) {
+
+	/*  setup the red information  */
+	{
+	    low_shade = (unsigned char) (i / red_colors_per_shade);
+	    high_shade = low_shade + 1;
+
+	    index = (unsigned short)
+		(((i - low_shade * red_colors_per_shade) / red_colors_per_shade) *
+		 (DITHER_LEVEL * DITHER_LEVEL + 1));
+
+	    low_shade *= red_mult;
+	    high_shade *= red_mult;
+
+	    red_dither[i] = (index << 16) + (high_shade << 8) + (low_shade);
+	}
+
+	/*  setup the green information  */
+	{
+	    low_shade = (unsigned char) (i / green_colors_per_shade);
+	    high_shade = low_shade + 1;
+
+	    index = (unsigned short)
+		(((i - low_shade * green_colors_per_shade) / green_colors_per_shade) *
+		 (DITHER_LEVEL * DITHER_LEVEL + 1));
+
+	    low_shade *= green_mult;
+	    high_shade *= green_mult;
+
+	    green_dither[i] = (index << 16) + (high_shade << 8) + (low_shade);
+	}
+
+	/*  setup the blue information  */
+	{
+	    low_shade = (unsigned char) (i / blue_colors_per_shade);
+	    high_shade = low_shade + 1;
+
+	    index = (unsigned short)
+		(((i - low_shade * blue_colors_per_shade) / blue_colors_per_shade) *
+		 (DITHER_LEVEL * DITHER_LEVEL + 1));
+
+	    blue_dither[i] = (index << 16) + (high_shade << 8) + (low_shade);
+	}
+
+	/*  setup the gray information  */
+	{
+	    low_shade = (unsigned char) (i / gray_colors_per_shade);
+	    high_shade = low_shade + 1;
+
+	    index = (unsigned short)
+		(((i - low_shade * gray_colors_per_shade) / gray_colors_per_shade) *
+		 (DITHER_LEVEL * DITHER_LEVEL + 1));
+
+	    gray_dither[i] = (index << 16) + (high_shade << 8) + (low_shade);
+	}
+    }
+}
+
+void
+dither_line_color(unsigned char *src, unsigned char *dest, int y, int width)
+{
+    register long   a, b;
+    long           *ymod, xmod;
+
+    ymod = DM[y & DITHER_MASK];
+
+    while (width--) {
+	xmod = width & DITHER_MASK;
+
+	b = red_dither[*(src++)];
+	if (ymod[xmod] < b)
+	    b >>= 8;
+
+	a = green_dither[*(src++)];
+	if (ymod[xmod] < a)
+	    a >>= 8;
+	b += a;
+
+	a = blue_dither[*(src++)];
+	if (ymod[xmod] < a)
+	    a >>= 8;
+	b += a;
+
+	*(dest++) = b & 0xff;
+    }
+}
+
+void
+dither_line_gray(unsigned char *src, unsigned char *dest, int y, int width)
+{
+    long           *ymod, xmod;
+    register long   a,g;
+
+    ymod = DM[y & DITHER_MASK];
+
+    while (width--) {
+	xmod = width & DITHER_MASK;
+
+#if 1
+	g = (src[0]*3 + src[1]*6 + src[2]) / 10;
+	a = gray_dither[g];
+	src += 3;
+#else
+	a = gray_dither[*(src++)];
+#endif
+	if (ymod[xmod] < a)
+	    a >>= 8;
+
+	*(dest++) = a & 0xff;
+    }
+}
diff --git a/lib/a2jpeg-6b/dither.h b/lib/a2jpeg-6b/dither.h
new file mode 100644
index 0000000..b209de6
--- /dev/null
+++ b/lib/a2jpeg-6b/dither.h
@@ -0,0 +1,6 @@
+
+extern void (*dither_line)(unsigned char *, unsigned char *, int, int);
+
+void init_dither(int, int, int, int);
+void dither_line_color(unsigned char *, unsigned char *, int, int);
+void dither_line_gray(unsigned char *, unsigned char *, int, int);
diff --git a/lib/a2jpeg-6b/filter.c b/lib/a2jpeg-6b/filter.c
new file mode 100644
index 0000000..283a1fa
--- /dev/null
+++ b/lib/a2jpeg-6b/filter.c
@@ -0,0 +1,495 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <math.h>
+#include <string.h>
+
+#include "readers.h"
+#include "filter.h"
+
+int debug = 0;
+
+/* ----------------------------------------------------------------------- */
+
+static void
+op_grayscale(struct ida_image *src, struct ida_rect *rect,
+	     unsigned char *dst, int line, void *data)
+{
+    unsigned char *scanline;
+    int i,g;
+
+    scanline = src->data + line * src->i.width * 3;
+    memcpy(dst,scanline,src->i.width * 3);
+    if (line < rect->y1 || line >= rect->y2)
+	return;
+    dst      += 3*rect->x1;
+    scanline += 3*rect->x1;
+    for (i = rect->x1; i < rect->x2; i++) {
+	g = (scanline[0]*30 + scanline[1]*59+scanline[2]*11)/100;
+	dst[0] = g;
+	dst[1] = g;
+	dst[2] = g;
+	scanline += 3;
+	dst += 3;
+    }
+}
+
+/* ----------------------------------------------------------------------- */
+
+struct op_3x3_handle {
+    struct op_3x3_parm filter;
+    int *linebuf;
+};
+
+static void*
+op_3x3_init(struct ida_image *src, struct ida_rect *rect,
+	    struct ida_image_info *i, void *parm)
+{
+    struct op_3x3_parm *args = parm;
+    struct op_3x3_handle *h;
+
+    h = malloc(sizeof(*h));
+    memcpy(&h->filter,args,sizeof(*args));
+    h->linebuf = malloc(sizeof(int)*3*(src->i.width));
+
+    *i = src->i;
+    return h;
+}
+
+static int inline
+op_3x3_calc_pixel(struct op_3x3_parm *p, unsigned char *s1,
+		  unsigned char *s2, unsigned char *s3)
+{
+    int val = 0;
+
+    val += p->f1[0] * s1[0];
+    val += p->f1[1] * s1[3];
+    val += p->f1[2] * s1[6];
+    val += p->f2[0] * s2[0];
+    val += p->f2[1] * s2[3];
+    val += p->f2[2] * s2[6];
+    val += p->f3[0] * s3[0];
+    val += p->f3[1] * s3[3];
+    val += p->f3[2] * s3[6];
+    if (p->mul && p->div)
+	val = val * p->mul / p->div;
+    val += p->add;
+    return val;
+}
+
+static void
+op_3x3_calc_line(struct ida_image *src, struct ida_rect *rect,
+		 int *dst, unsigned int line, struct op_3x3_parm *p)
+{
+    unsigned char b1[9],b2[9],b3[9];
+    unsigned char *s1,*s2,*s3;
+    unsigned int i,left,right;
+
+    s1 = src->data + (line-1) * src->i.width * 3;
+    s2 = src->data +  line    * src->i.width * 3;
+    s3 = src->data + (line+1) * src->i.width * 3;
+    if (0 == line)
+	s1 = src->data + line * src->i.width * 3;
+    if (src->i.height-1 == line)
+	s3 = src->data + line * src->i.width * 3;
+
+    left  = rect->x1;
+    right = rect->x2;
+    if (0 == left) {
+	/* left border special case: dup first col */
+	memcpy(b1,s1,3);
+	memcpy(b2,s2,3);
+	memcpy(b3,s3,3);
+	memcpy(b1+3,s1,6);
+	memcpy(b2+3,s2,6);
+	memcpy(b3+3,s3,6);
+	dst[0] = op_3x3_calc_pixel(p,b1,b2,b3);
+	dst[1] = op_3x3_calc_pixel(p,b1+1,b2+1,b3+1);
+	dst[2] = op_3x3_calc_pixel(p,b1+2,b2+2,b3+2);
+	left++;
+    }
+    if (src->i.width == right) {
+	/* right border */
+	memcpy(b1,s1+src->i.width*3-6,6);
+	memcpy(b2,s2+src->i.width*3-6,6);
+	memcpy(b3,s3+src->i.width*3-6,6);
+	memcpy(b1+3,s1+src->i.width*3-3,3);
+	memcpy(b2+3,s2+src->i.width*3-3,3);
+	memcpy(b3+3,s3+src->i.width*3-3,3);
+	dst[src->i.width*3-3] = op_3x3_calc_pixel(p,b1,b2,b3);
+	dst[src->i.width*3-2] = op_3x3_calc_pixel(p,b1+1,b2+1,b3+1);
+	dst[src->i.width*3-1] = op_3x3_calc_pixel(p,b1+2,b2+2,b3+2);
+	right--;
+    }
+    
+    dst += 3*left;
+    s1  += 3*(left-1);
+    s2  += 3*(left-1);
+    s3  += 3*(left-1);
+    for (i = left; i < right; i++) {
+	dst[0] = op_3x3_calc_pixel(p,s1++,s2++,s3++);
+	dst[1] = op_3x3_calc_pixel(p,s1++,s2++,s3++);
+	dst[2] = op_3x3_calc_pixel(p,s1++,s2++,s3++);
+	dst += 3;
+    }
+}
+
+static void
+op_3x3_clip_line(unsigned char *dst, int *src, int left, int right)
+{
+    int i,val;
+
+    src += left*3;
+    dst += left*3;
+    for (i = left*3; i < right*3; i++) {
+	val = *(src++);
+	if (val < 0)
+	    val = 0;
+	if (val > 255)
+	    val = 255;
+	*(dst++) = val;
+    }
+}
+
+static void
+op_3x3_work(struct ida_image *src, struct ida_rect *rect,
+	    unsigned char *dst, int line, void *data)
+{
+    struct op_3x3_handle *h = data;
+    unsigned char *scanline;
+
+    scanline = src->data + line * src->i.width * 3;
+    memcpy(dst,scanline,src->i.width * 3);
+    if (line < rect->y1 || line >= rect->y2)
+	return;
+
+    op_3x3_calc_line(src,rect,h->linebuf,line,&h->filter);
+    op_3x3_clip_line(dst,h->linebuf,rect->x1,rect->x2);
+}
+
+static void
+op_3x3_free(void *data)
+{
+    struct op_3x3_handle *h = data;
+
+    free(h->linebuf);
+    free(h);
+}
+	    
+/* ----------------------------------------------------------------------- */
+
+struct op_sharpe_handle {
+    int  factor;
+    int  *linebuf;
+};
+
+static void*
+op_sharpe_init(struct ida_image *src, struct ida_rect *rect,
+	       struct ida_image_info *i, void *parm)
+{
+    struct op_sharpe_parm *args = parm;
+    struct op_sharpe_handle *h;
+
+    h = malloc(sizeof(*h));
+    h->factor  = args->factor;
+    h->linebuf = malloc(sizeof(int)*3*(src->i.width));
+
+    *i = src->i;
+    return h;
+}
+
+static void
+op_sharpe_work(struct ida_image *src, struct ida_rect *rect,
+	       unsigned char *dst, int line, void *data)
+{
+    static struct op_3x3_parm laplace = {
+	f1: {  1,  1,  1 },
+	f2: {  1, -8,  1 },
+	f3: {  1,  1,  1 },
+    };
+    struct op_sharpe_handle *h = data;
+    unsigned char *scanline;
+    int i;
+
+    scanline = src->data + line * src->i.width * 3;
+    memcpy(dst,scanline,src->i.width * 3);
+    if (line < rect->y1 || line >= rect->y2)
+	return;
+
+    op_3x3_calc_line(src,rect,h->linebuf,line,&laplace);
+    for (i = rect->x1*3; i < rect->x2*3; i++)
+	h->linebuf[i] = scanline[i] - h->linebuf[i] * h->factor / 256;
+    op_3x3_clip_line(dst,h->linebuf,rect->x1,rect->x2);
+}
+
+static void
+op_sharpe_free(void *data)
+{
+    struct op_sharpe_handle *h = data;
+
+    free(h->linebuf);
+    free(h);
+}
+
+/* ----------------------------------------------------------------------- */
+
+struct op_resize_state {
+    float xscale,yscale,inleft;
+    float *rowbuf;
+    unsigned int width,height,srcrow;
+};
+
+static void*
+op_resize_init(struct ida_image *src, struct ida_rect *rect,
+	       struct ida_image_info *i, void *parm)
+{
+    struct op_resize_parm *args = parm;
+    struct op_resize_state *h;
+
+    h = malloc(sizeof(*h));
+    h->width  = args->width;
+    h->height = args->height;
+    h->xscale = (float)args->width/src->i.width;
+    h->yscale = (float)args->height/src->i.height;
+    h->rowbuf = malloc(src->i.width * 3 * sizeof(float));
+    h->srcrow = 0;
+    h->inleft = 1;
+
+    *i = src->i;
+    i->width  = args->width;
+    i->height = args->height;
+    i->dpi    = args->dpi;
+    return h;
+}
+
+static void
+op_resize_work(struct ida_image *src, struct ida_rect *rect,
+	       unsigned char *dst, int line, void *data)
+{
+    struct op_resize_state *h = data;
+    float outleft,left,weight,d0,d1,d2;
+    unsigned char *csrcline;
+    float *fsrcline;
+    unsigned int i,sx,dx;
+
+    /* scale y */
+    memset(h->rowbuf, 0, src->i.width * 3 * sizeof(float));
+    outleft = 1/h->yscale;
+    while (outleft > 0  &&  h->srcrow < src->i.height) {
+	if (outleft < h->inleft) {
+	    weight     = outleft * h->yscale;
+	    h->inleft -= outleft;
+	    outleft    = 0;
+	} else {
+	    weight     = h->inleft * h->yscale;
+	    outleft   -= h->inleft;
+	    h->inleft  = 0;
+	}
+#if 0
+	if (debug)
+	    fprintf(stderr,"y:  %6.2f%%: %d/%d => %d/%d\n",
+		    weight*100,h->srcrow,src->height,line,h->height);
+#endif
+	csrcline = src->data + h->srcrow * src->i.width * 3;
+	for (i = 0; i < src->i.width * 3; i++)
+	    h->rowbuf[i] += (float)csrcline[i] * weight;
+	if (0 == h->inleft) {
+	    h->inleft = 1;
+	    h->srcrow++;
+	}
+    }
+
+    /* scale x */
+    left = 1;
+    fsrcline = h->rowbuf;
+    for (sx = 0, dx = 0; dx < h->width; dx++) {
+	d0 = d1 = d2 = 0;
+	outleft = 1/h->xscale;
+	while (outleft > 0  &&  dx < h->width  &&  sx < src->i.width) {
+	    if (outleft < left) {
+		weight   = outleft * h->xscale;
+		left    -= outleft;
+		outleft  = 0;
+	    } else {
+		weight   = left * h->xscale;
+		outleft -= left;
+		left     = 0;
+	    }
+#if 0
+	    if (debug)
+		fprintf(stderr," x: %6.2f%%: %d/%d => %d/%d\n",
+			weight*100,sx,src->width,dx,h->width);
+#endif
+	    d0 += fsrcline[3*sx+0] * weight;
+	    d1 += fsrcline[3*sx+1] * weight;
+	    d2 += fsrcline[3*sx+2] * weight;
+	    if (0 == left) {
+		left = 1;
+		sx++;
+	    }
+	}
+	dst[0] = d0;
+	dst[1] = d1;
+	dst[2] = d2;
+	dst += 3;
+    }
+}
+
+static void
+op_resize_done(void *data)
+{
+    struct op_resize_state *h = data;
+
+    free(h->rowbuf);
+    free(h);
+}
+    
+/* ----------------------------------------------------------------------- */
+
+struct op_rotate_state {
+    float angle,sina,cosa;
+    struct ida_rect calc;
+    int cx,cy;
+};
+
+static void*
+op_rotate_init(struct ida_image *src, struct ida_rect *rect,
+	       struct ida_image_info *i, void *parm)
+{
+    struct op_rotate_parm *args = parm;
+    struct op_rotate_state *h;
+    float  diag;
+
+    h = malloc(sizeof(*h));
+    h->angle = args->angle * 2 * M_PI / 360;
+    h->sina  = sin(h->angle);
+    h->cosa  = cos(h->angle);
+    h->cx    = (rect->x2 - rect->x1) / 2 + rect->x1;
+    h->cy    = (rect->y2 - rect->y1) / 2 + rect->y1;
+
+    /* the area we have to process (worst case: 45°) */
+    diag     = sqrt((rect->x2 - rect->x1)*(rect->x2 - rect->x1) +
+		    (rect->y2 - rect->y1)*(rect->y2 - rect->y1))/2;
+    h->calc.x1 = h->cx - diag;
+    h->calc.x2 = h->cx + diag;
+    h->calc.y1 = h->cy - diag;
+    h->calc.y2 = h->cy + diag;
+    if (h->calc.x1 < 0)
+	h->calc.x1 = 0;
+    if (h->calc.x2 > src->i.width)
+	h->calc.x2 = src->i.width;
+    if (h->calc.y1 < 0)
+	h->calc.y1 = 0;
+    if (h->calc.y2 > src->i.height)
+	h->calc.y2 = src->i.height;
+
+    *i = src->i;
+    return h;
+}
+
+static inline
+unsigned char* op_rotate_getpixel(struct ida_image *src, struct ida_rect *rect,
+				  int sx, int sy, int dx, int dy)
+{
+    static unsigned char black[] = { 0, 0, 0};
+
+    if (sx < rect->x1 || sx >= rect->x2 ||
+	sy < rect->y1 || sy >= rect->y2) {
+	if (dx < rect->x1 || dx >= rect->x2 ||
+	    dy < rect->y1 || dy >= rect->y2)
+	    return src->data + dy * src->i.width * 3 + dx * 3;
+	return black;
+    }
+    return src->data + sy * src->i.width * 3 + sx * 3;
+}
+
+static void
+op_rotate_work(struct ida_image *src, struct ida_rect *rect,
+	       unsigned char *dst, int y, void *data)
+{
+    struct op_rotate_state *h = data;
+    unsigned char *pix;
+    float fx,fy,w;
+    int x,sx,sy;
+
+    pix = src->data + y * src->i.width * 3;
+    memcpy(dst,pix,src->i.width * 3);
+    if (y < h->calc.y1 || y >= h->calc.y2)
+	return;
+
+    dst += 3*h->calc.x1;
+    memset(dst, 0, (h->calc.x2-h->calc.x1) * 3);
+    for (x = h->calc.x1; x < h->calc.x2; x++, dst+=3) {
+	fx = h->cosa * (x - h->cx) - h->sina * (y - h->cy) + h->cx;
+	fy = h->sina * (x - h->cx) + h->cosa * (y - h->cy) + h->cy;
+	sx = (int)fx;
+	sy = (int)fy;
+	if (fx < 0)
+	    sx--;
+	if (fy < 0)
+	    sy--;
+	fx -= sx;
+	fy -= sy;
+
+	pix = op_rotate_getpixel(src,rect,sx,sy,x,y);
+	w = (1-fx) * (1-fy);
+	dst[0] += pix[0] * w;
+	dst[1] += pix[1] * w;
+	dst[2] += pix[2] * w;
+	pix = op_rotate_getpixel(src,rect,sx+1,sy,x,y);
+	w = fx * (1-fy);
+	dst[0] += pix[0] * w;
+	dst[1] += pix[1] * w;
+	dst[2] += pix[2] * w;
+	pix = op_rotate_getpixel(src,rect,sx,sy+1,x,y);
+	w = (1-fx) * fy;
+	dst[0] += pix[0] * w;
+	dst[1] += pix[1] * w;
+	dst[2] += pix[2] * w;
+	pix = op_rotate_getpixel(src,rect,sx+1,sy+1,x,y);
+	w = fx * fy;
+	dst[0] += pix[0] * w;
+	dst[1] += pix[1] * w;
+	dst[2] += pix[2] * w;
+    }
+}
+
+static void
+op_rotate_done(void *data)
+{
+    struct op_rotate_state *h = data;
+
+    free(h);
+}
+
+/* ----------------------------------------------------------------------- */
+
+struct ida_op desc_grayscale = {
+    name:  "grayscale",
+    init:  op_none_init,
+    work:  op_grayscale,
+    done:  op_none_done,
+};
+struct ida_op desc_3x3 = {
+    name:  "3x3",
+    init:  op_3x3_init,
+    work:  op_3x3_work,
+    done:  op_3x3_free,
+};
+struct ida_op desc_sharpe = {
+    name:  "sharpe",
+    init:  op_sharpe_init,
+    work:  op_sharpe_work,
+    done:  op_sharpe_free,
+};
+struct ida_op desc_resize = {
+    name:  "resize",
+    init:  op_resize_init,
+    work:  op_resize_work,
+    done:  op_resize_done,
+};
+struct ida_op desc_rotate = {
+    name:  "rotate",
+    init:  op_rotate_init,
+    work:  op_rotate_work,
+    done:  op_rotate_done,
+};
diff --git a/lib/a2jpeg-6b/filter.h b/lib/a2jpeg-6b/filter.h
new file mode 100644
index 0000000..37d67ee
--- /dev/null
+++ b/lib/a2jpeg-6b/filter.h
@@ -0,0 +1,27 @@
+
+struct op_3x3_parm {
+    int f1[3];
+    int f2[3];
+    int f3[3];
+    int mul,div,add;
+};
+
+struct op_sharpe_parm {
+    int factor;
+};
+
+struct op_resize_parm {
+    int width;
+    int height;
+    int dpi;
+};
+
+struct op_rotate_parm {
+    int angle;
+};
+
+extern struct ida_op desc_grayscale;
+extern struct ida_op desc_3x3;
+extern struct ida_op desc_sharpe;
+extern struct ida_op desc_resize;
+extern struct ida_op desc_rotate;
diff --git a/lib/a2jpeg-6b/genthumbnail.c b/lib/a2jpeg-6b/genthumbnail.c
new file mode 100644
index 0000000..23cbab5
--- /dev/null
+++ b/lib/a2jpeg-6b/genthumbnail.c
@@ -0,0 +1,296 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <stddef.h>
+#include <unistd.h>
+#include <errno.h>
+#include <string.h>
+
+#include <jpeglib.h>
+//#include "transupp.h"		/* Support routines for jpegtran */
+#include "jpegtools.h"
+
+#include "misc.h"
+
+#include "readers.h"
+#include "filter.h"
+#include "genthumbnail.h"
+
+/* ---------------------------------------------------------------------- */
+
+struct ida_image*
+read_jpeg(char *filename)
+{
+    struct ida_image *img;
+    FILE *fp;
+    unsigned int y;
+    void *data;
+    
+    /* open file */
+    if (NULL == (fp = fopen(filename, "r"))) {
+	fprintf(stderr,"open %s: %s\n",filename,strerror(errno));
+	return NULL;
+    }
+
+    /* load image */
+    img = malloc(sizeof(*img));
+    memset(img,0,sizeof(*img));
+    data = jpeg_loader.init(fp,filename,0,&img->i,0);
+    if (NULL == data) {
+	fprintf(stderr,"loading %s [%s] FAILED\n",filename,jpeg_loader.name);
+	free(img);
+	return NULL;
+    }
+    img->data = malloc(img->i.width * img->i.height * 3);
+    for (y = 0; y < img->i.height; y++)
+  	jpeg_loader.read(img->data + img->i.width * 3 * y, y, data);
+    jpeg_loader.done(data);
+    return img;
+}
+
+
+/* ---------------------------------------------------------------------- */
+
+struct ida_image*
+a2_scale_thumbnail(struct ida_image *src, int scale_h, int scale_w)
+{
+    struct op_resize_parm p;
+    struct ida_rect  rect;
+    struct ida_image *dest;
+    void *data;
+    unsigned int y;
+    float xs,ys;
+
+    dest = malloc(sizeof(*dest));
+    memset(dest,0,sizeof(*dest));
+    memset(&rect,0,sizeof(rect));
+    memset(&p,0,sizeof(p));
+
+    p.width  = src->i.width  * scale_w;
+    p.height = src->i.height * scale_h;
+    p.dpi    = src->i.dpi;
+    if (0 == p.width)
+	p.width = 1;
+    if (0 == p.height)
+	p.height = 1;
+
+    data = desc_resize.init(src,&rect,&dest->i,&p);
+    dest->data = malloc(dest->i.width * dest->i.height * 3);
+    for (y = 0; y < dest->i.height; y++)
+	desc_resize.work(src,&rect,
+			 dest->data + 3 * dest->i.width * y,
+			 y, data);
+    desc_resize.done(data);
+    return dest;
+}
+
+/* ---------------------------------------------------------------------- */
+
+struct ida_image*
+scale_thumbnail(struct ida_image *src, int max)
+{
+    struct op_resize_parm p;
+    struct ida_rect  rect;
+    struct ida_image *dest;
+    void *data;
+    unsigned int y;
+    float xs,ys,scale;
+    
+    xs = (float)max / src->i.width;
+    ys = (float)max / src->i.height;
+    scale = (xs < ys) ? xs : ys;
+
+    float scale_w = (float)max / src->i.width;
+    float scale_h = (float)max / src->i.height;
+
+    dest = malloc(sizeof(*dest));
+    memset(dest,0,sizeof(*dest));
+    memset(&rect,0,sizeof(rect));
+    memset(&p,0,sizeof(p));
+    
+    p.width  = src->i.width  * scale_w;
+    p.height = src->i.height * scale_h;
+    p.dpi    = src->i.dpi;
+    if (0 == p.width)
+	p.width = 1;
+    if (0 == p.height)
+	p.height = 1;
+    
+    data = desc_resize.init(src,&rect,&dest->i,&p);
+    dest->data = malloc(dest->i.width * dest->i.height * 3);
+    for (y = 0; y < dest->i.height; y++)
+	desc_resize.work(src,&rect,
+			 dest->data + 3 * dest->i.width * y,
+			 y, data);
+    desc_resize.done(data);
+    return dest;
+}
+
+/* ---------------------------------------------------------------------- */
+
+#define min(x,y) (x<y?x:y)
+struct ida_image*
+ece459_scale_thumbnail(struct ida_image *src, int max_dim)
+{
+    struct op_resize_parm p;
+    struct ida_rect  rect;
+    struct ida_image *dest;
+    void *data;
+    unsigned int y;
+
+    float scale_w = (float)max_dim / src->i.width;
+    float scale_h = (float)max_dim / src->i.height;
+
+    dest = malloc(sizeof(*dest));
+    memset(dest,0,sizeof(*dest));
+    memset(&rect,0,sizeof(rect));
+    memset(&p,0,sizeof(p));
+
+    p.width  = min(max_dim, src->i.width);
+    p.height = min(max_dim, src->i.height);
+    p.dpi    = src->i.dpi;
+    if (0 == p.width)
+	p.width = 1;
+    if (0 == p.height)
+	p.height = 1;
+
+    data = desc_resize.init(src,&rect,&dest->i,&p);
+    dest->data = malloc(dest->i.width * dest->i.height * 3);
+    for (y = 0; y < dest->i.height; y++)
+	desc_resize.work(src,&rect,
+			 dest->data + 3 * dest->i.width * y,
+			 y, data);
+    desc_resize.done(data);
+    return dest;
+}
+
+/* ---------------------------------------------------------------------- */
+
+struct thc {
+    struct jpeg_compress_struct dst;
+    struct jpeg_error_mgr err;
+    unsigned char *out;
+    int osize;
+};
+
+static void thc_dest_init(struct jpeg_compress_struct *cinfo)
+{
+    struct thc *h  = container_of(cinfo, struct thc, dst);
+    cinfo->dest->next_output_byte = h->out;
+    cinfo->dest->free_in_buffer   = h->osize;
+}
+
+static boolean thc_dest_flush(struct jpeg_compress_struct *cinfo)
+{
+    fprintf(stderr,"jpeg: panic: output buffer full\n");
+    exit(1);
+}
+
+static void thc_dest_term(struct jpeg_compress_struct *cinfo)
+{
+    struct thc *h  = container_of(cinfo, struct thc, dst);
+    h->osize -= cinfo->dest->free_in_buffer;
+}
+
+static struct jpeg_destination_mgr thumbnail_dst = {
+    .init_destination    = thc_dest_init,
+    .empty_output_buffer = thc_dest_flush,
+    .term_destination    = thc_dest_term,
+};
+
+int
+compress_thumbnail(struct ida_image *img, char *dest, int max)
+{
+    struct thc thc;
+    unsigned char *line;
+    unsigned int i;
+
+    memset(&thc,0,sizeof(thc));
+    thc.dst.err = jpeg_std_error(&thc.err);
+    jpeg_create_compress(&thc.dst);
+    thc.dst.dest = &thumbnail_dst;
+    thc.out = dest;
+    thc.osize = max;
+
+    thc.dst.image_width  = img->i.width;
+    thc.dst.image_height = img->i.height;
+    thc.dst.input_components = 3;
+    thc.dst.in_color_space = JCS_RGB;
+    jpeg_set_defaults(&thc.dst);
+    jpeg_start_compress(&thc.dst, TRUE);
+
+    for (i = 0, line = img->data; i < img->i.height; i++, line += img->i.width*3)
+        jpeg_write_scanlines(&thc.dst, &line, 1);
+    
+    jpeg_finish_compress(&(thc.dst));
+    jpeg_destroy_compress(&(thc.dst));
+
+    return thc.osize;
+}
+
+/* ---------------------------------------------------------------------- */
+
+int create_thumbnail(char *filename, unsigned char *dest, int max)
+{
+    struct ida_image *img,*thumb;
+    int size;
+
+    //fprintf(stderr,"%s: read ",filename);
+    img = read_jpeg(filename);
+    if (!img) {
+	fprintf(stderr,"FAILED\n");
+	return -1;
+    }
+    
+    //fprintf(stderr,"scale ");
+    thumb = scale_thumbnail(img,160);
+    if (!thumb) {
+	free(img->data);
+	free(img);
+	fprintf(stderr,"FAILED\n");
+	return -1;
+    }
+
+    //fprintf(stderr,"compress ");
+    size = compress_thumbnail(thumb,dest,max);
+
+    /* cleanup */
+    free(img->data);
+    free(img);
+    free(thumb->data);
+    free(thumb);
+    return size;
+}
+
+/* ---------------------------------------------------------------------- */
+
+#if 0
+
+#define THUMB_MAX 65536
+
+static int handle_image(char *filename)
+{
+    char *dest;
+    int size;
+
+    dest = malloc(THUMB_MAX);
+    size = create_thumbnail(filename,dest,THUMB_MAX);
+
+    fprintf(stderr,"transform ");
+    jpeg_transform_inplace(filename, JXFORM_NONE, NULL,
+			   dest, size, JFLAG_UPDATE_THUMBNAIL);
+
+    fprintf(stderr,"done\n");
+    return 0;
+}
+
+int main(int argc, char *argv[])
+{
+    int i;
+
+    for (i = 1; i < argc; i++)
+	handle_image(argv[i]);
+    return 0;
+}
+
+#endif
+
diff --git a/lib/a2jpeg-6b/genthumbnail.h b/lib/a2jpeg-6b/genthumbnail.h
new file mode 100644
index 0000000..fa0c2ed
--- /dev/null
+++ b/lib/a2jpeg-6b/genthumbnail.h
@@ -0,0 +1,11 @@
+int create_thumbnail(char *filename, unsigned char *dest, int max);
+
+//Scale image to (max x max)
+struct ida_image* ece459_scale_thumbnail(struct ida_image *src, int max);
+
+struct ida_image* scale_thumbnail(struct ida_image *src, int max);
+
+int compress_thumbnail(struct ida_image *img, char *dest, int max);
+
+struct ida_image* read_jpeg(char *filename);
+
diff --git a/lib/a2jpeg-6b/ida.c b/lib/a2jpeg-6b/ida.c
new file mode 100644
index 0000000..65e1d0a
--- /dev/null
+++ b/lib/a2jpeg-6b/ida.c
@@ -0,0 +1,1909 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <errno.h>
+#include <signal.h>
+#include <locale.h>
+#include <langinfo.h>
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/wait.h>
+
+#include <X11/Intrinsic.h>
+#include <X11/StringDefs.h>
+#include <Xm/Xm.h>
+#include <Xm/Primitive.h>
+#include <Xm/Label.h>
+#include <Xm/CascadeB.h>
+#include <Xm/PushB.h>
+#include <Xm/Separator.h>
+#include <Xm/RowColumn.h>
+#include <Xm/ScrolledW.h>
+#include <Xm/Protocols.h>
+#include <Xm/List.h>
+#include <Xm/Form.h>
+#include <Xm/MessageB.h>
+#include <Xm/SelectioB.h>
+#include <Xm/Scale.h>
+#include <Xm/Text.h>
+#include <Xm/FileSB.h>
+#include <Xm/ToggleB.h>
+#include <Xm/DrawingA.h>
+#include <Xm/Transfer.h>
+#include <Xm/TransferP.h>
+
+#include "RegEdit.h"
+#include "ida.h"
+#include "x11.h"
+#include "man.h"
+#include "readers.h"
+#include "writers.h"
+#include "viewer.h"
+#include "op.h"
+#include "lut.h"
+#include "filter.h"
+#include "color.h"
+#include "icons.h"
+#include "browser.h"
+#include "filelist.h"
+#include "xdnd.h"
+#include "selections.h"
+#include "sane.h"
+#include "curl.h"
+#include "idaconfig.h"
+
+/* ---------------------------------------------------------------------- */
+
+static void popup_ac(Widget, XEvent*, String*, Cardinal*);
+static void exit_ac(Widget, XEvent*, String*, Cardinal*);
+static void next_ac(Widget, XEvent*, String*, Cardinal*);
+static void prev_ac(Widget, XEvent*, String*, Cardinal*);
+static void next_page_ac(Widget, XEvent*, String*, Cardinal*);
+static void prev_page_ac(Widget, XEvent*, String*, Cardinal*);
+static void zoom_ac(Widget, XEvent*, String*, Cardinal*);
+static void scroll_ac(Widget, XEvent*, String*, Cardinal*);
+static void debug_ac(Widget, XEvent*, String*, Cardinal*);
+static void load_ac(Widget, XEvent*, String*, Cardinal*);
+static void save_ac(Widget, XEvent*, String*, Cardinal*);
+static void scan_ac(Widget, XEvent*, String*, Cardinal*);
+static void print_ac(Widget, XEvent*, String*, Cardinal*);
+
+static void undo_ac(Widget, XEvent*, String*, Cardinal*);
+static void filter_ac(Widget, XEvent*, String*, Cardinal*);
+static void gamma_ac(Widget, XEvent*, String*, Cardinal*);
+static void bright_ac(Widget, XEvent*, String*, Cardinal*);
+static void contrast_ac(Widget, XEvent*, String*, Cardinal*);
+static void color_ac(Widget, XEvent*, String*, Cardinal*);
+static void f3x3_ac(Widget, XEvent*, String*, Cardinal*);
+static void resize_ac(Widget, XEvent*, String*, Cardinal*);
+static void rotate_ac(Widget, XEvent*, String*, Cardinal*);
+static void sharpe_ac(Widget, XEvent*, String*, Cardinal*);
+
+static XtActionsRec actionTable[] = {
+    { "Exit",     exit_ac      },
+    { "Next",     next_ac      },
+    { "Prev",     prev_ac      },
+    { "NextPage", next_page_ac },
+    { "PrevPage", prev_page_ac },
+    { "Zoom",     zoom_ac      },
+    { "Scroll",   scroll_ac    },
+    { "Debug",    debug_ac     },
+    { "Popup",    popup_ac     },
+    { "Man",      man_action   },
+    { "Load",     load_ac      },
+    { "Save",     save_ac      },
+    { "Scan",     scan_ac      },
+    { "Print",    print_ac     },
+    { "Browser",  browser_ac   },
+    { "Filelist", filelist_ac  },
+
+    { "Undo",     undo_ac      },
+    { "Filter",   filter_ac    },
+    { "Gamma",    gamma_ac     },
+    { "Bright",   bright_ac    },
+    { "Contrast", contrast_ac  },
+    { "Color",    color_ac     },
+    { "F3x3",     f3x3_ac      },
+    { "Resize",   resize_ac    },
+    { "Rotate",   rotate_ac    },
+    { "Sharpe",   sharpe_ac    },
+
+    { "Ipc",      ipc_ac       },
+    { "Xdnd",     XdndAction   },
+};
+
+/* ---------------------------------------------------------------------- */
+
+XtAppContext       app_context;
+Display            *dpy;
+Widget             app_shell;
+int                gray=0;
+char               *binary;
+struct ida_viewer  *ida;
+
+/* ---------------------------------------------------------------------- */
+
+struct ARGS args;
+unsigned int pcd_res;
+unsigned int sane_res;
+
+XtResource args_desc[] = {
+    {
+	"debug",
+	XtCBoolean, XtRBoolean, sizeof(Boolean),
+	XtOffset(struct ARGS*,debug),
+	XtRString, "false"
+    },{
+	"help",
+	XtCBoolean, XtRBoolean, sizeof(Boolean),
+	XtOffset(struct ARGS*,help),
+	XtRString, "false"
+    },{
+	"testload",
+	XtCBoolean, XtRBoolean, sizeof(Boolean),
+	XtOffset(struct ARGS*,testload),
+	XtRString, "false"
+    }
+};
+const int args_count = XtNumber(args_desc);
+
+XrmOptionDescRec opt_desc[] = {
+    { "-d",          "debug",       XrmoptionNoArg,  "true" },
+    { "-debug",      "debug",       XrmoptionNoArg,  "true" },
+    { "-testload",   "testload",    XrmoptionNoArg,  "true" },
+    { "-h",          "help",        XrmoptionNoArg,  "true" },
+    { "-help",       "help",        XrmoptionNoArg,  "true" },
+    { "--help",      "help",        XrmoptionNoArg,  "true" },
+};
+const int opt_count = (sizeof(opt_desc)/sizeof(XrmOptionDescRec));
+
+static String fallback_ressources[] = {
+#include "Ida.ad.h"
+    NULL
+};
+
+/* ---------------------------------------------------------------------- */
+
+static struct ida_writer *cwriter;
+static char *save_filename;
+static char *print_command;
+
+static Widget control_shell,status;
+static Atom   wm_delete_window;
+
+static Widget view,loadbox,savebox,printbox;
+
+/* file list */
+static Widget wlist;
+static char **files = NULL;
+static int  cfile   = -1;
+static int  nfiles  = 0;
+static int  cpage   = 0;
+static int  npages  = 1;
+
+/* filter controls */
+static int gamma_val    = 100;
+static int bright_val   = 0;
+static int contrast_val = 0;
+static int rotate_val   = 0;
+static int sharpe_val   = 10;
+
+static struct MY_TOPLEVELS {
+    char        *name;
+    Widget      *shell;
+    int         mapped;
+} my_toplevels [] = {
+    { "control",   &control_shell },
+};
+#define TOPLEVELS (sizeof(my_toplevels)/sizeof(struct MY_TOPLEVELS))
+
+/* ---------------------------------------------------------------------- */
+
+static void
+popup_ac(Widget widget, XEvent *event,
+	 String *params, Cardinal *num_params)
+{
+    unsigned int i;
+
+    /* which window we are talking about ? */
+    if (*num_params > 0) {
+	for (i = 0; i < TOPLEVELS; i++) {
+	    if (0 == strcasecmp(my_toplevels[i].name,params[0]))
+		break;
+	}
+	if (i == TOPLEVELS) {
+	    fprintf(stderr,"PopupAction: oops: shell not found (name=%s)\n",
+		    params[0]);
+	    return;
+	}
+    } else {
+	for (i = 0; i < TOPLEVELS; i++) {
+	    if (*(my_toplevels[i].shell) == widget)
+		break;
+	}
+	if (i == TOPLEVELS) {
+	    fprintf(stderr,"PopupAction: oops: shell not found (%p:%s)\n",
+		    widget,XtName(widget));
+	    return;
+	}
+    }
+
+    /* popup/down window */
+    if (!my_toplevels[i].mapped) {
+	XtPopup(*(my_toplevels[i].shell), XtGrabNone);
+	my_toplevels[i].mapped = 1;
+    } else {
+	XtPopdown(*(my_toplevels[i].shell));
+	my_toplevels[i].mapped = 0;
+    }
+}
+
+static void
+popupdown_cb(Widget widget, XtPointer clientdata, XtPointer call_data)
+{
+    int i = 0;
+    popup_ac(clientdata, NULL, NULL, &i);
+}
+
+/* ---------------------------------------------------------------------- */
+
+void
+destroy_cb(Widget widget, XtPointer clientdata, XtPointer call_data)
+{
+    XtDestroyWidget(clientdata);
+}
+
+void
+action_cb(Widget widget, XtPointer clientdata, XtPointer call_data)
+{
+    char *calls, *action, *argv[16]; /* max: F3x3(9 args) */
+    int argc;
+
+    calls = strdup(clientdata);
+    action = strtok(calls,"(),");
+    for (argc = 0; NULL != (argv[argc] = strtok(NULL,"(),")); argc++)
+	/* nothing */;
+    XtCallActionProc(widget,action,NULL,argv,argc);
+    free(calls);
+}
+
+static void
+about_cb(Widget widget, XtPointer clientdata, XtPointer call_data)
+{
+    Widget msgbox;
+    
+    msgbox = XmCreateInformationDialog(app_shell,"aboutbox",NULL,0);
+    XtUnmanageChild(XmMessageBoxGetChild(msgbox,XmDIALOG_HELP_BUTTON));
+    XtUnmanageChild(XmMessageBoxGetChild(msgbox,XmDIALOG_CANCEL_BUTTON));
+    XtAddCallback(msgbox,XmNokCallback,destroy_cb,msgbox);
+    XtManageChild(msgbox);
+}
+
+#if 0
+static void
+sorry_cb(Widget widget, XtPointer clientdata, XtPointer call_data)
+{
+    Widget msgbox;
+    
+    msgbox = XmCreateErrorDialog(app_shell,"sorrybox",NULL,0);
+    XtUnmanageChild(XmMessageBoxGetChild(msgbox,XmDIALOG_HELP_BUTTON));
+    XtUnmanageChild(XmMessageBoxGetChild(msgbox,XmDIALOG_CANCEL_BUTTON));
+    XtAddCallback(msgbox,XmNokCallback,destroy_cb,msgbox);
+    XtManageChild(msgbox);
+}
+#endif
+
+void
+debug_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
+{
+    unsigned int i;
+
+    fprintf(stderr,"Debug:");
+    for (i = 0; i < *num; i++)
+	fprintf(stderr," %s",params[i]);
+    fprintf(stderr,"\n");
+}
+
+static void
+display_cb(Widget widget, XtPointer clientdata, XtPointer call_data)
+{
+    XmDisplayCallbackStruct *arg = call_data;
+    
+    switch (arg->reason) {
+    case XmCR_NO_RENDITION:
+	fprintf(stderr,"display_cb: no rendition: \"%s\"\n",arg->tag);
+	break;
+    case XmCR_NO_FONT:
+	fprintf(stderr,"display_cb: no font: \"%s\"\n",arg->font_name);
+	break;
+    default:
+	/* should not happen */
+	fprintf(stderr,"display_cb: unknown reason [%d]\n",arg->reason);
+	break;
+    }
+}
+
+/* ---------------------------------------------------------------------- */
+
+struct ptr_list {
+    struct ptr_list *next;
+    Widget widget;
+};
+struct ptr_list *ptr_head;
+
+void ptr_register(Widget widget)
+{
+    struct ptr_list *item;
+
+    if (XtWindow(widget))
+	XDefineCursor(XtDisplay(widget), XtWindow(widget),
+		      ptrs[POINTER_NORMAL]);
+    item = malloc(sizeof(*item));
+    memset(item,0,sizeof(*item));
+    item->widget = widget;
+    item->next = ptr_head;
+    ptr_head = item;
+}
+
+void ptr_unregister(Widget widget)
+{
+    struct ptr_list *item,*fitem;
+
+    if (ptr_head->widget == widget) {
+	fitem = ptr_head;
+	ptr_head = ptr_head->next;
+	free(fitem);
+	return;
+    }
+    for (item = ptr_head; NULL != item->next; item = item->next) {
+	if (item->next->widget == widget) {
+	    fitem = item->next;
+	    item->next = fitem->next;
+	    free(fitem);
+	    return;
+	}
+    }
+    /* shouldn't happen */
+    fprintf(stderr,"Oops: widget not found in list\n");
+}
+
+void ptr_busy(void)
+{
+    struct ptr_list *item;
+
+    for (item = ptr_head; NULL != item; item = item->next) {
+	if (!XtWindow(item->widget))
+	    continue;
+	XDefineCursor(XtDisplay(item->widget), XtWindow(item->widget),
+		      ptrs[POINTER_BUSY]);
+    }
+    XSync(dpy,False);
+}
+
+void ptr_idle(void)
+{
+    struct ptr_list *item;
+
+    for (item = ptr_head; NULL != item; item = item->next) {
+	if (!XtWindow(item->widget))
+	    continue;
+	XDefineCursor(XtDisplay(item->widget), XtWindow(item->widget),
+		      ptrs[POINTER_NORMAL]);
+    }
+}
+
+/* ---------------------------------------------------------------------- */
+
+static Boolean
+exit_wp(XtPointer client_data)
+{
+    exit(0);
+}
+
+static void
+exit_cb(Widget widget, XtPointer client_data, XtPointer calldata)
+{
+    XtAppAddWorkProc(app_context,exit_wp, NULL);
+    XtDestroyWidget(app_shell);
+}
+
+void
+exit_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
+{
+    exit_cb(widget,NULL,NULL);
+}
+
+/* ---------------------------------------------------------------------- */
+
+static void
+list_update(void)
+{
+    XmStringTable tab;
+    int i;
+
+    tab = malloc(nfiles * sizeof(XmString));
+    for (i = 0; i < nfiles; i++)
+	tab[i] = XmStringGenerate(files[i], NULL, XmMULTIBYTE_TEXT, NULL);
+    XtVaSetValues(wlist,
+		  XmNitems, tab,
+		  XmNitemCount, nfiles,
+		  NULL);
+    for (i = 0; i < nfiles; i++)
+	XmStringFree(tab[i]);
+    free(tab);
+}
+
+static int
+list_append(char *filename)
+{
+    int i;
+
+    for (i = 0; i < nfiles; i++)
+	if (0 == strcmp(files[i],filename))
+	    return i;
+    files = realloc(files,sizeof(char*)*(nfiles+1));
+    files[nfiles] = strdup(filename);
+    nfiles++;
+    return nfiles-1;
+}
+
+static void
+list_cb(Widget widget, XtPointer client_data, XtPointer calldata)
+{
+    XmListCallbackStruct *list = calldata;
+
+    if (0 == list->selected_item_count)
+	return;
+    cfile = list->selected_item_positions[0]-1;
+    cpage = 0;
+    npages = viewer_loadimage(ida,files[cfile],cpage);
+    if (-1 == npages)
+	return;
+    resize_shell();
+}
+
+static void
+pcd_set(Widget widget)
+{
+    WidgetList items;
+    Cardinal nitems;
+    unsigned int i;
+    int value;
+
+    value = GET_PHOTOCD_RES();
+    XtVaGetValues(widget,XtNchildren,&items,
+		  XtNnumChildren,&nitems,NULL);
+    for (i = 0; i < nitems; i++)
+	XmToggleButtonSetState(items[i],value == i+1,False);
+    pcd_res      = value;
+}
+
+static void
+pcd_cb(Widget widget, XtPointer client_data, XtPointer calldata)
+{
+    cfg_set_int(O_PHOTOCD_RES,(intptr_t)client_data);
+    pcd_set(XtParent(widget));
+}
+
+static void
+cfg_bool_cb(Widget widget, XtPointer client_data, XtPointer calldata)
+{
+    char *option = XtName(widget);
+    Boolean value = XmToggleButtonGetState(widget);
+    cfg_set_bool(O_OPTIONS, option, value);
+}
+
+static void
+cfg_save_cb(Widget widget, XtPointer client_data, XtPointer calldata)
+{
+    ida_write_config();
+}
+
+static void
+create_control(void)
+{
+    Widget form,menubar,tool,menu,smenu,push;
+
+    control_shell = XtVaAppCreateShell("ctrl","Iv",
+				       topLevelShellWidgetClass,
+				       dpy,
+				       XtNclientLeader,app_shell,
+				       XmNdeleteResponse,XmDO_NOTHING,
+				       NULL);
+    XmdRegisterEditres(control_shell);
+    XmAddWMProtocolCallback(control_shell,wm_delete_window,
+			    popupdown_cb,control_shell);
+
+    /* widgets */
+    form = XtVaCreateManagedWidget("form", xmFormWidgetClass, control_shell,
+				   NULL);
+    menubar = XmCreateMenuBar(form,"bar",NULL,0);
+    XtManageChild(menubar);
+    tool = XtVaCreateManagedWidget("tool",xmRowColumnWidgetClass, form,
+				   NULL);
+    status = XtVaCreateManagedWidget("status", xmLabelWidgetClass, form,
+				     NULL);
+    wlist = XmCreateScrolledList(form,"list",NULL,0);
+    XtManageChild(wlist);
+    XtAddCallback(wlist,XmNdefaultActionCallback,list_cb,NULL);
+    XtAddCallback(wlist,XmNdestinationCallback,selection_dest,NULL);
+    dnd_add(wlist);
+    
+    /* menu - file */
+    menu = XmCreatePulldownMenu(menubar,"fileM",NULL,0);
+    XtVaCreateManagedWidget("file",xmCascadeButtonWidgetClass,menubar,
+			    XmNsubMenuId,menu,NULL);
+    push = XtVaCreateManagedWidget("load",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Load()");
+    push = XtVaCreateManagedWidget("save",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Save()");
+    push = XtVaCreateManagedWidget("browse",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Browser()");
+    push = XtVaCreateManagedWidget("filelist",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Filelist()");
+    XtVaCreateManagedWidget("sep",xmSeparatorWidgetClass,menu,NULL);
+#ifdef HAVE_LIBSANE
+    sane_menu(menu);
+#endif
+    push = XtVaCreateManagedWidget("print",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Print()");
+    XtVaCreateManagedWidget("sep",xmSeparatorWidgetClass,menu,NULL);
+    push = XtVaCreateManagedWidget("quit",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,exit_cb,NULL);
+
+    /* menu - edit */
+    menu = XmCreatePulldownMenu(menubar,"editM",NULL,0);
+    XtVaCreateManagedWidget("edit",xmCascadeButtonWidgetClass,menubar,
+			    XmNsubMenuId,menu,NULL);
+    push = XtVaCreateManagedWidget("undo",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Undo()");
+    XtVaCreateManagedWidget("sep",xmSeparatorWidgetClass,menu,NULL);
+    push = XtVaCreateManagedWidget("copy",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Ipc(copy)");
+    push = XtVaCreateManagedWidget("paste",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Ipc(paste)");
+    XtVaCreateManagedWidget("sep",xmSeparatorWidgetClass,menu,NULL);
+    push = XtVaCreateManagedWidget("flipv",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Filter(flip-vert)");
+    push = XtVaCreateManagedWidget("fliph",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Filter(flip-horz)");
+    push = XtVaCreateManagedWidget("rotcw",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Filter(rotate-cw)");
+    push = XtVaCreateManagedWidget("rotccw",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Filter(rotate-ccw)");
+    push = XtVaCreateManagedWidget("invert",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Filter(invert)");
+    XtVaCreateManagedWidget("sep",xmSeparatorWidgetClass,menu,NULL);
+    push = XtVaCreateManagedWidget("crop",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Filter(crop)");
+    push = XtVaCreateManagedWidget("acrop",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Filter(autocrop)");
+    push = XtVaCreateManagedWidget("scale",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Resize()");
+    push = XtVaCreateManagedWidget("rotany",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Rotate()");
+
+    /* menu - filters / operations */
+    menu = XmCreatePulldownMenu(menubar,"opM",NULL,0);
+    XtVaCreateManagedWidget("op",xmCascadeButtonWidgetClass,menubar,
+			    XmNsubMenuId,menu,NULL);
+    push = XtVaCreateManagedWidget("gamma",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Gamma()");
+    push = XtVaCreateManagedWidget("bright",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Bright()");
+    push = XtVaCreateManagedWidget("contr",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Contrast()");
+    push = XtVaCreateManagedWidget("color",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Color()");
+    push = XtVaCreateManagedWidget("gray",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Filter(grayscale)");
+    XtVaCreateManagedWidget("sep",xmSeparatorWidgetClass,menu,NULL);
+    push = XtVaCreateManagedWidget("blur",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,
+		  "F3x3(1,1,1, 1,1,1, 1,1,1, 1,9,0)");
+    push = XtVaCreateManagedWidget("sharpe",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Sharpe()");
+    push = XtVaCreateManagedWidget("edge",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,
+		  "F3x3(-1,-1,-1, -1,8,-1, -1,-1,-1)");
+    push = XtVaCreateManagedWidget("emboss",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,
+		  "F3x3(1,0,0, 0,0,0, 0,0,-1, 0,0,128)");
+
+    /* menu - view */
+    menu = XmCreatePulldownMenu(menubar,"viewM",NULL,0);
+    XtVaCreateManagedWidget("view",xmCascadeButtonWidgetClass,menubar,
+			    XmNsubMenuId,menu,NULL);
+    push = XtVaCreateManagedWidget("prev",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Prev()");
+    push = XtVaCreateManagedWidget("next",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Next()");
+    XtVaCreateManagedWidget("sep",xmSeparatorWidgetClass,menu,NULL);
+    push = XtVaCreateManagedWidget("prevpage",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"PrevPage()");
+    push = XtVaCreateManagedWidget("nextpage",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"NextPage()");
+    XtVaCreateManagedWidget("sep",xmSeparatorWidgetClass,menu,NULL);
+    push = XtVaCreateManagedWidget("zoomin",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Zoom(inc)");
+    push = XtVaCreateManagedWidget("zoomout",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Zoom(dec)");
+
+    /* menu - options */
+    menu = XmCreatePulldownMenu(menubar,"optM",NULL,0);
+    push = XtVaCreateManagedWidget("opt",xmCascadeButtonWidgetClass,menubar,
+				   XmNsubMenuId,menu,NULL);
+    smenu = XmCreatePulldownMenu(menu,"pcdM",NULL,0);
+    XtVaCreateManagedWidget("pcd",xmCascadeButtonWidgetClass,menu,
+			    XmNsubMenuId,smenu,NULL);
+    push = XtVaCreateManagedWidget("1",xmToggleButtonWidgetClass,smenu,NULL);
+    XtAddCallback(push,XmNvalueChangedCallback,pcd_cb,(XtPointer)1);
+    push = XtVaCreateManagedWidget("2",xmToggleButtonWidgetClass,smenu,NULL);
+    XtAddCallback(push,XmNvalueChangedCallback,pcd_cb,(XtPointer)2);
+    push = XtVaCreateManagedWidget("3",xmToggleButtonWidgetClass,smenu,NULL);
+    XtAddCallback(push,XmNvalueChangedCallback,pcd_cb,(XtPointer)3);
+    push = XtVaCreateManagedWidget("4",xmToggleButtonWidgetClass,smenu,NULL);
+    XtAddCallback(push,XmNvalueChangedCallback,pcd_cb,(XtPointer)4);
+    push = XtVaCreateManagedWidget("5",xmToggleButtonWidgetClass,smenu,NULL);
+    XtAddCallback(push,XmNvalueChangedCallback,pcd_cb,(XtPointer)5);
+    pcd_set(smenu);
+
+    push = XtVaCreateManagedWidget("autozoom",xmToggleButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNvalueChangedCallback,cfg_bool_cb,NULL);
+    XmToggleButtonSetState(push,GET_AUTOZOOM(),False);
+
+    XtVaCreateManagedWidget("sep",xmSeparatorWidgetClass,menu,NULL);
+    push = XtVaCreateManagedWidget("cfgsave",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,cfg_save_cb,NULL);
+    
+    /* menu - help */
+    menu = XmCreatePulldownMenu(menubar,"helpM",NULL,0);
+    push = XtVaCreateManagedWidget("help",xmCascadeButtonWidgetClass,menubar,
+				   XmNsubMenuId,menu,NULL);
+    XtVaSetValues(menubar,XmNmenuHelpWidget,push,NULL);
+    push = XtVaCreateManagedWidget("man",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Man(ida)");
+    XtVaCreateManagedWidget("sep",xmSeparatorWidgetClass,menu,NULL);
+    push = XtVaCreateManagedWidget("about",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,about_cb,NULL);
+
+    /* toolbar */
+    push = XtVaCreateManagedWidget("prev",xmPushButtonWidgetClass,tool,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Prev()");
+    push = XtVaCreateManagedWidget("next",xmPushButtonWidgetClass,tool,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Next()");
+    push = XtVaCreateManagedWidget("zoomin",xmPushButtonWidgetClass,tool,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Zoom(inc)");
+    push = XtVaCreateManagedWidget("zoomout",xmPushButtonWidgetClass,tool,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Zoom(dec)");
+
+    XtVaCreateManagedWidget("sep",xmSeparatorWidgetClass,tool,NULL);
+    push = XtVaCreateManagedWidget("flipv",xmPushButtonWidgetClass,tool,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Filter(flip-vert)");
+    push = XtVaCreateManagedWidget("fliph",xmPushButtonWidgetClass,tool,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Filter(flip-horz)");
+    push = XtVaCreateManagedWidget("rotccw",xmPushButtonWidgetClass,tool,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Filter(rotate-ccw)");
+    push = XtVaCreateManagedWidget("rotcw",xmPushButtonWidgetClass,tool,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Filter(rotate-cw)");
+
+    XtVaCreateManagedWidget("sep",xmSeparatorWidgetClass,tool,NULL);
+    push = XtVaCreateManagedWidget("exit",xmPushButtonWidgetClass,tool,NULL);
+    XtAddCallback(push,XmNactivateCallback,exit_cb,NULL);
+}
+
+/* ---------------------------------------------------------------------- */
+
+void
+resize_shell(void)
+{
+    char *title,*base;
+    Dimension x,y,w,h,sw,sh;
+    XmString str;
+    int len;
+    
+    XtVaGetValues(app_shell, XtNx,&x, XtNy,&y, NULL);
+
+    /* resize shell + move shell
+       size: image size + 2*shadowThickness */
+    w = ida->scrwidth+2;
+    h = ida->scrheight+2;
+    sw = XtScreen(ida->widget)->width;
+    sh = XtScreen(ida->widget)->height;
+    if (w > sw)
+	w = sw;
+    if (h > sh)
+	h = sh;
+    if (x+w > sw)
+	x = sw-w;
+    if (y+h > sh)
+	y = sh-h;
+
+    base = strrchr(ida->file,'/');
+    if (base)
+	base++;
+    else
+	base = ida->file;
+    title = malloc(strlen(base)+128);
+    len = sprintf(title,"%s (%dx%d", base,
+		  ida->img.i.width, ida->img.i.height);
+    if (ida->img.i.dpi)
+	len += sprintf(title+len," | %d dpi",
+		       ida->img.i.dpi);
+    if (ida->img.i.npages > 1)
+        len += sprintf(title+len," | page %d/%d",
+		       cpage+1, ida->img.i.npages);
+    len += sprintf(title+len," | %d%%)", viewer_i2s(ida->zoom,100));
+    XtVaSetValues(app_shell, XtNtitle,title,
+		  /* XtNx,x, XtNy,y, */ XtNwidth,w, XtNheight,h,
+		  NULL);
+    str = XmStringGenerate(title,NULL,XmMULTIBYTE_TEXT,NULL);
+    XtVaSetValues(status,XmNlabelString,str,NULL);
+    XmStringFree(str);
+    free(title);
+}
+
+static int
+load_file(int nr, int np)
+{
+    if(nr < 0 || nr >= nfiles)
+        return -1;
+    npages = viewer_loadimage(ida,files[nr],np);
+    if (-1 == npages)
+	return -1;
+    resize_shell();
+#if 0
+    XmListSelectPos(wlist,nr+1,False);
+    cfile = nr;
+#endif
+    return npages;
+}
+
+char*
+load_tmpfile(char *base)
+{
+    char *tmpdir;
+    char *filename;
+
+    tmpdir = getenv("TMPDIR");
+    if (NULL == tmpdir)
+	tmpdir="/tmp";
+    filename = malloc(strlen(tmpdir)+strlen(base)+16);
+    sprintf(filename,"%s/%s-XXXXXX",tmpdir,base);
+    return filename;
+}
+
+static void
+load_logo(void)
+{
+    static unsigned char logo[] = {
+#include "logo.h"
+    };
+    char *filename = load_tmpfile("ida-logo");
+    int fd;
+    fd = mkstemp(filename);
+    write(fd,logo,sizeof(logo));
+    close(fd);
+    cpage = 0;
+    npages = 1;
+    if (0 < viewer_loadimage(ida,filename,cpage)) {
+	ida->file = "ida " VERSION;
+	resize_shell();
+    }
+    unlink(filename);
+    free(filename);
+}
+
+static void
+load_stdin(void)
+{
+    char *filename = load_tmpfile("ida-stdin");
+    char buf[4096];
+    int rc,fd;
+    fd = mkstemp(filename);
+    for (;;) {
+	rc = read(0,buf,sizeof(buf));
+	if (rc <= 0)
+	    break;
+	write(fd,buf,rc);
+    }
+    close(fd);
+    cpage = 0;
+    npages = 1;
+    if (0 < viewer_loadimage(ida,filename,cpage)) {
+	ida->file = "stdin";
+	resize_shell();
+    }
+    unlink(filename);
+    free(filename);
+}
+
+void
+next_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
+{
+    for (;;) {
+	if (cfile >= nfiles-1)
+	    return;
+	cfile++;
+        cpage = 0;
+	if (0 <= load_file(cfile,cpage))
+	    break;
+    }
+}
+
+void
+prev_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
+{
+    for (;;) {
+	if (cfile < 1)
+	    return;
+	cfile--;
+        cpage = 0;
+	if (0 <= load_file(cfile,cpage))
+	    break;
+    }
+}
+
+void
+next_page_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
+{
+    for (;;) {
+	if (cpage >= npages-1)
+	    return;
+	cpage++;
+	if (0 <= load_file(cfile,cpage))
+	    break;
+    }
+}
+
+void
+prev_page_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
+{
+    for (;;) {
+	if (cpage <= 0)
+	    return;
+	cpage--;
+	if (0 <= load_file(cfile,cpage))
+	    break;
+    }
+}
+
+void
+zoom_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
+{
+    int zoom;
+    
+    if (0 == *num)
+	return;
+
+    if (0 == strcasecmp(params[0],"auto")) {
+	viewer_autozoom(ida);
+	return;
+    }
+
+    if (0 == strcasecmp(params[0],"inc")) {
+	zoom = ida->zoom+1;
+    } else if (0 == strcasecmp(params[0],"dec")) {
+	zoom = ida->zoom-1;
+    } else {
+	zoom = atoi(params[0]);
+    }
+    viewer_setzoom(ida,zoom);
+    resize_shell();
+}
+
+void
+scroll_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
+{
+    fprintf(stderr,"Scroll(): %s\n",XtName(widget));
+}
+
+/* ---------------------------------------------------------------------- */
+
+void new_file(char *name, int complain)
+{
+    struct stat st;
+    int n;
+
+    if (curl_is_url(name))
+	goto load;
+
+    if (0 == strncasecmp(name,"file:",5))
+	name += 5;
+    if (-1 == stat(name,&st)) {
+	if (complain)
+	    fprintf(stderr,"stat %s: %s\n",name,strerror(errno));
+	return;
+    }
+    switch (st.st_mode & S_IFMT) {
+    case S_IFDIR:
+	browser_window(name);
+	break;
+    case S_IFREG:
+	goto load;
+	break;
+    }
+    return;
+    
+ load:
+    n = list_append(name);
+    list_update();
+    cpage = 0;
+    load_file(n,cpage);
+}
+
+static void
+load_done_cb(Widget widget, XtPointer clientdata, XtPointer call_data)
+{
+    XmFileSelectionBoxCallbackStruct *cb = call_data;
+    char *line;
+
+    if (cb->reason == XmCR_OK) {
+        line = XmStringUnparse(cb->value,NULL,
+                               XmMULTIBYTE_TEXT,XmMULTIBYTE_TEXT,
+                               NULL,0,0);
+	new_file(line,1);
+    }
+    XtUnmanageChild(widget);
+}
+
+void
+load_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
+{
+    Widget help;
+
+    if (NULL == loadbox) {
+	loadbox = XmCreateFileSelectionDialog(app_shell,"load",NULL,0);
+	help = XmFileSelectionBoxGetChild(loadbox,XmDIALOG_HELP_BUTTON);
+	XtUnmanageChild(help);
+	XtAddCallback(loadbox,XmNokCallback,load_done_cb,NULL);
+	XtAddCallback(loadbox,XmNcancelCallback,load_done_cb,NULL);
+    } else {
+	XmFileSelectionDoSearch(loadbox,NULL);
+    }
+    XtManageChild(loadbox);
+}
+
+void
+scan_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
+{
+#ifdef HAVE_LIBSANE
+    cpage = 0;
+    if (*num)
+	npages = viewer_loader_start(ida, &sane_loader, NULL, params[0], 0);
+    else
+	npages = viewer_loader_start(ida, &sane_loader, NULL, "", 0);
+    if (-1 == npages)
+	return;
+    ida->file = "scanned image";
+    resize_shell();
+#endif
+}
+
+/* ---------------------------------------------------------------------- */
+
+void
+do_save_print(void)
+{
+    FILE *fp;
+    
+    if (save_filename) {
+	XtUnmanageChild(savebox);
+	ptr_busy();
+	if (NULL == (fp = fopen(save_filename,"wb"))) {
+	    fprintf(stderr,"save: can't open %s: %s\n",
+		    save_filename,strerror(errno));
+	} else if (-1 == cwriter->write(fp,&ida->img)) {
+	    fclose(fp);
+	    fprintf(stderr,"saving %s FAILED",save_filename);
+	} else {
+	    fclose(fp);
+	    list_append(save_filename);
+	    list_update();
+	}
+	ptr_idle();
+    }
+    if (print_command) {
+	XtUnmanageChild(printbox);
+	ptr_busy();
+	if (NULL == (fp = popen(print_command,"w"))) {
+	    fprintf(stderr,"print: can't exec %s: %s\n",
+		    print_command,strerror(errno));
+	} else {
+	    if (-1 == cwriter->write(fp,&ida->img))
+		fprintf(stderr,"printing FAILED");
+	    fclose(fp);
+	}
+	ptr_idle();
+    }
+}
+
+static void
+save_done_cb(Widget widget, XtPointer clientdata, XtPointer call_data)
+{
+    XmFileSelectionBoxCallbackStruct *cb = call_data;
+
+    if (cb->reason == XmCR_OK) {
+	print_command = NULL;
+	save_filename = XmStringUnparse(cb->value,NULL,
+					XmMULTIBYTE_TEXT,XmMULTIBYTE_TEXT,
+					NULL,0,0);
+	if (cwriter->conf) {
+	    cwriter->conf(widget,&ida->img);
+	} else {
+	    do_save_print();
+	}
+    } else {
+	XtUnmanageChild(widget);
+    }
+}
+
+static void
+save_fmt_cb(Widget widget, XtPointer clientdata, XtPointer call_data)
+{
+    cwriter = clientdata;
+}
+
+static void
+save_ext_cb(Widget widget, XtPointer clientdata, XtPointer call_data)
+{
+    Widget option = clientdata;
+    Widget menu;
+    WidgetList children;
+    Cardinal nchildren;
+    struct ida_writer *wr = NULL;
+    struct list_head *item;
+    char *name,*ext;
+    int i,j,pick;
+
+    name = XmTextGetString(widget);
+    ext = strrchr(name,'.');
+    if (NULL == ext)
+	return;
+    if (strchr(ext,'/'))
+	return;
+    ext++;
+
+    i = 0; pick = -1;
+    list_for_each(item,&writers) {
+	wr = list_entry(item, struct ida_writer, list);
+	for (j = 0; NULL != wr->ext[j]; j++)
+	    if (0 == strcasecmp(ext,wr->ext[j]))
+		pick = i;
+	if (-1 != pick)
+	    break;
+	i++;
+    }
+    if (-1 == pick)
+	return;
+
+    XtVaGetValues(option,XmNsubMenuId,&menu,NULL);
+    XtVaGetValues(menu,XtNchildren,&children,
+		  XtNnumChildren,&nchildren,NULL);
+    XtVaSetValues(option,XmNmenuHistory,children[pick],NULL);
+    cwriter = wr;
+}
+
+static void
+save_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
+{
+    Widget help,menu,option,push,text;
+    Arg args[2];
+    struct ida_writer *wr = NULL;
+    struct list_head *item;
+
+    if (NULL == savebox) {
+	savebox = XmCreateFileSelectionDialog(app_shell,"save",NULL,0);
+	help = XmFileSelectionBoxGetChild(savebox,XmDIALOG_HELP_BUTTON);
+	text = XmFileSelectionBoxGetChild(savebox,XmDIALOG_TEXT);
+	XtUnmanageChild(help);
+
+	menu = XmCreatePulldownMenu(savebox,"formatM",NULL,0);
+	XtSetArg(args[0],XmNsubMenuId,menu);
+	option = XmCreateOptionMenu(savebox,"format",args,1);
+	XtManageChild(option);
+	list_for_each(item,&writers) {
+	    wr = list_entry(item, struct ida_writer, list);
+	    push = XtVaCreateManagedWidget(wr->label,
+					   xmPushButtonWidgetClass,menu,
+					   NULL);
+	    XtAddCallback(push,XmNactivateCallback,save_fmt_cb,wr);
+	}
+	cwriter = list_entry(writers.next, struct ida_writer, list);
+
+	XtAddCallback(text,XmNvalueChangedCallback,save_ext_cb,option);
+	XtAddCallback(savebox,XmNokCallback,save_done_cb,NULL);
+	XtAddCallback(savebox,XmNcancelCallback,save_done_cb,NULL);
+    } else {
+	XmFileSelectionDoSearch(savebox,NULL);
+    }
+    XtManageChild(savebox);
+}
+
+/* ---------------------------------------------------------------------- */
+
+static void
+print_done_cb(Widget widget, XtPointer clientdata, XtPointer call_data)
+{
+    XmSelectionBoxCallbackStruct *cb = call_data;
+
+    if (cb->reason == XmCR_OK) {
+	save_filename = NULL;
+	print_command = XmStringUnparse(cb->value,NULL,
+					XmMULTIBYTE_TEXT,XmMULTIBYTE_TEXT,
+					NULL,0,0);
+	cwriter = &ps_writer;
+	cwriter->conf(widget,&ida->img);
+    } else {
+	XtUnmanageChild(widget);
+    }
+}
+
+static void
+print_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
+{
+    if (NULL == printbox) {
+	printbox = XmCreatePromptDialog(app_shell,"print",NULL,0);
+	XtUnmanageChild(XmSelectionBoxGetChild(printbox,XmDIALOG_HELP_BUTTON));
+	XtAddCallback(printbox,XmNokCallback,print_done_cb,NULL);
+	XtAddCallback(printbox,XmNcancelCallback,print_done_cb,NULL);
+    }
+    XtManageChild(printbox);
+}
+
+/* ---------------------------------------------------------------------- */
+
+static struct ida_op *ops[] = {
+    &desc_flip_vert,
+    &desc_flip_horz,
+    &desc_rotate_cw,
+    &desc_rotate_ccw,
+    &desc_invert,
+    &desc_crop,
+    &desc_autocrop,
+    &desc_grayscale,
+    NULL
+};
+
+void
+filter_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
+{
+    struct ida_op *op = NULL;
+    int i;
+
+    if (*num < 1)
+	return;
+    for (i = 0; NULL != ops[i]; i++) {
+	op = ops[i];
+	if (0 == strcasecmp(op->name,params[0]))
+	    break;
+    }
+    if (NULL == ops[i]) {
+	fprintf(stderr,"Oops: unknown filter: %s\n",params[0]);
+	return;
+    }
+
+    viewer_start_op(ida,op,NULL);
+    if (ida->op_src.i.width  != ida->img.i.width ||
+	ida->op_src.i.height != ida->img.i.height)
+	resize_shell();
+}
+
+void
+f3x3_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
+{
+    struct op_3x3_parm p;
+
+    if (*num < 9) {
+	fprintf(stderr,"F3x3: wrong number of args (%d, need 9)\n",*num);
+	return;
+    }
+    memset(&p,0,sizeof(p));
+    p.f1[0] = atoi(params[0]);
+    p.f1[1] = atoi(params[1]);
+    p.f1[2] = atoi(params[2]);
+    p.f2[0] = atoi(params[3]);
+    p.f2[1] = atoi(params[4]);
+    p.f2[2] = atoi(params[5]);
+    p.f3[0] = atoi(params[6]);
+    p.f3[1] = atoi(params[7]);
+    p.f3[2] = atoi(params[8]);
+    if (*num >  9) p.mul = atoi(params[ 9]);
+    if (*num > 10) p.div = atoi(params[10]);
+    if (*num > 11) p.add = atoi(params[11]);
+    if (debug) {
+	fprintf(stderr,"f3x3: -----------\n");
+	fprintf(stderr,"f3x3: %3d %3d %3d\n",p.f1[0],p.f1[1],p.f1[2]);
+	fprintf(stderr,"f3x3: %3d %3d %3d\n",p.f2[0],p.f2[1],p.f2[2]);
+	fprintf(stderr,"f3x3: %3d %3d %3d\n",p.f3[0],p.f3[1],p.f3[2]);
+	fprintf(stderr,"f3x3: *%d/%d+%d\n",p.mul,p.div,p.add);
+    }
+    viewer_start_op(ida,&desc_3x3,&p);
+}
+
+void
+undo_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
+{
+    Widget msgbox;
+    int resize;
+
+    resize = (ida->undo.i.width  != ida->img.i.width ||
+	      ida->undo.i.height != ida->img.i.height);
+    if (-1 == viewer_undo(ida)) {
+	msgbox = XmCreateInformationDialog(app_shell,"noundobox",NULL,0);
+	XtUnmanageChild(XmMessageBoxGetChild(msgbox,XmDIALOG_HELP_BUTTON));
+	XtUnmanageChild(XmMessageBoxGetChild(msgbox,XmDIALOG_CANCEL_BUTTON));
+	XtAddCallback(msgbox,XmNokCallback,destroy_cb,msgbox);
+	XtManageChild(msgbox);
+    } else {
+	if (resize)
+	    resize_shell();
+    }
+}
+
+/* ---------------------------------------------------------------------- */
+
+struct ida_prompt {
+    Widget shell;
+    Widget box;
+    Widget scale;
+    Widget text;
+    int apply;
+    int value;
+    int decimal;
+    int factor;    /* 10^decimal */
+    void (*notify)(int value, int preview);
+};
+
+static void
+prompt_setvalue(struct ida_prompt *me, int value, int scale, int text)
+{
+    char str[32];
+    int min,max;
+    
+    if (me->value == value)
+	return;
+    XtVaGetValues(me->scale,XmNminimum,&min,XmNmaximum,&max,NULL);
+    if (value < min || value > max)
+	return;
+
+    me->value = value;
+    if (scale)
+	XmScaleSetValue(me->scale,value);
+    if (text) {
+	if (me->decimal) {
+	    sprintf(str,"%*.*f",me->decimal+2,me->decimal,
+		    (float)value/me->factor);
+	} else {
+	    sprintf(str,"%d",value);
+	}
+	XmTextSetString(me->text,str);
+    }
+    if (me->notify)
+	me->notify(value,1);
+}
+
+static void
+prompt_scale_cb(Widget widget, XtPointer client_data, XtPointer calldata)
+{
+    struct ida_prompt *me = client_data;
+    XmScaleCallbackStruct *cd = calldata;
+
+    prompt_setvalue(me,cd->value,0,1);
+}
+
+static void
+prompt_text_cb(Widget widget, XtPointer client_data, XtPointer calldata)
+{
+    struct ida_prompt *me = client_data;
+    float fvalue;
+    int value;
+
+    if (me->decimal) {
+	fvalue  = atof(XmTextGetString(me->text));
+	fvalue += 0.5/me->factor;
+	value = (int)(fvalue * me->factor);
+    } else {
+	value = atoi(XmTextGetString(me->text));
+    }
+    prompt_setvalue(me,value,1,0);
+}
+
+static void
+prompt_box_cb(Widget widget, XtPointer client_data, XtPointer calldata)
+{
+    struct ida_prompt *me = client_data;
+    XmSelectionBoxCallbackStruct *cd = calldata;
+
+    if (XmCR_OK == cd->reason)
+	me->apply = 1;
+    XtDestroyWidget(me->shell);
+}
+
+static void
+prompt_shell_cb(Widget widget, XtPointer client_data, XtPointer calldata)
+{
+    struct ida_prompt *me = client_data;
+
+    if (me->apply)
+	me->notify(me->value,0);
+    else
+	viewer_cancel_preview(ida);
+    free(me);
+}
+
+static void
+prompt_init(char *name, int decimal, int value,
+	    void (*notify)(int value, int preview))
+{
+    struct ida_prompt *me;
+
+    me = malloc(sizeof(*me));
+    memset(me,0,sizeof(*me));
+    if (decimal) {
+	int i;
+	me->decimal = decimal;
+	me->factor = 1;
+	for (i = 0; i < decimal; i++)
+	    me->factor *= 10;
+    }
+    me->notify = notify;
+    
+    me->box = XmCreatePromptDialog(app_shell,name,NULL,0);
+    me->shell = XtParent(me->box);
+    me->text = XmSelectionBoxGetChild(me->box,XmDIALOG_TEXT);
+    XmdRegisterEditres(XtParent(me->box));
+    XtUnmanageChild(XmSelectionBoxGetChild(me->box,XmDIALOG_HELP_BUTTON));
+    me->scale = XtVaCreateManagedWidget("scale",xmScaleWidgetClass,
+					me->box,NULL);
+
+    XtAddCallback(me->scale,XmNdragCallback,prompt_scale_cb,me);
+    XtAddCallback(me->scale,XmNvalueChangedCallback,prompt_scale_cb,me);
+    XtAddCallback(me->text,XmNvalueChangedCallback,prompt_text_cb,me);
+    XtAddCallback(me->box,XmNokCallback,prompt_box_cb,me);
+    XtAddCallback(me->box,XmNcancelCallback,prompt_box_cb,me);
+    XtAddCallback(me->shell,XmNdestroyCallback,prompt_shell_cb,me);
+    
+    XtManageChild(me->box);
+    prompt_setvalue(me,value,1,1);
+}
+
+/* ---------------------------------------------------------------------- */
+
+static void
+gamma_notify(int value, int preview)
+{
+    struct op_map_parm param;
+    float gamma = (float)value/100;
+
+    param.red = op_map_nothing;
+    param.red.gamma   = gamma;
+    param.green = param.red;
+    param.blue  = param.red;
+    if (preview) {
+	viewer_start_preview(ida,&desc_map,&param);
+    } else {
+	gamma_val = value;
+	viewer_start_op(ida,&desc_map,&param);
+    }
+}
+
+void
+gamma_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
+{
+    prompt_init("gamma",2,gamma_val,gamma_notify);
+}
+
+static void
+bright_notify(int value, int preview)
+{
+    struct op_map_parm param;
+
+    param.red = op_map_nothing;
+    param.red.bottom += value;
+    param.red.top    += value;
+    param.green = param.red;
+    param.blue  = param.red;
+    if (preview) {
+	viewer_start_preview(ida,&desc_map,&param);
+    } else {
+	bright_val = value;
+	viewer_start_op(ida,&desc_map,&param);
+    }
+}
+
+void
+bright_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
+{
+    prompt_init("bright",0,bright_val,bright_notify);
+}
+
+static void
+contrast_notify(int value, int preview)
+{
+    struct op_map_parm param;
+
+    param.red = op_map_nothing;
+    param.red.bottom -= value;
+    param.red.top    += value;
+    param.green = param.red;
+    param.blue  = param.red;
+    if (preview) {
+	viewer_start_preview(ida,&desc_map,&param);
+    } else {
+	contrast_val = value;
+	viewer_start_op(ida,&desc_map,&param);
+    }
+}
+
+void
+contrast_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
+{
+    prompt_init("contrast",0,contrast_val,contrast_notify);
+}
+
+static void
+rotate_notify(int value, int preview)
+{
+    struct op_rotate_parm parm;
+
+    parm.angle = value;
+    if (preview) {
+	viewer_start_preview(ida,&desc_rotate,&parm);
+    } else {
+	rotate_val = value;
+	viewer_start_op(ida,&desc_rotate,&parm);
+    }
+}
+
+void
+rotate_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
+{
+    prompt_init("rotate",0,rotate_val,rotate_notify);
+}
+
+static void
+sharpe_notify(int value, int preview)
+{
+    struct op_sharpe_parm parm;
+
+    parm.factor = value;
+    if (preview) {
+	viewer_start_preview(ida,&desc_sharpe,&parm);
+    } else {
+	sharpe_val = value;
+	viewer_start_op(ida,&desc_sharpe,&parm);
+    }
+}
+
+void
+sharpe_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
+{
+    prompt_init("sharpe",0,sharpe_val,sharpe_notify);
+}
+
+void
+color_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
+{
+    color_init(&ida->img);
+}
+
+/* ---------------------------------------------------------------------- */
+
+struct ida_resize {
+    Widget dlg,tx,ty,tr,lock,size,res,label;
+    int yupdate,xupdate,rupdate;
+    int apply;
+};
+
+static void
+resize_phys_size(struct ida_resize *h)
+{
+    char buf[128];
+    XmString str;
+    int dpi;
+    float x,y;
+
+    dpi = atoi(XmTextGetString(h->tr));
+    if (dpi) {
+	x = (float)atoi(XmTextGetString(h->tx)) / dpi;
+	y = (float)atoi(XmTextGetString(h->ty)) / dpi;
+	sprintf(buf,"%.2f x %.2f inch\n%.2f x %.2f cm",
+		x,y, x*2.54, y*2.54);
+    } else {
+	strcpy(buf,"unknown");
+    }
+    str = XmStringGenerate(buf, NULL, XmMULTIBYTE_TEXT,NULL);
+    XtVaSetValues(h->label,XmNlabelString,str,NULL);
+}
+
+static void
+resize_sync_cb(Widget widget, XtPointer client_data, XtPointer calldata)
+{
+    struct ida_resize *h = client_data;
+    char buf[32];
+    int i,lock,res;
+
+    lock = XmToggleButtonGetState(h->lock);
+    res  = XmToggleButtonGetState(h->res);
+
+    /* update text fields */
+    if (h->tx == widget) {
+	if (h->xupdate) {
+	    h->xupdate--;
+	    return;
+	}
+	i = atoi(XmTextGetString(h->tx));
+	if (lock) {
+	    sprintf(buf,"%d",i * ida->img.i.height / ida->img.i.width);
+	    h->yupdate++;
+	    XmTextSetString(h->ty,buf);
+	    if (res) {
+		sprintf(buf,"%d", ida->img.i.dpi * i / ida->img.i.width);
+		h->rupdate++;
+		XmTextSetString(h->tr,buf);
+	    }
+	} else {
+	    if (res) {
+		h->rupdate++;
+		XmTextSetString(h->tr,"0");
+	    }
+	}
+	resize_phys_size(h);
+    }
+    if (h->ty == widget) {
+	if (h->yupdate) {
+	    h->yupdate--;
+	    return;
+	}
+	i = atoi(XmTextGetString(h->ty));
+	if (lock) {
+	    sprintf(buf,"%d",i * ida->img.i.width / ida->img.i.height);
+	    h->xupdate++;
+	    XmTextSetString(h->tx,buf);
+	    if (res) {
+		sprintf(buf,"%d", ida->img.i.dpi * i / ida->img.i.height);
+		h->rupdate++;
+		XmTextSetString(h->tr,buf);
+	    }
+	} else {
+	    if (res) {
+		h->rupdate++;
+		XmTextSetString(h->tr,"0");
+	    }
+	}
+	resize_phys_size(h);
+    }
+    if (h->tr == widget) {
+	if (h->rupdate) {
+	    h->rupdate--;
+	    return;
+	}
+	i = atoi(XmTextGetString(h->tr));
+	sprintf(buf,"%d", ida->img.i.width * i / ida->img.i.dpi);
+	h->xupdate++;
+	XmTextSetString(h->tx,buf);
+	sprintf(buf,"%d", ida->img.i.height * i / ida->img.i.dpi);
+	h->yupdate++;
+	XmTextSetString(h->ty,buf);
+	resize_phys_size(h);
+    }
+
+    /* radio buttons pressed */
+    if (h->size == widget && XmToggleButtonGetState(h->size)) {
+	XmToggleButtonSetState(h->res,0,False);
+	sprintf(buf,"%d", ida->img.i.dpi);
+	h->rupdate++;
+	XmTextSetString(h->tr,buf);
+	XtVaSetValues(h->tr,XmNsensitive,False,NULL);
+	resize_phys_size(h);
+    }
+    if (h->res == widget && XmToggleButtonGetState(h->res)) {
+	XmToggleButtonSetState(h->size,0,False);
+	XtVaSetValues(h->tr,XmNsensitive,True,NULL);
+    }
+}
+
+static void
+resize_button_cb(Widget widget, XtPointer client_data, XtPointer calldata)
+{
+    struct ida_resize *h = client_data;
+    XmSelectionBoxCallbackStruct *cb = calldata;
+
+    if (cb->reason == XmCR_OK)
+	h->apply = 1;
+    XtDestroyWidget(XtParent(h->dlg));
+}
+
+static void
+resize_destroy(Widget widget, XtPointer client_data, XtPointer calldata)
+{
+    struct ida_resize *h = client_data;
+    struct op_resize_parm param;
+
+    if (!h->apply)
+	return;
+    param.width  = atoi(XmTextGetString(h->tx));
+    param.height = atoi(XmTextGetString(h->ty));
+    param.dpi    = atoi(XmTextGetString(h->tr));
+    if (0 == param.width  ||
+	0 == param.height) {
+	fprintf(stderr,"resize: invalid argument\n");
+	return;
+    }
+	
+    viewer_start_op(ida,&desc_resize,&param);
+    resize_shell();
+    free(h);
+}
+
+static void
+resize_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
+{
+    Widget rc,rc2;
+    char buf[32];
+    struct ida_resize *h;
+
+    h = malloc(sizeof(*h));
+    memset(h,0,sizeof(*h));
+    
+    h->dlg = XmCreatePromptDialog(app_shell,"resize",NULL,0);
+    XmdRegisterEditres(XtParent(h->dlg));
+    XtUnmanageChild(XmSelectionBoxGetChild(h->dlg,XmDIALOG_SELECTION_LABEL));
+    XtUnmanageChild(XmSelectionBoxGetChild(h->dlg,XmDIALOG_HELP_BUTTON));
+    XtUnmanageChild(XmSelectionBoxGetChild(h->dlg,XmDIALOG_TEXT));
+    rc = XtVaCreateManagedWidget("rc", xmRowColumnWidgetClass,h->dlg, NULL);
+    XtVaCreateManagedWidget("lx", xmLabelWidgetClass,rc, NULL);
+    h->tx = XtVaCreateManagedWidget("tx", xmTextWidgetClass,rc, NULL);
+    XtVaCreateManagedWidget("ly", xmLabelWidgetClass,rc, NULL);
+    h->ty = XtVaCreateManagedWidget("ty", xmTextWidgetClass,rc, NULL);
+    XtVaCreateManagedWidget("lr", xmLabelWidgetClass,rc, NULL);
+    h->tr = XtVaCreateManagedWidget("tr", xmTextWidgetClass,rc, NULL);
+    h->lock = XtVaCreateManagedWidget("lock", xmToggleButtonWidgetClass,
+				      rc, NULL);
+    rc2 = XtVaCreateManagedWidget("rc", xmRowColumnWidgetClass,rc, NULL);
+    h->size = XtVaCreateManagedWidget("size", xmToggleButtonWidgetClass,
+				      rc2, NULL);
+    h->res  = XtVaCreateManagedWidget("res", xmToggleButtonWidgetClass,
+				      rc2, NULL);
+    XtVaCreateManagedWidget("phys", xmLabelWidgetClass,rc,NULL);
+    h->label = XtVaCreateManagedWidget("label", xmLabelWidgetClass,
+				       rc, NULL);
+
+    sprintf(buf,"%d",ida->img.i.width);
+    XmTextSetString(h->tx,buf);
+    sprintf(buf,"%d",ida->img.i.height);
+    XmTextSetString(h->ty,buf);
+    sprintf(buf,"%d",ida->img.i.dpi);
+    XmTextSetString(h->tr,buf);
+    XtVaSetValues(h->tr,XmNsensitive,False,NULL);
+    XmToggleButtonSetState(h->lock,1,False);
+    XmToggleButtonSetState(h->size,1,False);
+    XmToggleButtonSetState(h->res,0,False);
+    if (!ida->img.i.dpi) {
+    	XtVaSetValues(h->size,XmNsensitive,False,NULL);
+	XtVaSetValues(h->res, XmNsensitive,False,NULL);
+    }
+    resize_phys_size(h);
+    
+    XtAddCallback(XtParent(h->dlg),XmNdestroyCallback,resize_destroy,h);
+    XtAddCallback(h->dlg, XmNokCallback,           resize_button_cb, h);
+    XtAddCallback(h->dlg, XmNcancelCallback,       resize_button_cb, h);
+    XtAddCallback(h->tx,  XmNvalueChangedCallback, resize_sync_cb,   h);
+    XtAddCallback(h->ty,  XmNvalueChangedCallback, resize_sync_cb,   h);
+    XtAddCallback(h->tr,  XmNvalueChangedCallback, resize_sync_cb,   h);
+    XtAddCallback(h->size,XmNvalueChangedCallback, resize_sync_cb,   h);
+    XtAddCallback(h->res, XmNvalueChangedCallback, resize_sync_cb,   h);
+    XtManageChild(h->dlg);
+}
+
+/* ---------------------------------------------------------------------- */
+
+struct stderr_handler {
+    Widget box;
+    XmString str;
+    int pipe,err;
+    XtInputId id;
+};
+
+static void
+stderr_input(XtPointer clientdata, int *src, XtInputId *id)
+{
+    struct stderr_handler *h = clientdata;
+    XmString item;
+    Widget label;
+    char buf[1024];
+    int rc;
+
+    rc = read(h->pipe,buf,sizeof(buf)-1);
+    if (rc <= 0) {
+	/* Oops */
+	XtRemoveInput(h->id);
+	close(h->pipe);
+	XtDestroyWidget(h->box);
+	free(h);
+    }
+    buf[rc] = 0;
+    write(h->err,buf,rc);
+    item = XmStringGenerate(buf, NULL, XmMULTIBYTE_TEXT,NULL);
+    h->str = XmStringConcatAndFree(h->str,item);
+    label = XmMessageBoxGetChild(h->box,XmDIALOG_MESSAGE_LABEL);
+    XtVaSetValues(label,XmNlabelString,h->str,NULL);
+    XtManageChild(h->box);
+}
+
+static void
+stderr_ok_cb(Widget widget, XtPointer clientdata, XtPointer call_data)
+{
+    struct stderr_handler *h = clientdata;
+
+    XmStringFree(h->str);
+    h->str = XmStringGenerate("", NULL, XmMULTIBYTE_TEXT,NULL);
+    XtUnmanageChild(h->box);
+}
+
+static void
+stderr_close_cb(Widget widget, XtPointer clientdata, XtPointer call_data)
+{
+    struct stderr_handler *h = clientdata;
+
+    XmStringFree(h->str);
+    h->str = XmStringGenerate("", NULL, XmMULTIBYTE_TEXT,NULL);
+}
+
+static void
+stderr_init(void)
+{
+    struct stderr_handler *h;
+    int p[2];
+
+    h = malloc(sizeof(*h));
+    memset(h,0,sizeof(*h));
+    h->str = XmStringGenerate("", NULL, XmMULTIBYTE_TEXT,NULL);
+    h->box = XmCreateErrorDialog(app_shell,"errbox",NULL,0);
+    XtUnmanageChild(XmMessageBoxGetChild(h->box,XmDIALOG_HELP_BUTTON));
+    XtUnmanageChild(XmMessageBoxGetChild(h->box,XmDIALOG_CANCEL_BUTTON));
+    XtAddCallback(h->box,XmNokCallback,stderr_ok_cb,h);
+    XtAddCallback(XtParent(h->box),XmNpopdownCallback,stderr_close_cb,h);
+    XSync(XtDisplay(app_shell),False);
+    if (!debug) {
+	pipe(p);
+	h->err = dup(2);
+	dup2(p[1],2);
+	close(p[1]);
+	h->pipe = p[0];
+	h->id = XtAppAddInput(app_context,h->pipe,(XtPointer)XtInputReadMask,
+			      stderr_input,h);
+    }
+}
+
+/* ---------------------------------------------------------------------- */
+
+static void
+create_mainwindow(void)
+{
+    Widget img;
+
+    XmdRegisterEditres(app_shell);
+    view = XmCreateScrolledWindow(app_shell,"view",NULL,0);
+    XtManageChild(view);
+    img = XtVaCreateManagedWidget("image", xmDrawingAreaWidgetClass,view,NULL);
+    XtAddCallback(img,XmNdestinationCallback,selection_dest,NULL);
+    XtAddCallback(img,XmNconvertCallback,selection_convert,NULL);
+    dnd_add(img);
+    ida = viewer_init(img);
+    XtInstallAllAccelerators(img,app_shell);
+}
+
+static void
+usage(void)
+{
+    fprintf(stderr,
+	    "ida " VERSION " - image viewer & editor\n"
+	    "usage: ida [ options ] [ files ]\n"
+	    "options:\n"
+	    "   -h, -help    this text\n"
+	    "       -pcd n   pick PhotoCD size (n = 1 .. 5, default 3)\n"
+	    "   -d, -debug   enable debug messages\n");
+    exit(0);
+}
+
+int
+main(int argc, char *argv[])
+{
+    int i, files, zero = 0;
+    struct stat st;
+    Pixel background;
+
+    setlocale(LC_ALL,"");
+    if (0 == strcasecmp("utf-8", nl_langinfo(CODESET))) {
+	/* ### FIXME ###
+	 * for not-yet known reasons ida crashes somewhere deep in
+	 * the Motif libraries when running in utf-8 locale ... */
+	setenv("LC_ALL", "POSIX", 1);
+	setlocale(LC_ALL,"");
+    }
+    
+    binary = argv[0];
+    ida_init_config();
+    ida_read_config();
+
+    XtSetLanguageProc(NULL,NULL,NULL);
+    app_shell = XtAppInitialize(&app_context, "Ida",
+				opt_desc, opt_count,
+				&argc, argv,
+				fallback_ressources,
+				NULL, 0);
+    dpy = XtDisplay(app_shell);
+    XtGetApplicationResources(app_shell,&args,
+			      args_desc,args_count,
+			      NULL,0);
+    pcd_res  = GET_PHOTOCD_RES();
+    sane_res = GET_SANE_RES();
+    if (args.help)
+	usage();
+    if (args.debug) {
+	debug=1;
+	xdnd_debug = 1;
+	XSynchronize(dpy,1);
+    }
+
+    XtAppAddActions(app_context, actionTable,
+		    sizeof(actionTable) / sizeof(XtActionsRec));
+    if (0) {
+	XtAddCallback(XmGetXmDisplay(dpy),XmNnoFontCallback,
+		      display_cb,NULL);
+	XtAddCallback(XmGetXmDisplay(dpy),XmNnoRenditionCallback,
+		      display_cb,NULL);
+    }
+    XtVaGetValues(app_shell, XtNbackground,&background, NULL);
+    x11_color_init(app_shell,&gray);
+    x11_icons_init(dpy, background /* x11_gray */);
+    stderr_init();
+    ipc_init();
+
+    wm_delete_window = XInternAtom(dpy,"WM_DELETE_WINDOW",False);
+    create_mainwindow();
+    create_control();
+    XtRealizeWidget(app_shell);
+    ptr_register(ida->widget);
+    ptr_register(control_shell);
+
+    /* handle cmd line args */
+    if (2 == argc && 0 == strcmp(argv[1],"-")) {
+	load_stdin();
+    } else if (argc > 1) {
+	for (files = 0, i = 1; i < argc; i++) {
+ 	    if (curl_is_url(argv[i])) {
+		list_append(argv[i]);
+		files++;
+		continue;
+	    }
+	    if (-1 == stat(argv[i],&st)) {
+		if (debug)
+		    fprintf(stderr,"stat %s: %s\n",argv[i],strerror(errno));
+		continue;
+	    }
+	    switch (st.st_mode & S_IFMT) {
+	    case S_IFDIR:
+		browser_window(argv[i]);
+		break;
+	    case S_IFREG:
+		list_append(argv[i]);
+		files++;
+		break;
+	    }
+	}
+	if (files) {
+	    list_update();
+	    next_ac(ida->widget,NULL,NULL,&zero);
+	}
+    }
+
+    if (NULL == ida->file)
+	load_logo();
+
+    XtAppMainLoop(app_context);
+    return 0; /* keep compiler happy */
+}
diff --git a/lib/a2jpeg-6b/ida.h b/lib/a2jpeg-6b/ida.h
new file mode 100644
index 0000000..7fa8b0a
--- /dev/null
+++ b/lib/a2jpeg-6b/ida.h
@@ -0,0 +1,26 @@
+struct ARGS {
+    Boolean        debug;
+    Boolean        help;
+    Boolean        testload;
+};
+
+extern struct ARGS        args;
+extern unsigned int       pcd_res;
+
+extern Widget             app_shell;
+extern XtAppContext       app_context;
+extern Display            *dpy;
+extern struct ida_viewer  *ida;
+
+void action_cb(Widget widget, XtPointer clientdata, XtPointer call_data);
+void destroy_cb(Widget widget, XtPointer clientdata, XtPointer call_data);
+
+void ptr_register(Widget widget);
+void ptr_unregister(Widget widget);
+void ptr_busy(void);
+void ptr_idle(void);
+
+void do_save_print(void);
+void resize_shell(void);
+char* load_tmpfile(char *base);
+void new_file(char *name, int complain);
diff --git a/lib/a2jpeg-6b/jinclude.h b/lib/a2jpeg-6b/jinclude.h
new file mode 100644
index 0000000..0a4f151
--- /dev/null
+++ b/lib/a2jpeg-6b/jinclude.h
@@ -0,0 +1,91 @@
+/*
+ * jinclude.h
+ *
+ * Copyright (C) 1991-1994, Thomas G. Lane.
+ * This file is part of the Independent JPEG Group's software.
+ * For conditions of distribution and use, see the accompanying README file.
+ *
+ * This file exists to provide a single place to fix any problems with
+ * including the wrong system include files.  (Common problems are taken
+ * care of by the standard jconfig symbols, but on really weird systems
+ * you may have to edit this file.)
+ *
+ * NOTE: this file is NOT intended to be included by applications using the
+ * JPEG library.  Most applications need only include jpeglib.h.
+ */
+
+
+/* Include auto-config file to find out which system include files we need. */
+
+#include "jconfig.h"		/* auto configuration options */
+#define JCONFIG_INCLUDED	/* so that jpeglib.h doesn't do it again */
+
+/*
+ * We need the NULL macro and size_t typedef.
+ * On an ANSI-conforming system it is sufficient to include <stddef.h>.
+ * Otherwise, we get them from <stdlib.h> or <stdio.h>; we may have to
+ * pull in <sys/types.h> as well.
+ * Note that the core JPEG library does not require <stdio.h>;
+ * only the default error handler and data source/destination modules do.
+ * But we must pull it in because of the references to FILE in jpeglib.h.
+ * You can remove those references if you want to compile without <stdio.h>.
+ */
+
+#ifdef HAVE_STDDEF_H
+#include <stddef.h>
+#endif
+
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+
+#ifdef NEED_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+
+#include <stdio.h>
+
+/*
+ * We need memory copying and zeroing functions, plus strncpy().
+ * ANSI and System V implementations declare these in <string.h>.
+ * BSD doesn't have the mem() functions, but it does have bcopy()/bzero().
+ * Some systems may declare memset and memcpy in <memory.h>.
+ *
+ * NOTE: we assume the size parameters to these functions are of type size_t.
+ * Change the casts in these macros if not!
+ */
+
+#ifdef NEED_BSD_STRINGS
+
+#include <strings.h>
+#define MEMZERO(target,size)	bzero((void *)(target), (size_t)(size))
+#define MEMCOPY(dest,src,size)	bcopy((const void *)(src), (void *)(dest), (size_t)(size))
+
+#else /* not BSD, assume ANSI/SysV string lib */
+
+#include <string.h>
+#define MEMZERO(target,size)	memset((void *)(target), 0, (size_t)(size))
+#define MEMCOPY(dest,src,size)	memcpy((void *)(dest), (const void *)(src), (size_t)(size))
+
+#endif
+
+/*
+ * In ANSI C, and indeed any rational implementation, size_t is also the
+ * type returned by sizeof().  However, it seems there are some irrational
+ * implementations out there, in which sizeof() returns an int even though
+ * size_t is defined as long or unsigned long.  To ensure consistent results
+ * we always use this SIZEOF() macro in place of using sizeof() directly.
+ */
+
+#define SIZEOF(object)	((size_t) sizeof(object))
+
+/*
+ * The modules that use fread() and fwrite() always invoke them through
+ * these macros.  On some systems you may need to twiddle the argument casts.
+ * CAUTION: argument order is different from underlying functions!
+ */
+
+#define JFREAD(file,buf,sizeofbuf)  \
+  ((size_t) fread((void *) (buf), (size_t) 1, (size_t) (sizeofbuf), (file)))
+#define JFWRITE(file,buf,sizeofbuf)  \
+  ((size_t) fwrite((const void *) (buf), (size_t) 1, (size_t) (sizeofbuf), (file)))
diff --git a/lib/a2jpeg-6b/jpegint.h b/lib/a2jpeg-6b/jpegint.h
new file mode 100644
index 0000000..95b00d4
--- /dev/null
+++ b/lib/a2jpeg-6b/jpegint.h
@@ -0,0 +1,392 @@
+/*
+ * jpegint.h
+ *
+ * Copyright (C) 1991-1997, Thomas G. Lane.
+ * This file is part of the Independent JPEG Group's software.
+ * For conditions of distribution and use, see the accompanying README file.
+ *
+ * This file provides common declarations for the various JPEG modules.
+ * These declarations are considered internal to the JPEG library; most
+ * applications using the library shouldn't need to include this file.
+ */
+
+
+/* Declarations for both compression & decompression */
+
+typedef enum {			/* Operating modes for buffer controllers */
+	JBUF_PASS_THRU,		/* Plain stripwise operation */
+	/* Remaining modes require a full-image buffer to have been created */
+	JBUF_SAVE_SOURCE,	/* Run source subobject only, save output */
+	JBUF_CRANK_DEST,	/* Run dest subobject only, using saved data */
+	JBUF_SAVE_AND_PASS	/* Run both subobjects, save output */
+} J_BUF_MODE;
+
+/* Values of global_state field (jdapi.c has some dependencies on ordering!) */
+#define CSTATE_START	100	/* after create_compress */
+#define CSTATE_SCANNING	101	/* start_compress done, write_scanlines OK */
+#define CSTATE_RAW_OK	102	/* start_compress done, write_raw_data OK */
+#define CSTATE_WRCOEFS	103	/* jpeg_write_coefficients done */
+#define DSTATE_START	200	/* after create_decompress */
+#define DSTATE_INHEADER	201	/* reading header markers, no SOS yet */
+#define DSTATE_READY	202	/* found SOS, ready for start_decompress */
+#define DSTATE_PRELOAD	203	/* reading multiscan file in start_decompress*/
+#define DSTATE_PRESCAN	204	/* performing dummy pass for 2-pass quant */
+#define DSTATE_SCANNING	205	/* start_decompress done, read_scanlines OK */
+#define DSTATE_RAW_OK	206	/* start_decompress done, read_raw_data OK */
+#define DSTATE_BUFIMAGE	207	/* expecting jpeg_start_output */
+#define DSTATE_BUFPOST	208	/* looking for SOS/EOI in jpeg_finish_output */
+#define DSTATE_RDCOEFS	209	/* reading file in jpeg_read_coefficients */
+#define DSTATE_STOPPING	210	/* looking for EOI in jpeg_finish_decompress */
+
+
+/* Declarations for compression modules */
+
+/* Master control module */
+struct jpeg_comp_master {
+  JMETHOD(void, prepare_for_pass, (j_compress_ptr cinfo));
+  JMETHOD(void, pass_startup, (j_compress_ptr cinfo));
+  JMETHOD(void, finish_pass, (j_compress_ptr cinfo));
+
+  /* State variables made visible to other modules */
+  boolean call_pass_startup;	/* True if pass_startup must be called */
+  boolean is_last_pass;		/* True during last pass */
+};
+
+/* Main buffer control (downsampled-data buffer) */
+struct jpeg_c_main_controller {
+  JMETHOD(void, start_pass, (j_compress_ptr cinfo, J_BUF_MODE pass_mode));
+  JMETHOD(void, process_data, (j_compress_ptr cinfo,
+			       JSAMPARRAY input_buf, JDIMENSION *in_row_ctr,
+			       JDIMENSION in_rows_avail));
+};
+
+/* Compression preprocessing (downsampling input buffer control) */
+struct jpeg_c_prep_controller {
+  JMETHOD(void, start_pass, (j_compress_ptr cinfo, J_BUF_MODE pass_mode));
+  JMETHOD(void, pre_process_data, (j_compress_ptr cinfo,
+				   JSAMPARRAY input_buf,
+				   JDIMENSION *in_row_ctr,
+				   JDIMENSION in_rows_avail,
+				   JSAMPIMAGE output_buf,
+				   JDIMENSION *out_row_group_ctr,
+				   JDIMENSION out_row_groups_avail));
+};
+
+/* Coefficient buffer control */
+struct jpeg_c_coef_controller {
+  JMETHOD(void, start_pass, (j_compress_ptr cinfo, J_BUF_MODE pass_mode));
+  JMETHOD(boolean, compress_data, (j_compress_ptr cinfo,
+				   JSAMPIMAGE input_buf));
+};
+
+/* Colorspace conversion */
+struct jpeg_color_converter {
+  JMETHOD(void, start_pass, (j_compress_ptr cinfo));
+  JMETHOD(void, color_convert, (j_compress_ptr cinfo,
+				JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+				JDIMENSION output_row, int num_rows));
+};
+
+/* Downsampling */
+struct jpeg_downsampler {
+  JMETHOD(void, start_pass, (j_compress_ptr cinfo));
+  JMETHOD(void, downsample, (j_compress_ptr cinfo,
+			     JSAMPIMAGE input_buf, JDIMENSION in_row_index,
+			     JSAMPIMAGE output_buf,
+			     JDIMENSION out_row_group_index));
+
+  boolean need_context_rows;	/* TRUE if need rows above & below */
+};
+
+/* Forward DCT (also controls coefficient quantization) */
+struct jpeg_forward_dct {
+  JMETHOD(void, start_pass, (j_compress_ptr cinfo));
+  /* perhaps this should be an array??? */
+  JMETHOD(void, forward_DCT, (j_compress_ptr cinfo,
+			      jpeg_component_info * compptr,
+			      JSAMPARRAY sample_data, JBLOCKROW coef_blocks,
+			      JDIMENSION start_row, JDIMENSION start_col,
+			      JDIMENSION num_blocks));
+};
+
+/* Entropy encoding */
+struct jpeg_entropy_encoder {
+  JMETHOD(void, start_pass, (j_compress_ptr cinfo, boolean gather_statistics));
+  JMETHOD(boolean, encode_mcu, (j_compress_ptr cinfo, JBLOCKROW *MCU_data));
+  JMETHOD(void, finish_pass, (j_compress_ptr cinfo));
+};
+
+/* Marker writing */
+struct jpeg_marker_writer {
+  JMETHOD(void, write_file_header, (j_compress_ptr cinfo));
+  JMETHOD(void, write_frame_header, (j_compress_ptr cinfo));
+  JMETHOD(void, write_scan_header, (j_compress_ptr cinfo));
+  JMETHOD(void, write_file_trailer, (j_compress_ptr cinfo));
+  JMETHOD(void, write_tables_only, (j_compress_ptr cinfo));
+  /* These routines are exported to allow insertion of extra markers */
+  /* Probably only COM and APPn markers should be written this way */
+  JMETHOD(void, write_marker_header, (j_compress_ptr cinfo, int marker,
+				      unsigned int datalen));
+  JMETHOD(void, write_marker_byte, (j_compress_ptr cinfo, int val));
+};
+
+
+/* Declarations for decompression modules */
+
+/* Master control module */
+struct jpeg_decomp_master {
+  JMETHOD(void, prepare_for_output_pass, (j_decompress_ptr cinfo));
+  JMETHOD(void, finish_output_pass, (j_decompress_ptr cinfo));
+
+  /* State variables made visible to other modules */
+  boolean is_dummy_pass;	/* True during 1st pass for 2-pass quant */
+};
+
+/* Input control module */
+struct jpeg_input_controller {
+  JMETHOD(int, consume_input, (j_decompress_ptr cinfo));
+  JMETHOD(void, reset_input_controller, (j_decompress_ptr cinfo));
+  JMETHOD(void, start_input_pass, (j_decompress_ptr cinfo));
+  JMETHOD(void, finish_input_pass, (j_decompress_ptr cinfo));
+
+  /* State variables made visible to other modules */
+  boolean has_multiple_scans;	/* True if file has multiple scans */
+  boolean eoi_reached;		/* True when EOI has been consumed */
+};
+
+/* Main buffer control (downsampled-data buffer) */
+struct jpeg_d_main_controller {
+  JMETHOD(void, start_pass, (j_decompress_ptr cinfo, J_BUF_MODE pass_mode));
+  JMETHOD(void, process_data, (j_decompress_ptr cinfo,
+			       JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
+			       JDIMENSION out_rows_avail));
+};
+
+/* Coefficient buffer control */
+struct jpeg_d_coef_controller {
+  JMETHOD(void, start_input_pass, (j_decompress_ptr cinfo));
+  JMETHOD(int, consume_data, (j_decompress_ptr cinfo));
+  JMETHOD(void, start_output_pass, (j_decompress_ptr cinfo));
+  JMETHOD(int, decompress_data, (j_decompress_ptr cinfo,
+				 JSAMPIMAGE output_buf));
+  /* Pointer to array of coefficient virtual arrays, or NULL if none */
+  jvirt_barray_ptr *coef_arrays;
+};
+
+/* Decompression postprocessing (color quantization buffer control) */
+struct jpeg_d_post_controller {
+  JMETHOD(void, start_pass, (j_decompress_ptr cinfo, J_BUF_MODE pass_mode));
+  JMETHOD(void, post_process_data, (j_decompress_ptr cinfo,
+				    JSAMPIMAGE input_buf,
+				    JDIMENSION *in_row_group_ctr,
+				    JDIMENSION in_row_groups_avail,
+				    JSAMPARRAY output_buf,
+				    JDIMENSION *out_row_ctr,
+				    JDIMENSION out_rows_avail));
+};
+
+/* Marker reading & parsing */
+struct jpeg_marker_reader {
+  JMETHOD(void, reset_marker_reader, (j_decompress_ptr cinfo));
+  /* Read markers until SOS or EOI.
+   * Returns same codes as are defined for jpeg_consume_input:
+   * JPEG_SUSPENDED, JPEG_REACHED_SOS, or JPEG_REACHED_EOI.
+   */
+  JMETHOD(int, read_markers, (j_decompress_ptr cinfo));
+  /* Read a restart marker --- exported for use by entropy decoder only */
+  jpeg_marker_parser_method read_restart_marker;
+
+  /* State of marker reader --- nominally internal, but applications
+   * supplying COM or APPn handlers might like to know the state.
+   */
+  boolean saw_SOI;		/* found SOI? */
+  boolean saw_SOF;		/* found SOF? */
+  int next_restart_num;		/* next restart number expected (0-7) */
+  unsigned int discarded_bytes;	/* # of bytes skipped looking for a marker */
+};
+
+/* Entropy decoding */
+struct jpeg_entropy_decoder {
+  JMETHOD(void, start_pass, (j_decompress_ptr cinfo));
+  JMETHOD(boolean, decode_mcu, (j_decompress_ptr cinfo,
+				JBLOCKROW *MCU_data));
+
+  /* This is here to share code between baseline and progressive decoders; */
+  /* other modules probably should not use it */
+  boolean insufficient_data;	/* set TRUE after emitting warning */
+};
+
+/* Inverse DCT (also performs dequantization) */
+typedef JMETHOD(void, inverse_DCT_method_ptr,
+		(j_decompress_ptr cinfo, jpeg_component_info * compptr,
+		 JCOEFPTR coef_block,
+		 JSAMPARRAY output_buf, JDIMENSION output_col));
+
+struct jpeg_inverse_dct {
+  JMETHOD(void, start_pass, (j_decompress_ptr cinfo));
+  /* It is useful to allow each component to have a separate IDCT method. */
+  inverse_DCT_method_ptr inverse_DCT[MAX_COMPONENTS];
+};
+
+/* Upsampling (note that upsampler must also call color converter) */
+struct jpeg_upsampler {
+  JMETHOD(void, start_pass, (j_decompress_ptr cinfo));
+  JMETHOD(void, upsample, (j_decompress_ptr cinfo,
+			   JSAMPIMAGE input_buf,
+			   JDIMENSION *in_row_group_ctr,
+			   JDIMENSION in_row_groups_avail,
+			   JSAMPARRAY output_buf,
+			   JDIMENSION *out_row_ctr,
+			   JDIMENSION out_rows_avail));
+
+  boolean need_context_rows;	/* TRUE if need rows above & below */
+};
+
+/* Colorspace conversion */
+struct jpeg_color_deconverter {
+  JMETHOD(void, start_pass, (j_decompress_ptr cinfo));
+  JMETHOD(void, color_convert, (j_decompress_ptr cinfo,
+				JSAMPIMAGE input_buf, JDIMENSION input_row,
+				JSAMPARRAY output_buf, int num_rows));
+};
+
+/* Color quantization or color precision reduction */
+struct jpeg_color_quantizer {
+  JMETHOD(void, start_pass, (j_decompress_ptr cinfo, boolean is_pre_scan));
+  JMETHOD(void, color_quantize, (j_decompress_ptr cinfo,
+				 JSAMPARRAY input_buf, JSAMPARRAY output_buf,
+				 int num_rows));
+  JMETHOD(void, finish_pass, (j_decompress_ptr cinfo));
+  JMETHOD(void, new_color_map, (j_decompress_ptr cinfo));
+};
+
+
+/* Miscellaneous useful macros */
+
+#undef MAX
+#define MAX(a,b)	((a) > (b) ? (a) : (b))
+#undef MIN
+#define MIN(a,b)	((a) < (b) ? (a) : (b))
+
+
+/* We assume that right shift corresponds to signed division by 2 with
+ * rounding towards minus infinity.  This is correct for typical "arithmetic
+ * shift" instructions that shift in copies of the sign bit.  But some
+ * C compilers implement >> with an unsigned shift.  For these machines you
+ * must define RIGHT_SHIFT_IS_UNSIGNED.
+ * RIGHT_SHIFT provides a proper signed right shift of an INT32 quantity.
+ * It is only applied with constant shift counts.  SHIFT_TEMPS must be
+ * included in the variables of any routine using RIGHT_SHIFT.
+ */
+
+#ifdef RIGHT_SHIFT_IS_UNSIGNED
+#define SHIFT_TEMPS	INT32 shift_temp;
+#define RIGHT_SHIFT(x,shft)  \
+	((shift_temp = (x)) < 0 ? \
+	 (shift_temp >> (shft)) | ((~((INT32) 0)) << (32-(shft))) : \
+	 (shift_temp >> (shft)))
+#else
+#define SHIFT_TEMPS
+#define RIGHT_SHIFT(x,shft)	((x) >> (shft))
+#endif
+
+
+/* Short forms of external names for systems with brain-damaged linkers. */
+
+#ifdef NEED_SHORT_EXTERNAL_NAMES
+#define jinit_compress_master	jICompress
+#define jinit_c_master_control	jICMaster
+#define jinit_c_main_controller	jICMainC
+#define jinit_c_prep_controller	jICPrepC
+#define jinit_c_coef_controller	jICCoefC
+#define jinit_color_converter	jICColor
+#define jinit_downsampler	jIDownsampler
+#define jinit_forward_dct	jIFDCT
+#define jinit_huff_encoder	jIHEncoder
+#define jinit_phuff_encoder	jIPHEncoder
+#define jinit_marker_writer	jIMWriter
+#define jinit_master_decompress	jIDMaster
+#define jinit_d_main_controller	jIDMainC
+#define jinit_d_coef_controller	jIDCoefC
+#define jinit_d_post_controller	jIDPostC
+#define jinit_input_controller	jIInCtlr
+#define jinit_marker_reader	jIMReader
+#define jinit_huff_decoder	jIHDecoder
+#define jinit_phuff_decoder	jIPHDecoder
+#define jinit_inverse_dct	jIIDCT
+#define jinit_upsampler		jIUpsampler
+#define jinit_color_deconverter	jIDColor
+#define jinit_1pass_quantizer	jI1Quant
+#define jinit_2pass_quantizer	jI2Quant
+#define jinit_merged_upsampler	jIMUpsampler
+#define jinit_memory_mgr	jIMemMgr
+#define jdiv_round_up		jDivRound
+#define jround_up		jRound
+#define jcopy_sample_rows	jCopySamples
+#define jcopy_block_row		jCopyBlocks
+#define jzero_far		jZeroFar
+#define jpeg_zigzag_order	jZIGTable
+#define jpeg_natural_order	jZAGTable
+#endif /* NEED_SHORT_EXTERNAL_NAMES */
+
+
+/* Compression module initialization routines */
+EXTERN(void) jinit_compress_master JPP((j_compress_ptr cinfo));
+EXTERN(void) jinit_c_master_control JPP((j_compress_ptr cinfo,
+					 boolean transcode_only));
+EXTERN(void) jinit_c_main_controller JPP((j_compress_ptr cinfo,
+					  boolean need_full_buffer));
+EXTERN(void) jinit_c_prep_controller JPP((j_compress_ptr cinfo,
+					  boolean need_full_buffer));
+EXTERN(void) jinit_c_coef_controller JPP((j_compress_ptr cinfo,
+					  boolean need_full_buffer));
+EXTERN(void) jinit_color_converter JPP((j_compress_ptr cinfo));
+EXTERN(void) jinit_downsampler JPP((j_compress_ptr cinfo));
+EXTERN(void) jinit_forward_dct JPP((j_compress_ptr cinfo));
+EXTERN(void) jinit_huff_encoder JPP((j_compress_ptr cinfo));
+EXTERN(void) jinit_phuff_encoder JPP((j_compress_ptr cinfo));
+EXTERN(void) jinit_marker_writer JPP((j_compress_ptr cinfo));
+/* Decompression module initialization routines */
+EXTERN(void) jinit_master_decompress JPP((j_decompress_ptr cinfo));
+EXTERN(void) jinit_d_main_controller JPP((j_decompress_ptr cinfo,
+					  boolean need_full_buffer));
+EXTERN(void) jinit_d_coef_controller JPP((j_decompress_ptr cinfo,
+					  boolean need_full_buffer));
+EXTERN(void) jinit_d_post_controller JPP((j_decompress_ptr cinfo,
+					  boolean need_full_buffer));
+EXTERN(void) jinit_input_controller JPP((j_decompress_ptr cinfo));
+EXTERN(void) jinit_marker_reader JPP((j_decompress_ptr cinfo));
+EXTERN(void) jinit_huff_decoder JPP((j_decompress_ptr cinfo));
+EXTERN(void) jinit_phuff_decoder JPP((j_decompress_ptr cinfo));
+EXTERN(void) jinit_inverse_dct JPP((j_decompress_ptr cinfo));
+EXTERN(void) jinit_upsampler JPP((j_decompress_ptr cinfo));
+EXTERN(void) jinit_color_deconverter JPP((j_decompress_ptr cinfo));
+EXTERN(void) jinit_1pass_quantizer JPP((j_decompress_ptr cinfo));
+EXTERN(void) jinit_2pass_quantizer JPP((j_decompress_ptr cinfo));
+EXTERN(void) jinit_merged_upsampler JPP((j_decompress_ptr cinfo));
+/* Memory manager initialization */
+EXTERN(void) jinit_memory_mgr JPP((j_common_ptr cinfo));
+
+/* Utility routines in jutils.c */
+EXTERN(long) jdiv_round_up JPP((long a, long b));
+EXTERN(long) jround_up JPP((long a, long b));
+EXTERN(void) jcopy_sample_rows JPP((JSAMPARRAY input_array, int source_row,
+				    JSAMPARRAY output_array, int dest_row,
+				    int num_rows, JDIMENSION num_cols));
+EXTERN(void) jcopy_block_row JPP((JBLOCKROW input_row, JBLOCKROW output_row,
+				  JDIMENSION num_blocks));
+EXTERN(void) jzero_far JPP((void FAR * target, size_t bytestozero));
+/* Constant tables in jutils.c */
+#if 0				/* This table is not actually needed in v6a */
+extern const int jpeg_zigzag_order[]; /* natural coef order to zigzag order */
+#endif
+extern const int jpeg_natural_order[]; /* zigzag coef order to natural order */
+
+/* Suppress undefined-structure complaints if necessary. */
+
+#ifdef INCOMPLETE_TYPES_BROKEN
+#ifndef AM_MEMORY_MANAGER	/* only jmemmgr.c defines these */
+struct jvirt_sarray_control { long dummy; };
+struct jvirt_barray_control { long dummy; };
+#endif
+#endif /* INCOMPLETE_TYPES_BROKEN */
diff --git a/lib/a2jpeg-6b/jpeglib.h b/lib/a2jpeg-6b/jpeglib.h
new file mode 100644
index 0000000..d1be8dd
--- /dev/null
+++ b/lib/a2jpeg-6b/jpeglib.h
@@ -0,0 +1,1096 @@
+/*
+ * jpeglib.h
+ *
+ * Copyright (C) 1991-1998, Thomas G. Lane.
+ * This file is part of the Independent JPEG Group's software.
+ * For conditions of distribution and use, see the accompanying README file.
+ *
+ * This file defines the application interface for the JPEG library.
+ * Most applications using the library need only include this file,
+ * and perhaps jerror.h if they want to know the exact error codes.
+ */
+
+#ifndef JPEGLIB_H
+#define JPEGLIB_H
+
+/*
+ * First we include the configuration files that record how this
+ * installation of the JPEG library is set up.  jconfig.h can be
+ * generated automatically for many systems.  jmorecfg.h contains
+ * manual configuration options that most people need not worry about.
+ */
+
+#ifndef JCONFIG_INCLUDED	/* in case jinclude.h already did */
+#include "jconfig.h"		/* widely used configuration options */
+#endif
+#include "jmorecfg.h"		/* seldom changed options */
+
+
+/* Version ID for the JPEG library.
+ * Might be useful for tests like "#if JPEG_LIB_VERSION >= 60".
+ */
+
+#define JPEG_LIB_VERSION  62	/* Version 6b */
+
+
+/* Various constants determining the sizes of things.
+ * All of these are specified by the JPEG standard, so don't change them
+ * if you want to be compatible.
+ */
+
+#define DCTSIZE		    8	/* The basic DCT block is 8x8 samples */
+#define DCTSIZE2	    64	/* DCTSIZE squared; # of elements in a block */
+#define NUM_QUANT_TBLS      4	/* Quantization tables are numbered 0..3 */
+#define NUM_HUFF_TBLS       4	/* Huffman tables are numbered 0..3 */
+#define NUM_ARITH_TBLS      16	/* Arith-coding tables are numbered 0..15 */
+#define MAX_COMPS_IN_SCAN   4	/* JPEG limit on # of components in one scan */
+#define MAX_SAMP_FACTOR     4	/* JPEG limit on sampling factors */
+/* Unfortunately, some bozo at Adobe saw no reason to be bound by the standard;
+ * the PostScript DCT filter can emit files with many more than 10 blocks/MCU.
+ * If you happen to run across such a file, you can up D_MAX_BLOCKS_IN_MCU
+ * to handle it.  We even let you do this from the jconfig.h file.  However,
+ * we strongly discourage changing C_MAX_BLOCKS_IN_MCU; just because Adobe
+ * sometimes emits noncompliant files doesn't mean you should too.
+ */
+#define C_MAX_BLOCKS_IN_MCU   10 /* compressor's limit on blocks per MCU */
+#ifndef D_MAX_BLOCKS_IN_MCU
+#define D_MAX_BLOCKS_IN_MCU   10 /* decompressor's limit on blocks per MCU */
+#endif
+
+
+/* Data structures for images (arrays of samples and of DCT coefficients).
+ * On 80x86 machines, the image arrays are too big for near pointers,
+ * but the pointer arrays can fit in near memory.
+ */
+
+typedef JSAMPLE FAR *JSAMPROW;	/* ptr to one image row of pixel samples. */
+typedef JSAMPROW *JSAMPARRAY;	/* ptr to some rows (a 2-D sample array) */
+typedef JSAMPARRAY *JSAMPIMAGE;	/* a 3-D sample array: top index is color */
+
+typedef JCOEF JBLOCK[DCTSIZE2];	/* one block of coefficients */
+typedef JBLOCK FAR *JBLOCKROW;	/* pointer to one row of coefficient blocks */
+typedef JBLOCKROW *JBLOCKARRAY;		/* a 2-D array of coefficient blocks */
+typedef JBLOCKARRAY *JBLOCKIMAGE;	/* a 3-D array of coefficient blocks */
+
+typedef JCOEF FAR *JCOEFPTR;	/* useful in a couple of places */
+
+
+/* Types for JPEG compression parameters and working tables. */
+
+
+/* DCT coefficient quantization tables. */
+
+typedef struct {
+  /* This array gives the coefficient quantizers in natural array order
+   * (not the zigzag order in which they are stored in a JPEG DQT marker).
+   * CAUTION: IJG versions prior to v6a kept this array in zigzag order.
+   */
+  UINT16 quantval[DCTSIZE2];	/* quantization step for each coefficient */
+  /* This field is used only during compression.  It's initialized FALSE when
+   * the table is created, and set TRUE when it's been output to the file.
+   * You could suppress output of a table by setting this to TRUE.
+   * (See jpeg_suppress_tables for an example.)
+   */
+  boolean sent_table;		/* TRUE when table has been output */
+} JQUANT_TBL;
+
+
+/* Huffman coding tables. */
+
+typedef struct {
+  /* These two fields directly represent the contents of a JPEG DHT marker */
+  UINT8 bits[17];		/* bits[k] = # of symbols with codes of */
+				/* length k bits; bits[0] is unused */
+  UINT8 huffval[256];		/* The symbols, in order of incr code length */
+  /* This field is used only during compression.  It's initialized FALSE when
+   * the table is created, and set TRUE when it's been output to the file.
+   * You could suppress output of a table by setting this to TRUE.
+   * (See jpeg_suppress_tables for an example.)
+   */
+  boolean sent_table;		/* TRUE when table has been output */
+} JHUFF_TBL;
+
+
+/* Basic info about one component (color channel). */
+
+typedef struct {
+  /* These values are fixed over the whole image. */
+  /* For compression, they must be supplied by parameter setup; */
+  /* for decompression, they are read from the SOF marker. */
+  int component_id;		/* identifier for this component (0..255) */
+  int component_index;		/* its index in SOF or cinfo->comp_info[] */
+  int h_samp_factor;		/* horizontal sampling factor (1..4) */
+  int v_samp_factor;		/* vertical sampling factor (1..4) */
+  int quant_tbl_no;		/* quantization table selector (0..3) */
+  /* These values may vary between scans. */
+  /* For compression, they must be supplied by parameter setup; */
+  /* for decompression, they are read from the SOS marker. */
+  /* The decompressor output side may not use these variables. */
+  int dc_tbl_no;		/* DC entropy table selector (0..3) */
+  int ac_tbl_no;		/* AC entropy table selector (0..3) */
+  
+  /* Remaining fields should be treated as private by applications. */
+  
+  /* These values are computed during compression or decompression startup: */
+  /* Component's size in DCT blocks.
+   * Any dummy blocks added to complete an MCU are not counted; therefore
+   * these values do not depend on whether a scan is interleaved or not.
+   */
+  JDIMENSION width_in_blocks;
+  JDIMENSION height_in_blocks;
+  /* Size of a DCT block in samples.  Always DCTSIZE for compression.
+   * For decompression this is the size of the output from one DCT block,
+   * reflecting any scaling we choose to apply during the IDCT step.
+   * Values of 1,2,4,8 are likely to be supported.  Note that different
+   * components may receive different IDCT scalings.
+   */
+  int DCT_scaled_size;
+  /* The downsampled dimensions are the component's actual, unpadded number
+   * of samples at the main buffer (preprocessing/compression interface), thus
+   * downsampled_width = ceil(image_width * Hi/Hmax)
+   * and similarly for height.  For decompression, IDCT scaling is included, so
+   * downsampled_width = ceil(image_width * Hi/Hmax * DCT_scaled_size/DCTSIZE)
+   */
+  JDIMENSION downsampled_width;	 /* actual width in samples */
+  JDIMENSION downsampled_height; /* actual height in samples */
+  /* This flag is used only for decompression.  In cases where some of the
+   * components will be ignored (eg grayscale output from YCbCr image),
+   * we can skip most computations for the unused components.
+   */
+  boolean component_needed;	/* do we need the value of this component? */
+
+  /* These values are computed before starting a scan of the component. */
+  /* The decompressor output side may not use these variables. */
+  int MCU_width;		/* number of blocks per MCU, horizontally */
+  int MCU_height;		/* number of blocks per MCU, vertically */
+  int MCU_blocks;		/* MCU_width * MCU_height */
+  int MCU_sample_width;		/* MCU width in samples, MCU_width*DCT_scaled_size */
+  int last_col_width;		/* # of non-dummy blocks across in last MCU */
+  int last_row_height;		/* # of non-dummy blocks down in last MCU */
+
+  /* Saved quantization table for component; NULL if none yet saved.
+   * See jdinput.c comments about the need for this information.
+   * This field is currently used only for decompression.
+   */
+  JQUANT_TBL * quant_table;
+
+  /* Private per-component storage for DCT or IDCT subsystem. */
+  void * dct_table;
+} jpeg_component_info;
+
+
+/* The script for encoding a multiple-scan file is an array of these: */
+
+typedef struct {
+  int comps_in_scan;		/* number of components encoded in this scan */
+  int component_index[MAX_COMPS_IN_SCAN]; /* their SOF/comp_info[] indexes */
+  int Ss, Se;			/* progressive JPEG spectral selection parms */
+  int Ah, Al;			/* progressive JPEG successive approx. parms */
+} jpeg_scan_info;
+
+/* The decompressor can save APPn and COM markers in a list of these: */
+
+typedef struct jpeg_marker_struct FAR * jpeg_saved_marker_ptr;
+
+struct jpeg_marker_struct {
+  jpeg_saved_marker_ptr next;	/* next in list, or NULL */
+  UINT8 marker;			/* marker code: JPEG_COM, or JPEG_APP0+n */
+  unsigned int original_length;	/* # bytes of data in the file */
+  unsigned int data_length;	/* # bytes of data saved at data[] */
+  JOCTET FAR * data;		/* the data contained in the marker */
+  /* the marker length word is not counted in data_length or original_length */
+};
+
+/* Known color spaces. */
+
+typedef enum {
+	JCS_UNKNOWN,		/* error/unspecified */
+	JCS_GRAYSCALE,		/* monochrome */
+	JCS_RGB,		/* red/green/blue */
+	JCS_YCbCr,		/* Y/Cb/Cr (also known as YUV) */
+	JCS_CMYK,		/* C/M/Y/K */
+	JCS_YCCK		/* Y/Cb/Cr/K */
+} J_COLOR_SPACE;
+
+/* DCT/IDCT algorithm options. */
+
+typedef enum {
+	JDCT_ISLOW,		/* slow but accurate integer algorithm */
+	JDCT_IFAST,		/* faster, less accurate integer method */
+	JDCT_FLOAT		/* floating-point: accurate, fast on fast HW */
+} J_DCT_METHOD;
+
+#ifndef JDCT_DEFAULT		/* may be overridden in jconfig.h */
+#define JDCT_DEFAULT  JDCT_ISLOW
+#endif
+#ifndef JDCT_FASTEST		/* may be overridden in jconfig.h */
+#define JDCT_FASTEST  JDCT_IFAST
+#endif
+
+/* Dithering options for decompression. */
+
+typedef enum {
+	JDITHER_NONE,		/* no dithering */
+	JDITHER_ORDERED,	/* simple ordered dither */
+	JDITHER_FS		/* Floyd-Steinberg error diffusion dither */
+} J_DITHER_MODE;
+
+
+/* Common fields between JPEG compression and decompression master structs. */
+
+#define jpeg_common_fields \
+  struct jpeg_error_mgr * err;	/* Error handler module */\
+  struct jpeg_memory_mgr * mem;	/* Memory manager module */\
+  struct jpeg_progress_mgr * progress; /* Progress monitor, or NULL if none */\
+  void * client_data;		/* Available for use by application */\
+  boolean is_decompressor;	/* So common code can tell which is which */\
+  int global_state		/* For checking call sequence validity */
+
+/* Routines that are to be used by both halves of the library are declared
+ * to receive a pointer to this structure.  There are no actual instances of
+ * jpeg_common_struct, only of jpeg_compress_struct and jpeg_decompress_struct.
+ */
+struct jpeg_common_struct {
+  jpeg_common_fields;		/* Fields common to both master struct types */
+  /* Additional fields follow in an actual jpeg_compress_struct or
+   * jpeg_decompress_struct.  All three structs must agree on these
+   * initial fields!  (This would be a lot cleaner in C++.)
+   */
+};
+
+typedef struct jpeg_common_struct * j_common_ptr;
+typedef struct jpeg_compress_struct * j_compress_ptr;
+typedef struct jpeg_decompress_struct * j_decompress_ptr;
+
+
+/* Master record for a compression instance */
+
+struct jpeg_compress_struct {
+  jpeg_common_fields;		/* Fields shared with jpeg_decompress_struct */
+
+  /* Destination for compressed data */
+  struct jpeg_destination_mgr * dest;
+
+  /* Description of source image --- these fields must be filled in by
+   * outer application before starting compression.  in_color_space must
+   * be correct before you can even call jpeg_set_defaults().
+   */
+
+  JDIMENSION image_width;	/* input image width */
+  JDIMENSION image_height;	/* input image height */
+  int input_components;		/* # of color components in input image */
+  J_COLOR_SPACE in_color_space;	/* colorspace of input image */
+
+  double input_gamma;		/* image gamma of input image */
+
+  /* Compression parameters --- these fields must be set before calling
+   * jpeg_start_compress().  We recommend calling jpeg_set_defaults() to
+   * initialize everything to reasonable defaults, then changing anything
+   * the application specifically wants to change.  That way you won't get
+   * burnt when new parameters are added.  Also note that there are several
+   * helper routines to simplify changing parameters.
+   */
+
+  int data_precision;		/* bits of precision in image data */
+
+  int num_components;		/* # of color components in JPEG image */
+  J_COLOR_SPACE jpeg_color_space; /* colorspace of JPEG image */
+
+  jpeg_component_info * comp_info;
+  /* comp_info[i] describes component that appears i'th in SOF */
+  
+  JQUANT_TBL * quant_tbl_ptrs[NUM_QUANT_TBLS];
+  /* ptrs to coefficient quantization tables, or NULL if not defined */
+  
+  JHUFF_TBL * dc_huff_tbl_ptrs[NUM_HUFF_TBLS];
+  JHUFF_TBL * ac_huff_tbl_ptrs[NUM_HUFF_TBLS];
+  /* ptrs to Huffman coding tables, or NULL if not defined */
+  
+  UINT8 arith_dc_L[NUM_ARITH_TBLS]; /* L values for DC arith-coding tables */
+  UINT8 arith_dc_U[NUM_ARITH_TBLS]; /* U values for DC arith-coding tables */
+  UINT8 arith_ac_K[NUM_ARITH_TBLS]; /* Kx values for AC arith-coding tables */
+
+  int num_scans;		/* # of entries in scan_info array */
+  const jpeg_scan_info * scan_info; /* script for multi-scan file, or NULL */
+  /* The default value of scan_info is NULL, which causes a single-scan
+   * sequential JPEG file to be emitted.  To create a multi-scan file,
+   * set num_scans and scan_info to point to an array of scan definitions.
+   */
+
+  boolean raw_data_in;		/* TRUE=caller supplies downsampled data */
+  boolean arith_code;		/* TRUE=arithmetic coding, FALSE=Huffman */
+  boolean optimize_coding;	/* TRUE=optimize entropy encoding parms */
+  boolean CCIR601_sampling;	/* TRUE=first samples are cosited */
+  int smoothing_factor;		/* 1..100, or 0 for no input smoothing */
+  J_DCT_METHOD dct_method;	/* DCT algorithm selector */
+
+  /* The restart interval can be specified in absolute MCUs by setting
+   * restart_interval, or in MCU rows by setting restart_in_rows
+   * (in which case the correct restart_interval will be figured
+   * for each scan).
+   */
+  unsigned int restart_interval; /* MCUs per restart, or 0 for no restart */
+  int restart_in_rows;		/* if > 0, MCU rows per restart interval */
+
+  /* Parameters controlling emission of special markers. */
+
+  boolean write_JFIF_header;	/* should a JFIF marker be written? */
+  UINT8 JFIF_major_version;	/* What to write for the JFIF version number */
+  UINT8 JFIF_minor_version;
+  /* These three values are not used by the JPEG code, merely copied */
+  /* into the JFIF APP0 marker.  density_unit can be 0 for unknown, */
+  /* 1 for dots/inch, or 2 for dots/cm.  Note that the pixel aspect */
+  /* ratio is defined by X_density/Y_density even when density_unit=0. */
+  UINT8 density_unit;		/* JFIF code for pixel size units */
+  UINT16 X_density;		/* Horizontal pixel density */
+  UINT16 Y_density;		/* Vertical pixel density */
+  boolean write_Adobe_marker;	/* should an Adobe marker be written? */
+  
+  /* State variable: index of next scanline to be written to
+   * jpeg_write_scanlines().  Application may use this to control its
+   * processing loop, e.g., "while (next_scanline < image_height)".
+   */
+
+  JDIMENSION next_scanline;	/* 0 .. image_height-1  */
+
+  /* Remaining fields are known throughout compressor, but generally
+   * should not be touched by a surrounding application.
+   */
+
+  /*
+   * These fields are computed during compression startup
+   */
+  boolean progressive_mode;	/* TRUE if scan script uses progressive mode */
+  int max_h_samp_factor;	/* largest h_samp_factor */
+  int max_v_samp_factor;	/* largest v_samp_factor */
+
+  JDIMENSION total_iMCU_rows;	/* # of iMCU rows to be input to coef ctlr */
+  /* The coefficient controller receives data in units of MCU rows as defined
+   * for fully interleaved scans (whether the JPEG file is interleaved or not).
+   * There are v_samp_factor * DCTSIZE sample rows of each component in an
+   * "iMCU" (interleaved MCU) row.
+   */
+  
+  /*
+   * These fields are valid during any one scan.
+   * They describe the components and MCUs actually appearing in the scan.
+   */
+  int comps_in_scan;		/* # of JPEG components in this scan */
+  jpeg_component_info * cur_comp_info[MAX_COMPS_IN_SCAN];
+  /* *cur_comp_info[i] describes component that appears i'th in SOS */
+  
+  JDIMENSION MCUs_per_row;	/* # of MCUs across the image */
+  JDIMENSION MCU_rows_in_scan;	/* # of MCU rows in the image */
+  
+  int blocks_in_MCU;		/* # of DCT blocks per MCU */
+  int MCU_membership[C_MAX_BLOCKS_IN_MCU];
+  /* MCU_membership[i] is index in cur_comp_info of component owning */
+  /* i'th block in an MCU */
+
+  int Ss, Se, Ah, Al;		/* progressive JPEG parameters for scan */
+
+  /*
+   * Links to compression subobjects (methods and private variables of modules)
+   */
+  struct jpeg_comp_master * master;
+  struct jpeg_c_main_controller * main;
+  struct jpeg_c_prep_controller * prep;
+  struct jpeg_c_coef_controller * coef;
+  struct jpeg_marker_writer * marker;
+  struct jpeg_color_converter * cconvert;
+  struct jpeg_downsampler * downsample;
+  struct jpeg_forward_dct * fdct;
+  struct jpeg_entropy_encoder * entropy;
+  jpeg_scan_info * script_space; /* workspace for jpeg_simple_progression */
+  int script_space_size;
+};
+
+
+/* Master record for a decompression instance */
+
+struct jpeg_decompress_struct {
+  jpeg_common_fields;		/* Fields shared with jpeg_compress_struct */
+
+  /* Source of compressed data */
+  struct jpeg_source_mgr * src;
+
+  /* Basic description of image --- filled in by jpeg_read_header(). */
+  /* Application may inspect these values to decide how to process image. */
+
+  JDIMENSION image_width;	/* nominal image width (from SOF marker) */
+  JDIMENSION image_height;	/* nominal image height */
+  int num_components;		/* # of color components in JPEG image */
+  J_COLOR_SPACE jpeg_color_space; /* colorspace of JPEG image */
+
+  /* Decompression processing parameters --- these fields must be set before
+   * calling jpeg_start_decompress().  Note that jpeg_read_header() initializes
+   * them to default values.
+   */
+
+  J_COLOR_SPACE out_color_space; /* colorspace for output */
+
+  unsigned int scale_num, scale_denom; /* fraction by which to scale image */
+
+  double output_gamma;		/* image gamma wanted in output */
+
+  boolean buffered_image;	/* TRUE=multiple output passes */
+  boolean raw_data_out;		/* TRUE=downsampled data wanted */
+
+  J_DCT_METHOD dct_method;	/* IDCT algorithm selector */
+  boolean do_fancy_upsampling;	/* TRUE=apply fancy upsampling */
+  boolean do_block_smoothing;	/* TRUE=apply interblock smoothing */
+
+  boolean quantize_colors;	/* TRUE=colormapped output wanted */
+  /* the following are ignored if not quantize_colors: */
+  J_DITHER_MODE dither_mode;	/* type of color dithering to use */
+  boolean two_pass_quantize;	/* TRUE=use two-pass color quantization */
+  int desired_number_of_colors;	/* max # colors to use in created colormap */
+  /* these are significant only in buffered-image mode: */
+  boolean enable_1pass_quant;	/* enable future use of 1-pass quantizer */
+  boolean enable_external_quant;/* enable future use of external colormap */
+  boolean enable_2pass_quant;	/* enable future use of 2-pass quantizer */
+
+  /* Description of actual output image that will be returned to application.
+   * These fields are computed by jpeg_start_decompress().
+   * You can also use jpeg_calc_output_dimensions() to determine these values
+   * in advance of calling jpeg_start_decompress().
+   */
+
+  JDIMENSION output_width;	/* scaled image width */
+  JDIMENSION output_height;	/* scaled image height */
+  int out_color_components;	/* # of color components in out_color_space */
+  int output_components;	/* # of color components returned */
+  /* output_components is 1 (a colormap index) when quantizing colors;
+   * otherwise it equals out_color_components.
+   */
+  int rec_outbuf_height;	/* min recommended height of scanline buffer */
+  /* If the buffer passed to jpeg_read_scanlines() is less than this many rows
+   * high, space and time will be wasted due to unnecessary data copying.
+   * Usually rec_outbuf_height will be 1 or 2, at most 4.
+   */
+
+  /* When quantizing colors, the output colormap is described by these fields.
+   * The application can supply a colormap by setting colormap non-NULL before
+   * calling jpeg_start_decompress; otherwise a colormap is created during
+   * jpeg_start_decompress or jpeg_start_output.
+   * The map has out_color_components rows and actual_number_of_colors columns.
+   */
+  int actual_number_of_colors;	/* number of entries in use */
+  JSAMPARRAY colormap;		/* The color map as a 2-D pixel array */
+
+  /* State variables: these variables indicate the progress of decompression.
+   * The application may examine these but must not modify them.
+   */
+
+  /* Row index of next scanline to be read from jpeg_read_scanlines().
+   * Application may use this to control its processing loop, e.g.,
+   * "while (output_scanline < output_height)".
+   */
+  JDIMENSION output_scanline;	/* 0 .. output_height-1  */
+
+  /* Current input scan number and number of iMCU rows completed in scan.
+   * These indicate the progress of the decompressor input side.
+   */
+  int input_scan_number;	/* Number of SOS markers seen so far */
+  JDIMENSION input_iMCU_row;	/* Number of iMCU rows completed */
+
+  /* The "output scan number" is the notional scan being displayed by the
+   * output side.  The decompressor will not allow output scan/row number
+   * to get ahead of input scan/row, but it can fall arbitrarily far behind.
+   */
+  int output_scan_number;	/* Nominal scan number being displayed */
+  JDIMENSION output_iMCU_row;	/* Number of iMCU rows read */
+
+  /* Current progression status.  coef_bits[c][i] indicates the precision
+   * with which component c's DCT coefficient i (in zigzag order) is known.
+   * It is -1 when no data has yet been received, otherwise it is the point
+   * transform (shift) value for the most recent scan of the coefficient
+   * (thus, 0 at completion of the progression).
+   * This pointer is NULL when reading a non-progressive file.
+   */
+  int (*coef_bits)[DCTSIZE2];	/* -1 or current Al value for each coef */
+
+  /* Internal JPEG parameters --- the application usually need not look at
+   * these fields.  Note that the decompressor output side may not use
+   * any parameters that can change between scans.
+   */
+
+  /* Quantization and Huffman tables are carried forward across input
+   * datastreams when processing abbreviated JPEG datastreams.
+   */
+
+  JQUANT_TBL * quant_tbl_ptrs[NUM_QUANT_TBLS];
+  /* ptrs to coefficient quantization tables, or NULL if not defined */
+
+  JHUFF_TBL * dc_huff_tbl_ptrs[NUM_HUFF_TBLS];
+  JHUFF_TBL * ac_huff_tbl_ptrs[NUM_HUFF_TBLS];
+  /* ptrs to Huffman coding tables, or NULL if not defined */
+
+  /* These parameters are never carried across datastreams, since they
+   * are given in SOF/SOS markers or defined to be reset by SOI.
+   */
+
+  int data_precision;		/* bits of precision in image data */
+
+  jpeg_component_info * comp_info;
+  /* comp_info[i] describes component that appears i'th in SOF */
+
+  boolean progressive_mode;	/* TRUE if SOFn specifies progressive mode */
+  boolean arith_code;		/* TRUE=arithmetic coding, FALSE=Huffman */
+
+  UINT8 arith_dc_L[NUM_ARITH_TBLS]; /* L values for DC arith-coding tables */
+  UINT8 arith_dc_U[NUM_ARITH_TBLS]; /* U values for DC arith-coding tables */
+  UINT8 arith_ac_K[NUM_ARITH_TBLS]; /* Kx values for AC arith-coding tables */
+
+  unsigned int restart_interval; /* MCUs per restart interval, or 0 for no restart */
+
+  /* These fields record data obtained from optional markers recognized by
+   * the JPEG library.
+   */
+  boolean saw_JFIF_marker;	/* TRUE iff a JFIF APP0 marker was found */
+  /* Data copied from JFIF marker; only valid if saw_JFIF_marker is TRUE: */
+  UINT8 JFIF_major_version;	/* JFIF version number */
+  UINT8 JFIF_minor_version;
+  UINT8 density_unit;		/* JFIF code for pixel size units */
+  UINT16 X_density;		/* Horizontal pixel density */
+  UINT16 Y_density;		/* Vertical pixel density */
+  boolean saw_Adobe_marker;	/* TRUE iff an Adobe APP14 marker was found */
+  UINT8 Adobe_transform;	/* Color transform code from Adobe marker */
+
+  boolean CCIR601_sampling;	/* TRUE=first samples are cosited */
+
+  /* Aside from the specific data retained from APPn markers known to the
+   * library, the uninterpreted contents of any or all APPn and COM markers
+   * can be saved in a list for examination by the application.
+   */
+  jpeg_saved_marker_ptr marker_list; /* Head of list of saved markers */
+
+  /* Remaining fields are known throughout decompressor, but generally
+   * should not be touched by a surrounding application.
+   */
+
+  /*
+   * These fields are computed during decompression startup
+   */
+  int max_h_samp_factor;	/* largest h_samp_factor */
+  int max_v_samp_factor;	/* largest v_samp_factor */
+
+  int min_DCT_scaled_size;	/* smallest DCT_scaled_size of any component */
+
+  JDIMENSION total_iMCU_rows;	/* # of iMCU rows in image */
+  /* The coefficient controller's input and output progress is measured in
+   * units of "iMCU" (interleaved MCU) rows.  These are the same as MCU rows
+   * in fully interleaved JPEG scans, but are used whether the scan is
+   * interleaved or not.  We define an iMCU row as v_samp_factor DCT block
+   * rows of each component.  Therefore, the IDCT output contains
+   * v_samp_factor*DCT_scaled_size sample rows of a component per iMCU row.
+   */
+
+  JSAMPLE * sample_range_limit; /* table for fast range-limiting */
+
+  /*
+   * These fields are valid during any one scan.
+   * They describe the components and MCUs actually appearing in the scan.
+   * Note that the decompressor output side must not use these fields.
+   */
+  int comps_in_scan;		/* # of JPEG components in this scan */
+  jpeg_component_info * cur_comp_info[MAX_COMPS_IN_SCAN];
+  /* *cur_comp_info[i] describes component that appears i'th in SOS */
+
+  JDIMENSION MCUs_per_row;	/* # of MCUs across the image */
+  JDIMENSION MCU_rows_in_scan;	/* # of MCU rows in the image */
+
+  int blocks_in_MCU;		/* # of DCT blocks per MCU */
+  int MCU_membership[D_MAX_BLOCKS_IN_MCU];
+  /* MCU_membership[i] is index in cur_comp_info of component owning */
+  /* i'th block in an MCU */
+
+  int Ss, Se, Ah, Al;		/* progressive JPEG parameters for scan */
+
+  /* This field is shared between entropy decoder and marker parser.
+   * It is either zero or the code of a JPEG marker that has been
+   * read from the data source, but has not yet been processed.
+   */
+  int unread_marker;
+
+  /*
+   * Links to decompression subobjects (methods, private variables of modules)
+   */
+  struct jpeg_decomp_master * master;
+  struct jpeg_d_main_controller * main;
+  struct jpeg_d_coef_controller * coef;
+  struct jpeg_d_post_controller * post;
+  struct jpeg_input_controller * inputctl;
+  struct jpeg_marker_reader * marker;
+  struct jpeg_entropy_decoder * entropy;
+  struct jpeg_inverse_dct * idct;
+  struct jpeg_upsampler * upsample;
+  struct jpeg_color_deconverter * cconvert;
+  struct jpeg_color_quantizer * cquantize;
+};
+
+
+/* "Object" declarations for JPEG modules that may be supplied or called
+ * directly by the surrounding application.
+ * As with all objects in the JPEG library, these structs only define the
+ * publicly visible methods and state variables of a module.  Additional
+ * private fields may exist after the public ones.
+ */
+
+
+/* Error handler object */
+
+struct jpeg_error_mgr {
+  /* Error exit handler: does not return to caller */
+  JMETHOD(void, error_exit, (j_common_ptr cinfo));
+  /* Conditionally emit a trace or warning message */
+  JMETHOD(void, emit_message, (j_common_ptr cinfo, int msg_level));
+  /* Routine that actually outputs a trace or error message */
+  JMETHOD(void, output_message, (j_common_ptr cinfo));
+  /* Format a message string for the most recent JPEG error or message */
+  JMETHOD(void, format_message, (j_common_ptr cinfo, char * buffer));
+#define JMSG_LENGTH_MAX  200	/* recommended size of format_message buffer */
+  /* Reset error state variables at start of a new image */
+  JMETHOD(void, reset_error_mgr, (j_common_ptr cinfo));
+  
+  /* The message ID code and any parameters are saved here.
+   * A message can have one string parameter or up to 8 int parameters.
+   */
+  int msg_code;
+#define JMSG_STR_PARM_MAX  80
+  union {
+    int i[8];
+    char s[JMSG_STR_PARM_MAX];
+  } msg_parm;
+  
+  /* Standard state variables for error facility */
+  
+  int trace_level;		/* max msg_level that will be displayed */
+  
+  /* For recoverable corrupt-data errors, we emit a warning message,
+   * but keep going unless emit_message chooses to abort.  emit_message
+   * should count warnings in num_warnings.  The surrounding application
+   * can check for bad data by seeing if num_warnings is nonzero at the
+   * end of processing.
+   */
+  long num_warnings;		/* number of corrupt-data warnings */
+
+  /* These fields point to the table(s) of error message strings.
+   * An application can change the table pointer to switch to a different
+   * message list (typically, to change the language in which errors are
+   * reported).  Some applications may wish to add additional error codes
+   * that will be handled by the JPEG library error mechanism; the second
+   * table pointer is used for this purpose.
+   *
+   * First table includes all errors generated by JPEG library itself.
+   * Error code 0 is reserved for a "no such error string" message.
+   */
+  const char * const * jpeg_message_table; /* Library errors */
+  int last_jpeg_message;    /* Table contains strings 0..last_jpeg_message */
+  /* Second table can be added by application (see cjpeg/djpeg for example).
+   * It contains strings numbered first_addon_message..last_addon_message.
+   */
+  const char * const * addon_message_table; /* Non-library errors */
+  int first_addon_message;	/* code for first string in addon table */
+  int last_addon_message;	/* code for last string in addon table */
+};
+
+
+/* Progress monitor object */
+
+struct jpeg_progress_mgr {
+  JMETHOD(void, progress_monitor, (j_common_ptr cinfo));
+
+  long pass_counter;		/* work units completed in this pass */
+  long pass_limit;		/* total number of work units in this pass */
+  int completed_passes;		/* passes completed so far */
+  int total_passes;		/* total number of passes expected */
+};
+
+
+/* Data destination object for compression */
+
+struct jpeg_destination_mgr {
+  JOCTET * next_output_byte;	/* => next byte to write in buffer */
+  size_t free_in_buffer;	/* # of byte spaces remaining in buffer */
+
+  JMETHOD(void, init_destination, (j_compress_ptr cinfo));
+  JMETHOD(boolean, empty_output_buffer, (j_compress_ptr cinfo));
+  JMETHOD(void, term_destination, (j_compress_ptr cinfo));
+};
+
+
+/* Data source object for decompression */
+
+struct jpeg_source_mgr {
+  const JOCTET * next_input_byte; /* => next byte to read from buffer */
+  size_t bytes_in_buffer;	/* # of bytes remaining in buffer */
+
+  JMETHOD(void, init_source, (j_decompress_ptr cinfo));
+  JMETHOD(boolean, fill_input_buffer, (j_decompress_ptr cinfo));
+  JMETHOD(void, skip_input_data, (j_decompress_ptr cinfo, long num_bytes));
+  JMETHOD(boolean, resync_to_restart, (j_decompress_ptr cinfo, int desired));
+  JMETHOD(void, term_source, (j_decompress_ptr cinfo));
+};
+
+
+/* Memory manager object.
+ * Allocates "small" objects (a few K total), "large" objects (tens of K),
+ * and "really big" objects (virtual arrays with backing store if needed).
+ * The memory manager does not allow individual objects to be freed; rather,
+ * each created object is assigned to a pool, and whole pools can be freed
+ * at once.  This is faster and more convenient than remembering exactly what
+ * to free, especially where malloc()/free() are not too speedy.
+ * NB: alloc routines never return NULL.  They exit to error_exit if not
+ * successful.
+ */
+
+#define JPOOL_PERMANENT	0	/* lasts until master record is destroyed */
+#define JPOOL_IMAGE	1	/* lasts until done with image/datastream */
+#define JPOOL_NUMPOOLS	2
+
+typedef struct jvirt_sarray_control * jvirt_sarray_ptr;
+typedef struct jvirt_barray_control * jvirt_barray_ptr;
+
+
+struct jpeg_memory_mgr {
+  /* Method pointers */
+  JMETHOD(void *, alloc_small, (j_common_ptr cinfo, int pool_id,
+				size_t sizeofobject));
+  JMETHOD(void FAR *, alloc_large, (j_common_ptr cinfo, int pool_id,
+				     size_t sizeofobject));
+  JMETHOD(JSAMPARRAY, alloc_sarray, (j_common_ptr cinfo, int pool_id,
+				     JDIMENSION samplesperrow,
+				     JDIMENSION numrows));
+  JMETHOD(JBLOCKARRAY, alloc_barray, (j_common_ptr cinfo, int pool_id,
+				      JDIMENSION blocksperrow,
+				      JDIMENSION numrows));
+  JMETHOD(jvirt_sarray_ptr, request_virt_sarray, (j_common_ptr cinfo,
+						  int pool_id,
+						  boolean pre_zero,
+						  JDIMENSION samplesperrow,
+						  JDIMENSION numrows,
+						  JDIMENSION maxaccess));
+  JMETHOD(jvirt_barray_ptr, request_virt_barray, (j_common_ptr cinfo,
+						  int pool_id,
+						  boolean pre_zero,
+						  JDIMENSION blocksperrow,
+						  JDIMENSION numrows,
+						  JDIMENSION maxaccess));
+  JMETHOD(void, realize_virt_arrays, (j_common_ptr cinfo));
+  JMETHOD(JSAMPARRAY, access_virt_sarray, (j_common_ptr cinfo,
+					   jvirt_sarray_ptr ptr,
+					   JDIMENSION start_row,
+					   JDIMENSION num_rows,
+					   boolean writable));
+  JMETHOD(JBLOCKARRAY, access_virt_barray, (j_common_ptr cinfo,
+					    jvirt_barray_ptr ptr,
+					    JDIMENSION start_row,
+					    JDIMENSION num_rows,
+					    boolean writable));
+  JMETHOD(void, free_pool, (j_common_ptr cinfo, int pool_id));
+  JMETHOD(void, self_destruct, (j_common_ptr cinfo));
+
+  /* Limit on memory allocation for this JPEG object.  (Note that this is
+   * merely advisory, not a guaranteed maximum; it only affects the space
+   * used for virtual-array buffers.)  May be changed by outer application
+   * after creating the JPEG object.
+   */
+  long max_memory_to_use;
+
+  /* Maximum allocation request accepted by alloc_large. */
+  long max_alloc_chunk;
+};
+
+
+/* Routine signature for application-supplied marker processing methods.
+ * Need not pass marker code since it is stored in cinfo->unread_marker.
+ */
+typedef JMETHOD(boolean, jpeg_marker_parser_method, (j_decompress_ptr cinfo));
+
+
+/* Declarations for routines called by application.
+ * The JPP macro hides prototype parameters from compilers that can't cope.
+ * Note JPP requires double parentheses.
+ */
+
+#ifdef HAVE_PROTOTYPES
+#define JPP(arglist)	arglist
+#else
+#define JPP(arglist)	()
+#endif
+
+
+/* Short forms of external names for systems with brain-damaged linkers.
+ * We shorten external names to be unique in the first six letters, which
+ * is good enough for all known systems.
+ * (If your compiler itself needs names to be unique in less than 15 
+ * characters, you are out of luck.  Get a better compiler.)
+ */
+
+#ifdef NEED_SHORT_EXTERNAL_NAMES
+#define jpeg_std_error		jStdError
+#define jpeg_CreateCompress	jCreaCompress
+#define jpeg_CreateDecompress	jCreaDecompress
+#define jpeg_destroy_compress	jDestCompress
+#define jpeg_destroy_decompress	jDestDecompress
+#define jpeg_stdio_dest		jStdDest
+#define jpeg_stdio_src		jStdSrc
+#define jpeg_set_defaults	jSetDefaults
+#define jpeg_set_colorspace	jSetColorspace
+#define jpeg_default_colorspace	jDefColorspace
+#define jpeg_set_quality	jSetQuality
+#define jpeg_set_linear_quality	jSetLQuality
+#define jpeg_add_quant_table	jAddQuantTable
+#define jpeg_quality_scaling	jQualityScaling
+#define jpeg_simple_progression	jSimProgress
+#define jpeg_suppress_tables	jSuppressTables
+#define jpeg_alloc_quant_table	jAlcQTable
+#define jpeg_alloc_huff_table	jAlcHTable
+#define jpeg_start_compress	jStrtCompress
+#define jpeg_write_scanlines	jWrtScanlines
+#define jpeg_finish_compress	jFinCompress
+#define jpeg_write_raw_data	jWrtRawData
+#define jpeg_write_marker	jWrtMarker
+#define jpeg_write_m_header	jWrtMHeader
+#define jpeg_write_m_byte	jWrtMByte
+#define jpeg_write_tables	jWrtTables
+#define jpeg_read_header	jReadHeader
+#define jpeg_start_decompress	jStrtDecompress
+#define jpeg_read_scanlines	jReadScanlines
+#define jpeg_finish_decompress	jFinDecompress
+#define jpeg_read_raw_data	jReadRawData
+#define jpeg_has_multiple_scans	jHasMultScn
+#define jpeg_start_output	jStrtOutput
+#define jpeg_finish_output	jFinOutput
+#define jpeg_input_complete	jInComplete
+#define jpeg_new_colormap	jNewCMap
+#define jpeg_consume_input	jConsumeInput
+#define jpeg_calc_output_dimensions	jCalcDimensions
+#define jpeg_save_markers	jSaveMarkers
+#define jpeg_set_marker_processor	jSetMarker
+#define jpeg_read_coefficients	jReadCoefs
+#define jpeg_write_coefficients	jWrtCoefs
+#define jpeg_copy_critical_parameters	jCopyCrit
+#define jpeg_abort_compress	jAbrtCompress
+#define jpeg_abort_decompress	jAbrtDecompress
+#define jpeg_abort		jAbort
+#define jpeg_destroy		jDestroy
+#define jpeg_resync_to_restart	jResyncRestart
+#endif /* NEED_SHORT_EXTERNAL_NAMES */
+
+
+/* Default error-management setup */
+EXTERN(struct jpeg_error_mgr *) jpeg_std_error
+	JPP((struct jpeg_error_mgr * err));
+
+/* Initialization of JPEG compression objects.
+ * jpeg_create_compress() and jpeg_create_decompress() are the exported
+ * names that applications should call.  These expand to calls on
+ * jpeg_CreateCompress and jpeg_CreateDecompress with additional information
+ * passed for version mismatch checking.
+ * NB: you must set up the error-manager BEFORE calling jpeg_create_xxx.
+ */
+#define jpeg_create_compress(cinfo) \
+    jpeg_CreateCompress((cinfo), JPEG_LIB_VERSION, \
+			(size_t) sizeof(struct jpeg_compress_struct))
+#define jpeg_create_decompress(cinfo) \
+    jpeg_CreateDecompress((cinfo), JPEG_LIB_VERSION, \
+			  (size_t) sizeof(struct jpeg_decompress_struct))
+EXTERN(void) jpeg_CreateCompress JPP((j_compress_ptr cinfo,
+				      int version, size_t structsize));
+EXTERN(void) jpeg_CreateDecompress JPP((j_decompress_ptr cinfo,
+					int version, size_t structsize));
+/* Destruction of JPEG compression objects */
+EXTERN(void) jpeg_destroy_compress JPP((j_compress_ptr cinfo));
+EXTERN(void) jpeg_destroy_decompress JPP((j_decompress_ptr cinfo));
+
+/* Standard data source and destination managers: stdio streams. */
+/* Caller is responsible for opening the file before and closing after. */
+EXTERN(void) jpeg_stdio_dest JPP((j_compress_ptr cinfo, FILE * outfile));
+EXTERN(void) jpeg_stdio_src JPP((j_decompress_ptr cinfo, FILE * infile));
+
+/* Default parameter setup for compression */
+EXTERN(void) jpeg_set_defaults JPP((j_compress_ptr cinfo));
+/* Compression parameter setup aids */
+EXTERN(void) jpeg_set_colorspace JPP((j_compress_ptr cinfo,
+				      J_COLOR_SPACE colorspace));
+EXTERN(void) jpeg_default_colorspace JPP((j_compress_ptr cinfo));
+EXTERN(void) jpeg_set_quality JPP((j_compress_ptr cinfo, int quality,
+				   boolean force_baseline));
+EXTERN(void) jpeg_set_linear_quality JPP((j_compress_ptr cinfo,
+					  int scale_factor,
+					  boolean force_baseline));
+EXTERN(void) jpeg_add_quant_table JPP((j_compress_ptr cinfo, int which_tbl,
+				       const unsigned int *basic_table,
+				       int scale_factor,
+				       boolean force_baseline));
+EXTERN(int) jpeg_quality_scaling JPP((int quality));
+EXTERN(void) jpeg_simple_progression JPP((j_compress_ptr cinfo));
+EXTERN(void) jpeg_suppress_tables JPP((j_compress_ptr cinfo,
+				       boolean suppress));
+EXTERN(JQUANT_TBL *) jpeg_alloc_quant_table JPP((j_common_ptr cinfo));
+EXTERN(JHUFF_TBL *) jpeg_alloc_huff_table JPP((j_common_ptr cinfo));
+
+/* Main entry points for compression */
+EXTERN(void) jpeg_start_compress JPP((j_compress_ptr cinfo,
+				      boolean write_all_tables));
+EXTERN(JDIMENSION) jpeg_write_scanlines JPP((j_compress_ptr cinfo,
+					     JSAMPARRAY scanlines,
+					     JDIMENSION num_lines));
+EXTERN(void) jpeg_finish_compress JPP((j_compress_ptr cinfo));
+
+/* Replaces jpeg_write_scanlines when writing raw downsampled data. */
+EXTERN(JDIMENSION) jpeg_write_raw_data JPP((j_compress_ptr cinfo,
+					    JSAMPIMAGE data,
+					    JDIMENSION num_lines));
+
+/* Write a special marker.  See libjpeg.doc concerning safe usage. */
+EXTERN(void) jpeg_write_marker
+	JPP((j_compress_ptr cinfo, int marker,
+	     const JOCTET * dataptr, unsigned int datalen));
+/* Same, but piecemeal. */
+EXTERN(void) jpeg_write_m_header
+	JPP((j_compress_ptr cinfo, int marker, unsigned int datalen));
+EXTERN(void) jpeg_write_m_byte
+	JPP((j_compress_ptr cinfo, int val));
+
+/* Alternate compression function: just write an abbreviated table file */
+EXTERN(void) jpeg_write_tables JPP((j_compress_ptr cinfo));
+
+/* Decompression startup: read start of JPEG datastream to see what's there */
+EXTERN(int) jpeg_read_header JPP((j_decompress_ptr cinfo,
+				  boolean require_image));
+/* Return value is one of: */
+#define JPEG_SUSPENDED		0 /* Suspended due to lack of input data */
+#define JPEG_HEADER_OK		1 /* Found valid image datastream */
+#define JPEG_HEADER_TABLES_ONLY	2 /* Found valid table-specs-only datastream */
+/* If you pass require_image = TRUE (normal case), you need not check for
+ * a TABLES_ONLY return code; an abbreviated file will cause an error exit.
+ * JPEG_SUSPENDED is only possible if you use a data source module that can
+ * give a suspension return (the stdio source module doesn't).
+ */
+
+/* Main entry points for decompression */
+EXTERN(boolean) jpeg_start_decompress JPP((j_decompress_ptr cinfo));
+EXTERN(JDIMENSION) jpeg_read_scanlines JPP((j_decompress_ptr cinfo,
+					    JSAMPARRAY scanlines,
+					    JDIMENSION max_lines));
+EXTERN(boolean) jpeg_finish_decompress JPP((j_decompress_ptr cinfo));
+
+/* Replaces jpeg_read_scanlines when reading raw downsampled data. */
+EXTERN(JDIMENSION) jpeg_read_raw_data JPP((j_decompress_ptr cinfo,
+					   JSAMPIMAGE data,
+					   JDIMENSION max_lines));
+
+/* Additional entry points for buffered-image mode. */
+EXTERN(boolean) jpeg_has_multiple_scans JPP((j_decompress_ptr cinfo));
+EXTERN(boolean) jpeg_start_output JPP((j_decompress_ptr cinfo,
+				       int scan_number));
+EXTERN(boolean) jpeg_finish_output JPP((j_decompress_ptr cinfo));
+EXTERN(boolean) jpeg_input_complete JPP((j_decompress_ptr cinfo));
+EXTERN(void) jpeg_new_colormap JPP((j_decompress_ptr cinfo));
+EXTERN(int) jpeg_consume_input JPP((j_decompress_ptr cinfo));
+/* Return value is one of: */
+/* #define JPEG_SUSPENDED	0    Suspended due to lack of input data */
+#define JPEG_REACHED_SOS	1 /* Reached start of new scan */
+#define JPEG_REACHED_EOI	2 /* Reached end of image */
+#define JPEG_ROW_COMPLETED	3 /* Completed one iMCU row */
+#define JPEG_SCAN_COMPLETED	4 /* Completed last iMCU row of a scan */
+
+/* Precalculate output dimensions for current decompression parameters. */
+EXTERN(void) jpeg_calc_output_dimensions JPP((j_decompress_ptr cinfo));
+
+/* Control saving of COM and APPn markers into marker_list. */
+EXTERN(void) jpeg_save_markers
+	JPP((j_decompress_ptr cinfo, int marker_code,
+	     unsigned int length_limit));
+
+/* Install a special processing method for COM or APPn markers. */
+EXTERN(void) jpeg_set_marker_processor
+	JPP((j_decompress_ptr cinfo, int marker_code,
+	     jpeg_marker_parser_method routine));
+
+/* Read or write raw DCT coefficients --- useful for lossless transcoding. */
+EXTERN(jvirt_barray_ptr *) jpeg_read_coefficients JPP((j_decompress_ptr cinfo));
+EXTERN(void) jpeg_write_coefficients JPP((j_compress_ptr cinfo,
+					  jvirt_barray_ptr * coef_arrays));
+EXTERN(void) jpeg_copy_critical_parameters JPP((j_decompress_ptr srcinfo,
+						j_compress_ptr dstinfo));
+
+/* If you choose to abort compression or decompression before completing
+ * jpeg_finish_(de)compress, then you need to clean up to release memory,
+ * temporary files, etc.  You can just call jpeg_destroy_(de)compress
+ * if you're done with the JPEG object, but if you want to clean it up and
+ * reuse it, call this:
+ */
+EXTERN(void) jpeg_abort_compress JPP((j_compress_ptr cinfo));
+EXTERN(void) jpeg_abort_decompress JPP((j_decompress_ptr cinfo));
+
+/* Generic versions of jpeg_abort and jpeg_destroy that work on either
+ * flavor of JPEG object.  These may be more convenient in some places.
+ */
+EXTERN(void) jpeg_abort JPP((j_common_ptr cinfo));
+EXTERN(void) jpeg_destroy JPP((j_common_ptr cinfo));
+
+/* Default restart-marker-resync procedure for use by data source modules */
+EXTERN(boolean) jpeg_resync_to_restart JPP((j_decompress_ptr cinfo,
+					    int desired));
+
+
+/* These marker codes are exported since applications and data source modules
+ * are likely to want to use them.
+ */
+
+#define JPEG_RST0	0xD0	/* RST0 marker code */
+#define JPEG_EOI	0xD9	/* EOI marker code */
+#define JPEG_APP0	0xE0	/* APP0 marker code */
+#define JPEG_COM	0xFE	/* COM marker code */
+
+
+/* If we have a brain-damaged compiler that emits warnings (or worse, errors)
+ * for structure definitions that are never filled in, keep it quiet by
+ * supplying dummy definitions for the various substructures.
+ */
+
+#ifdef INCOMPLETE_TYPES_BROKEN
+#ifndef JPEG_INTERNALS		/* will be defined in jpegint.h */
+struct jvirt_sarray_control { long dummy; };
+struct jvirt_barray_control { long dummy; };
+struct jpeg_comp_master { long dummy; };
+struct jpeg_c_main_controller { long dummy; };
+struct jpeg_c_prep_controller { long dummy; };
+struct jpeg_c_coef_controller { long dummy; };
+struct jpeg_marker_writer { long dummy; };
+struct jpeg_color_converter { long dummy; };
+struct jpeg_downsampler { long dummy; };
+struct jpeg_forward_dct { long dummy; };
+struct jpeg_entropy_encoder { long dummy; };
+struct jpeg_decomp_master { long dummy; };
+struct jpeg_d_main_controller { long dummy; };
+struct jpeg_d_coef_controller { long dummy; };
+struct jpeg_d_post_controller { long dummy; };
+struct jpeg_input_controller { long dummy; };
+struct jpeg_marker_reader { long dummy; };
+struct jpeg_entropy_decoder { long dummy; };
+struct jpeg_inverse_dct { long dummy; };
+struct jpeg_upsampler { long dummy; };
+struct jpeg_color_deconverter { long dummy; };
+struct jpeg_color_quantizer { long dummy; };
+#endif /* JPEG_INTERNALS */
+#endif /* INCOMPLETE_TYPES_BROKEN */
+
+
+/*
+ * The JPEG library modules define JPEG_INTERNALS before including this file.
+ * The internal structure declarations are read only when that is true.
+ * Applications using the library should not include jpegint.h, but may wish
+ * to include jerror.h.
+ */
+
+#ifdef JPEG_INTERNALS
+#include "jpegint.h"		/* fetch private declarations */
+#include "jerror.h"		/* fetch error codes too */
+#endif
+
+#endif /* JPEGLIB_H */
diff --git a/lib/a2jpeg-6b/jpegtools.c b/lib/a2jpeg-6b/jpegtools.c
new file mode 100644
index 0000000..91854d8
--- /dev/null
+++ b/lib/a2jpeg-6b/jpegtools.c
@@ -0,0 +1,621 @@
+/*
+ * jpegtran.c
+ *
+ * Copyright (C) 1995-1997, Thomas G. Lane.
+ * This file is part of the Independent JPEG Group's software.
+ * For conditions of distribution and use, see the accompanying README file.
+ * 
+ * plenty of changes by Gerd Hoffmann <kraxel@bytesex.org>, with focus on
+ * digital image processing and sane exif handling:
+ *
+ *   - does transformations only (flip/rotate/transpose/transverse).
+ *   - also transforms the exif thumbnail if present.
+ *   - can automatically figure transformation from the
+ *     exif orientation tag.
+ *   - updates the exif orientation tag.
+ *   - updates the exif pixel dimension tags.
+ *
+ * This file contains a command-line user interface for JPEG transcoding.
+ * It is very similar to cjpeg.c, but provides lossless transcoding between
+ * different JPEG file formats.  It also provides some lossless and sort-of-
+ * lossless transformations of JPEG data.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stddef.h>
+#include <unistd.h>
+#include <errno.h>
+#include <string.h>
+#include <utime.h>
+#include <setjmp.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+
+#include <jpeglib.h>
+//#include "a2jpeg/transupp.h"		/* Support routines for jpegtran */
+#include "jpegtools.h"
+
+#include "misc.h"
+
+#include <libexif/exif-data.h>
+#include <libexif/exif-utils.h>
+#include <libexif/exif-ifd.h>
+#include <libexif/exif-tag.h>
+
+static int do_transform(struct jpeg_decompress_struct *src,
+			struct jpeg_compress_struct   *dst,
+			JXFORM_CODE transform,
+			unsigned char *comment,
+			char *thumbnail, int tsize,
+			unsigned int flags);
+
+static JXFORM_CODE transmagic[] = {
+    [ 1 ] = JXFORM_NONE,
+    [ 2 ] = JXFORM_FLIP_H,
+    [ 3 ] = JXFORM_ROT_180,
+    [ 4 ] = JXFORM_FLIP_V,
+    [ 5 ] = JXFORM_TRANSPOSE,
+    [ 6 ] = JXFORM_ROT_90,
+    [ 7 ] = JXFORM_TRANSVERSE,
+    [ 8 ] = JXFORM_ROT_270,
+};
+
+#if 0
+static char *transname[] = {
+    [ JXFORM_NONE ]       = "none",
+    [ JXFORM_FLIP_H ]     = "flip h",
+    [ JXFORM_FLIP_V ]     = "flip v",
+    [ JXFORM_TRANSPOSE ]  = "transpose",
+    [ JXFORM_TRANSVERSE ] = "transverse",
+    [ JXFORM_ROT_90 ]     = "rot 90",
+    [ JXFORM_ROT_180 ]    = "rot 190",
+    [ JXFORM_ROT_270 ]    = "rot 270",
+};
+#endif
+
+/* ---------------------------------------------------------------------- */
+
+/* libjpeg error handler -- exit via longjump */
+struct longjmp_error_mgr {
+    struct jpeg_error_mgr jpeg;
+    jmp_buf setjmp_buffer;
+};
+
+static void longjmp_error_exit(j_common_ptr cinfo)
+{
+    struct longjmp_error_mgr *h = (struct longjmp_error_mgr*)cinfo->err;
+    (*cinfo->err->output_message)(cinfo);
+    longjmp(h->setjmp_buffer, 1);
+}
+
+/* ---------------------------------------------------------------------- */
+
+static long get_int(ExifData *ed, ExifEntry *ee)
+{
+    ExifByteOrder o = exif_data_get_byte_order(ed);
+    long value;
+    
+    switch (ee->format) {
+    case EXIF_FORMAT_SHORT:
+	value = exif_get_short (ee->data, o);
+	break;
+    case EXIF_FORMAT_LONG:
+	value = exif_get_long (ee->data, o);
+	break;
+    case EXIF_FORMAT_SLONG:
+	value = exif_get_slong (ee->data, o);
+	break;
+    default:
+	fprintf(stderr,"get_int oops\n");
+	exit(1);
+    }
+    return value;
+}
+
+static void set_int(ExifData *ed, ExifEntry *ee, long value)
+{
+    ExifByteOrder o = exif_data_get_byte_order(ed);
+
+    switch (ee->format) {
+    case EXIF_FORMAT_SHORT:
+	exif_set_short (ee->data, o, value);
+	break;
+    case EXIF_FORMAT_LONG:
+	exif_set_long (ee->data, o, value);
+	break;
+    case EXIF_FORMAT_SLONG:
+	exif_set_slong (ee->data, o, value);
+	break;
+    default:
+	fprintf(stderr,"set_int oops\n");
+	exit(1);
+    }
+}
+
+static void update_orientation(ExifData *ed, int ifd, int orientation)
+{
+    ExifEntry *ee;
+
+    ee = exif_content_get_entry(ed->ifd[ifd], 0x0112);
+    if (NULL == ee)
+	return;
+    set_int(ed,ee,orientation);
+}
+
+static void update_dimension(ExifData *ed, JXFORM_CODE transform,
+			     int src_x, int src_y)
+{
+    static struct {
+	int idf;
+	int tag;
+	int x;
+    } fields[] = {
+	{
+	    .idf = EXIF_IFD_EXIF,
+	    .tag = EXIF_TAG_PIXEL_X_DIMENSION,
+	    .x   = 1,
+	},{
+	    .idf = EXIF_IFD_EXIF,
+	    .tag = EXIF_TAG_PIXEL_Y_DIMENSION,
+	    .x   = 0,
+	},{
+	    .idf = EXIF_IFD_INTEROPERABILITY,
+	    .tag = EXIF_TAG_RELATED_IMAGE_WIDTH,
+	    .x   = 1,
+	},{
+	    .idf = EXIF_IFD_INTEROPERABILITY,
+	    .tag = EXIF_TAG_RELATED_IMAGE_LENGTH,
+	    .x   = 0,
+	}
+    };
+    ExifEntry *ee;
+    int i;
+
+    for (i = 0; i < sizeof(fields)/sizeof(fields[0]); i++) {
+	ee = exif_content_get_entry(ed->ifd[fields[i].idf], fields[i].tag);
+	if (!ee)
+	    continue;
+	switch (transform) {
+	case JXFORM_ROT_90:
+	case JXFORM_ROT_270:
+	case JXFORM_TRANSPOSE:
+	case JXFORM_TRANSVERSE:
+	    /* x/y reversed */
+	    set_int(ed, ee, fields[i].x ? src_y : src_x);
+	    break;
+	default:
+	    /* normal */
+	    set_int(ed, ee, fields[i].x ? src_x : src_y);
+	    break;
+	}
+    }
+}
+
+int get_orientation(ExifData *ed)
+{
+    ExifEntry *ee;
+
+    ee = exif_content_get_entry(ed->ifd[EXIF_IFD_0], 0x0112);
+    if (NULL == ee)
+	return 1; /* top - left */
+    return get_int(ed,ee);
+}
+
+/* ---------------------------------------------------------------------- */
+
+struct th {
+    struct jpeg_decompress_struct src;
+    struct jpeg_compress_struct   dst;
+    struct jpeg_error_mgr jsrcerr, jdsterr;
+    unsigned char *in;
+    unsigned char *out;
+    int isize, osize;
+};
+
+static void thumbnail_src_init(struct jpeg_decompress_struct *cinfo)
+{
+    struct th *h  = container_of(cinfo, struct th, src);
+    cinfo->src->next_input_byte = h->in;
+    cinfo->src->bytes_in_buffer = h->isize;
+}
+
+static int thumbnail_src_fill(struct jpeg_decompress_struct *cinfo)
+{
+    fprintf(stderr,"jpeg: panic: no more thumbnail input data\n");
+    exit(1);
+}
+
+static void thumbnail_src_skip(struct jpeg_decompress_struct *cinfo,
+			       long num_bytes)
+{
+    cinfo->src->next_input_byte += num_bytes;
+}
+
+static void thumbnail_src_term(struct jpeg_decompress_struct *cinfo)
+{
+    /* nothing */
+}
+
+static void thumbnail_dest_init(struct jpeg_compress_struct *cinfo)
+{
+    struct th *h  = container_of(cinfo, struct th, dst);
+    h->osize = h->isize * 2;
+    h->out   = malloc(h->osize);
+    cinfo->dest->next_output_byte = h->out;
+    cinfo->dest->free_in_buffer   = h->osize;
+}
+
+static boolean thumbnail_dest_flush(struct jpeg_compress_struct *cinfo)
+{
+    fprintf(stderr,"jpeg: panic: output buffer full\n");
+    exit(1);
+}
+
+static void thumbnail_dest_term(struct jpeg_compress_struct *cinfo)
+{
+    struct th *h  = container_of(cinfo, struct th, dst);
+    h->osize -= cinfo->dest->free_in_buffer;
+}
+
+static struct jpeg_source_mgr thumbnail_src = {
+    .init_source         = thumbnail_src_init,
+    .fill_input_buffer   = thumbnail_src_fill,
+    .skip_input_data     = thumbnail_src_skip,
+    .resync_to_restart   = jpeg_resync_to_restart,
+    .term_source         = thumbnail_src_term,
+};
+
+static struct jpeg_destination_mgr thumbnail_dst = {
+    .init_destination    = thumbnail_dest_init,
+    .empty_output_buffer = thumbnail_dest_flush,
+    .term_destination    = thumbnail_dest_term,
+};
+
+static void do_thumbnail(ExifData *ed, JXFORM_CODE transform)
+{
+    struct th th;
+
+    if (JXFORM_NONE == transform)
+	return;
+    
+    memset(&th,0,sizeof(th));
+    th.in    = ed->data;
+    th.isize = ed->size;
+    
+    /* setup src */
+    th.src.err = jpeg_std_error(&th.jsrcerr);
+    jpeg_create_decompress(&th.src);
+    th.src.src = &thumbnail_src;
+    
+    /* setup dst */
+    th.dst.err = jpeg_std_error(&th.jdsterr);
+    jpeg_create_compress(&th.dst);
+    th.dst.dest = &thumbnail_dst;
+
+    /* transform image */
+    do_transform(&th.src,&th.dst,transform,NULL,NULL,0,JFLAG_TRANSFORM_IMAGE);
+
+    /* cleanup */
+    jpeg_destroy_decompress(&th.src);
+    jpeg_destroy_compress(&th.dst);
+
+    /* replace thumbnail */
+    free(ed->data);
+    ed->data = th.out;
+    ed->size = th.osize;
+}
+
+static void do_exif(struct jpeg_decompress_struct *src,
+		    JXFORM_CODE *transform,
+		    char *thumbnail, int tsize,
+		    unsigned int flags)
+{
+    jpeg_saved_marker_ptr mark;
+    ExifData *ed = NULL;
+    unsigned char *data;
+    unsigned int  size;
+    
+    for (mark = src->marker_list; NULL != mark; mark = mark->next) {
+	if (mark->marker != JPEG_APP0 +1)
+	    continue;
+	ed = exif_data_new_from_data(mark->data,mark->data_length);
+	break;
+    }
+    if (flags & JFLAG_UPDATE_THUMBNAIL) {
+	if (NULL == ed)
+	    ed = exif_data_new();
+	if (NULL == mark) {
+	    mark = src->mem->alloc_large((j_common_ptr)src,JPOOL_IMAGE,sizeof(*mark));
+	    memset(mark,0,sizeof(*mark));
+	    mark->marker = JPEG_APP0 +1;
+	    mark->next = src->marker_list;
+	    src->marker_list = mark;
+	}
+	if (ed->data)
+	    free(ed->data);
+	ed->data = thumbnail;
+	ed->size = tsize;
+    }
+    if (NULL == ed)
+	return;
+
+    if (-1 == *transform) {
+	/* automagic image transformation */
+	int orientation = get_orientation(ed);
+	*transform = JXFORM_NONE;
+	if (orientation >= 1 && orientation <= 8)
+	    *transform = transmagic[orientation];
+#if 0
+	if (debug)
+	    fprintf(stderr,"autotrans: %s\n",transname[*transform]);
+#endif
+    }
+
+    /* update exif data */
+    if (flags & JFLAG_UPDATE_ORIENTATION) {
+	update_orientation(ed,EXIF_IFD_0,1);
+	update_orientation(ed,EXIF_IFD_1,1);
+    }
+    if (ed->data && ed->data[0] == 0xff && ed->data[1] == 0xd8 &&
+	(flags & JFLAG_TRANSFORM_THUMBNAIL))
+	do_thumbnail(ed,*transform);
+    update_dimension(ed, (flags & JFLAG_TRANSFORM_IMAGE) ? *transform : JXFORM_NONE,
+		     src->image_width, src->image_height);
+
+    /* build new exif data block */
+    exif_data_save_data(ed,&data,&size);
+    exif_data_unref(ed);
+
+    /* update jpeg APP1 (EXIF) marker */
+    mark->data = src->mem->alloc_large((j_common_ptr)src,JPOOL_IMAGE,size);
+    mark->original_length = size;
+    mark->data_length = size;
+    memcpy(mark->data,data,size);
+    free(data);
+}
+
+/* ---------------------------------------------------------------------- */
+
+static void do_comment(struct jpeg_decompress_struct *src,
+		       unsigned char *comment)
+{
+    jpeg_saved_marker_ptr mark;
+    int size;
+
+    /* find or create comment marker */
+    for (mark = src->marker_list;; mark = mark->next) {
+	if (mark->marker == JPEG_COM)
+	    break;
+	if (NULL == mark->next) {
+	    mark->next = src->mem->alloc_large((j_common_ptr)src,JPOOL_IMAGE,
+					       sizeof(*mark));
+	    mark = mark->next;
+	    memset(mark,0,sizeof(*mark));
+	    mark->marker = JPEG_COM;
+	    break;
+	}
+    }
+
+    /* update comment marker */
+    size = strlen(comment) +1;
+    mark->data = src->mem->alloc_large((j_common_ptr)src,JPOOL_IMAGE,size);
+    mark->original_length = size;
+    mark->data_length = size;
+    memcpy(mark->data,comment,size);
+}
+
+static int do_transform(struct jpeg_decompress_struct *src,
+			struct jpeg_compress_struct *dst,
+			JXFORM_CODE transform,
+			unsigned char *comment,
+			char *thumbnail, int tsize,
+			unsigned int flags)
+{
+    jvirt_barray_ptr * src_coef_arrays;
+    jvirt_barray_ptr * dst_coef_arrays;
+    jpeg_transform_info transformoption;
+
+    jcopy_markers_setup(src, JCOPYOPT_ALL);
+    if (JPEG_HEADER_OK != jpeg_read_header(src, TRUE))
+	return -1;
+
+    do_exif(src,&transform,thumbnail,tsize,flags);
+    if (-1 == transform)
+	transform = JXFORM_NONE;
+    if (!(flags & JFLAG_TRANSFORM_IMAGE))
+	transform = JXFORM_NONE;
+    if ((flags & JFLAG_UPDATE_COMMENT) && NULL != comment)
+	do_comment(src,comment);
+
+    memset(&transformoption,0,sizeof(transformoption));
+    transformoption.transform = transform;
+    transformoption.trim      = FALSE;
+    transformoption.force_grayscale = FALSE;
+
+    /* Any space needed by a transform option must be requested before
+     * jpeg_read_coefficients so that memory allocation will be done right.
+     */
+    jtransform_request_workspace(src, &transformoption);
+    src_coef_arrays = jpeg_read_coefficients(src);
+    jpeg_copy_critical_parameters(src, dst);
+    dst_coef_arrays = jtransform_adjust_parameters
+	(src, dst, src_coef_arrays, &transformoption);
+    
+    /* Start compressor (note no image data is actually written here) */
+    jpeg_write_coefficients(dst, dst_coef_arrays);
+    
+    /* Copy to the output file any extra markers that we want to preserve */
+    jcopy_markers_execute(src, dst, JCOPYOPT_ALL);
+    
+    /* Execute image transformation, if any */
+    jtransform_execute_transformation(src, dst,
+				      src_coef_arrays,
+				      &transformoption);
+    
+    /* Finish compression and release memory */
+    jpeg_finish_compress(dst);
+    jpeg_finish_decompress(src);
+
+    return 0;
+}
+
+/* ---------------------------------------------------------------------- */
+
+int jpeg_transform_fp(FILE *in, FILE *out,
+		      JXFORM_CODE transform,
+		      unsigned char *comment,
+		      char *thumbnail, int tsize,
+		      unsigned int flags)
+{
+    struct jpeg_decompress_struct src;
+    struct jpeg_compress_struct   dst;
+    struct jpeg_error_mgr jdsterr;
+    struct longjmp_error_mgr jsrcerr;
+    
+    /* setup src */
+    src.err = jpeg_std_error(&jsrcerr.jpeg);
+    jsrcerr.jpeg.error_exit = longjmp_error_exit;
+    if (setjmp(jsrcerr.setjmp_buffer))
+	/* something went wrong within the jpeg library ... */
+	goto oops;
+    jpeg_create_decompress(&src);
+    jpeg_stdio_src(&src, in);
+    
+    /* setup dst */
+    dst.err = jpeg_std_error(&jdsterr);
+    jpeg_create_compress(&dst);
+    jpeg_stdio_dest(&dst, out);
+
+    /* transform image */
+    do_transform(&src,&dst,transform,comment,thumbnail,tsize,flags);
+
+    /* cleanup */
+    jpeg_destroy_decompress(&src);
+    jpeg_destroy_compress(&dst);
+    return 0;
+
+ oops:
+    jpeg_destroy_decompress(&src);
+    jpeg_destroy_compress(&dst);
+    return -1;
+}
+
+int jpeg_transform_files(char *infile, char *outfile,
+			 JXFORM_CODE transform,
+			 unsigned char *comment,
+			 char *thumbnail, int tsize,
+			 unsigned int flags)
+{
+    int rc;
+    FILE *in;
+    FILE *out;
+    
+    /* open infile */
+    in = fopen(infile,"r");
+    if (NULL == in) {
+	fprintf(stderr,"open %s: %s\n",infile,strerror(errno));
+	return -1;
+    }
+    
+    /* open outfile */
+    out = fopen(outfile,"w");
+    if (NULL == out) {
+	fprintf(stderr,"open %s: %s\n",outfile,strerror(errno));
+	fclose(in);
+	return -1;
+    }
+
+    /* go! */
+    rc = jpeg_transform_fp(in,out,transform,comment,thumbnail,tsize,flags);
+    fclose(in);
+    fclose(out);
+
+    return rc;
+}
+
+int jpeg_transform_inplace(char *file,
+			   JXFORM_CODE transform,
+			   unsigned char *comment,
+			   char *thumbnail, int tsize,
+			   unsigned int flags)
+{
+    char *tmpfile;
+    char *bakfile;
+    struct stat st;
+    int fd;
+    FILE *in  = NULL;
+    FILE *out = NULL;
+
+    /* are we allowed to write to the file? */
+    if (0 != access(file,W_OK)) {
+	fprintf(stderr,"access %s: %s\n",file,strerror(errno));
+	return -1;
+    }
+
+    /* open infile */
+    in = fopen(file,"r");
+    if (NULL == in) {
+	fprintf(stderr,"open %s: %s\n",file,strerror(errno));
+	return -1;
+    }
+    
+    /* open tmpfile */
+    tmpfile = malloc(strlen(file)+10);
+    sprintf(tmpfile,"%s.XXXXXX",file);
+    fd = mkstemp(tmpfile);
+    if (-1 == fd) {
+	fprintf(stderr,"mkstemp(%s): %s\n",tmpfile,strerror(errno));
+	goto oops;
+    }
+    out = fdopen(fd,"w");
+
+    /* copy owner and permissions */
+    if (-1 == fstat(fileno(in),&st)) {
+	fprintf(stderr,"fstat(%s): %s\n",file,strerror(errno));
+	goto oops;
+    }
+    if (-1 == fchown(fileno(out),st.st_uid,st.st_gid)) {
+	fprintf(stderr,"fchown(%s): %s\n",tmpfile,strerror(errno));
+	goto oops;
+    }
+    if (-1 == fchmod(fileno(out),st.st_mode)) {
+	fprintf(stderr,"fchmod(%s): %s\n",tmpfile,strerror(errno));
+	goto oops;
+    }
+
+    /* transform */
+    if (0 != jpeg_transform_fp(in,out,transform,comment,thumbnail,tsize,flags))
+	goto oops;
+
+    /* worked ok -- commit */
+    fclose(in);
+    fclose(out);
+    if (flags & JFLAG_FILE_BACKUP) {
+	bakfile = malloc(strlen(file)+2);
+	sprintf(bakfile,"%s~",file);
+	rename(file,bakfile);
+	free(bakfile);
+    }
+    rename(tmpfile,file);
+    if (flags & JFLAG_FILE_KEEP_TIME) {
+	struct utimbuf u;
+	u.actime = st.st_atime;
+	u.modtime = st.st_mtime;
+	utime(file,&u);
+    }
+        
+    /* cleanup & return */
+    free(tmpfile);
+    return 0;
+
+ oops:
+    /* something went wrong -- rollback */
+    if (in)
+	fclose(in);
+    if (out) {
+	fclose(out);
+	unlink(tmpfile);
+    }
+    return -1;
+}
diff --git a/lib/a2jpeg-6b/jpegtools.h b/lib/a2jpeg-6b/jpegtools.h
new file mode 100644
index 0000000..875b66b
--- /dev/null
+++ b/lib/a2jpeg-6b/jpegtools.h
@@ -0,0 +1,33 @@
+
+/* various flags */
+#define JFLAG_TRANSFORM_IMAGE      0x0001
+#define JFLAG_TRANSFORM_THUMBNAIL  0x0002
+
+#define JFLAG_UPDATE_COMMENT       0x0010
+#define JFLAG_UPDATE_ORIENTATION   0x0020
+#define JFLAG_UPDATE_THUMBNAIL     0x0040
+
+#define JFLAG_FILE_BACKUP          0x0100
+#define JFLAG_FILE_KEEP_TIME       0x0200
+
+#include "transupp.h"
+#include "exif-data.h"
+
+/* functions */
+int jpeg_transform_fp(FILE *in, FILE *out,
+		      JXFORM_CODE transform,
+		      unsigned char *comment,
+		      char *thumbnail, int tsize,
+		      unsigned int flags);
+int jpeg_transform_files(char *infile, char *outfile,
+			 JXFORM_CODE transform,
+			 unsigned char *comment,
+			 char *thumbnail, int tsize,
+			 unsigned int flags);
+int jpeg_transform_inplace(char *file,
+			   JXFORM_CODE transform,
+			   unsigned char *comment,
+			   char *thumbnail, int tsize,
+			   unsigned int flags);
+
+int get_orientation(ExifData *ed);
diff --git a/lib/a2jpeg-6b/list.h b/lib/a2jpeg-6b/list.h
new file mode 100644
index 0000000..614d34b
--- /dev/null
+++ b/lib/a2jpeg-6b/list.h
@@ -0,0 +1,168 @@
+#ifndef _LIST_H_
+#define _LIST_H_
+/*
+ * Simple doubly linked list implementation.
+ *	-- shameless stolen from the linux kernel sources
+ *
+ * Some of the internal functions ("__xxx") are useful when
+ * manipulating whole lists rather than single entries, as
+ * sometimes we already know the next/prev entries and we can
+ * generate better code by using them directly rather than
+ * using the generic single-entry routines.
+ */
+
+struct list_head {
+	struct list_head *next, *prev;
+};
+
+#define LIST_HEAD_INIT(name) { &(name), &(name) }
+
+#define LIST_HEAD(name) \
+	struct list_head name = LIST_HEAD_INIT(name)
+
+#define INIT_LIST_HEAD(ptr) do { \
+	(ptr)->next = (ptr); (ptr)->prev = (ptr); \
+} while (0)
+
+/*
+ * Insert a new entry between two known consecutive entries. 
+ *
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ */
+static __inline__ void __list_add(struct list_head * new,
+	struct list_head * prev,
+	struct list_head * next)
+{
+	next->prev = new;
+	new->next = next;
+	new->prev = prev;
+	prev->next = new;
+}
+
+/**
+ * list_add - add a new entry
+ * @new: new entry to be added
+ * @head: list head to add it after
+ *
+ * Insert a new entry after the specified head.
+ * This is good for implementing stacks.
+ */
+static __inline__ void list_add(struct list_head *new, struct list_head *head)
+{
+	__list_add(new, head, head->next);
+}
+
+/**
+ * list_add_tail - add a new entry
+ * @new: new entry to be added
+ * @head: list head to add it before
+ *
+ * Insert a new entry before the specified head.
+ * This is useful for implementing queues.
+ */
+static __inline__ void list_add_tail(struct list_head *new, struct list_head *head)
+{
+	__list_add(new, head->prev, head);
+}
+
+/*
+ * Delete a list entry by making the prev/next entries
+ * point to each other.
+ *
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ */
+static __inline__ void __list_del(struct list_head * prev,
+				  struct list_head * next)
+{
+	next->prev = prev;
+	prev->next = next;
+}
+
+/**
+ * list_del - deletes entry from list.
+ * @entry: the element to delete from the list.
+ * Note: list_empty on entry does not return true after this, the entry is in an undefined state.
+ */
+static __inline__ void list_del(struct list_head *entry)
+{
+	__list_del(entry->prev, entry->next);
+}
+
+/**
+ * list_del_init - deletes entry from list and reinitialize it.
+ * @entry: the element to delete from the list.
+ */
+static __inline__ void list_del_init(struct list_head *entry)
+{
+	__list_del(entry->prev, entry->next);
+	INIT_LIST_HEAD(entry); 
+}
+
+/**
+ * list_empty - tests whether a list is empty
+ * @head: the list to test.
+ */
+static __inline__ int list_empty(struct list_head *head)
+{
+	return head->next == head;
+}
+
+/**
+ * list_splice - join two lists
+ * @list: the new list to add.
+ * @head: the place to add it in the first list.
+ */
+static __inline__ void list_splice(struct list_head *list, struct list_head *head)
+{
+	struct list_head *first = list->next;
+
+	if (first != list) {
+		struct list_head *last = list->prev;
+		struct list_head *at = head->next;
+
+		first->prev = head;
+		head->next = first;
+
+		last->next = at;
+		at->prev = last;
+	}
+}
+
+/**
+ * list_entry - get the struct for this entry
+ * @ptr:	the &struct list_head pointer.
+ * @type:	the type of the struct this is embedded in.
+ * @member:	the name of the list_struct within the struct.
+ */
+#define list_entry(ptr, type, member) \
+	((type *)((char *)(ptr)-(unsigned long)(&((type *)0)->member)))
+
+/**
+ * list_for_each	-	iterate over a list
+ * @pos:	the &struct list_head to use as a loop counter.
+ * @head:	the head for your list.
+ */
+#define list_for_each(pos, head) \
+	for (pos = (head)->next; pos != (head); pos = pos->next)
+        	
+/**
+ * list_for_each_safe	-	iterate over a list safe against removal of list entry
+ * @pos:	the &struct list_head to use as a loop counter.
+ * @n:		another &struct list_head to use as temporary storage
+ * @head:	the head for your list.
+ */
+#define list_for_each_safe(pos, n, head) \
+	for (pos = (head)->next, n = pos->next; pos != (head); \
+		pos = n, n = pos->next)
+
+/**
+ * list_for_each_prev	-	iterate over a list in reverse order
+ * @pos:	the &struct list_head to use as a loop counter.
+ * @head:	the head for your list.
+ */
+#define list_for_each_prev(pos, head) \
+	for (pos = (head)->prev; pos != (head); pos = pos->prev)
+
+#endif /* _LIST_H_ */
diff --git a/lib/a2jpeg-6b/misc.h b/lib/a2jpeg-6b/misc.h
new file mode 100644
index 0000000..92a66bc
--- /dev/null
+++ b/lib/a2jpeg-6b/misc.h
@@ -0,0 +1,9 @@
+/*
+ * misc useful #defines ...
+ */
+
+#define container_of(ptr, type, member) ({			\
+        const typeof( ((type *)0)->member ) *__mptr = (ptr);	\
+        (type *)( (char *)__mptr - offsetof(type,member) );})
+
+#define array_size(x) (sizeof(x)/sizeof(x[0]))
diff --git a/lib/a2jpeg-6b/op.c b/lib/a2jpeg-6b/op.c
new file mode 100644
index 0000000..b4e95fe
--- /dev/null
+++ b/lib/a2jpeg-6b/op.c
@@ -0,0 +1,289 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "readers.h"
+#include "op.h"
+#include "filter.h"
+
+/* ----------------------------------------------------------------------- */
+/* functions                                                               */
+
+static char op_none_data;
+
+static void
+op_flip_vert(struct ida_image *src, struct ida_rect *rect,
+	     unsigned char *dst, int line, void *data)
+{
+    char *scanline;
+
+    scanline = src->data + (src->i.height - line - 1) * src->i.width * 3;
+    memcpy(dst,scanline,src->i.width*3);
+}
+
+static void
+op_flip_horz(struct ida_image *src, struct ida_rect *rect,
+	     unsigned char *dst, int line, void *data)
+{
+    char *scanline;
+    unsigned int i;
+
+    scanline = src->data + (line+1) * src->i.width * 3;
+    for (i = 0; i < src->i.width; i++) {
+	scanline -= 3;
+	dst[0] = scanline[0];
+	dst[1] = scanline[1];
+	dst[2] = scanline[2];
+	dst += 3;
+    }
+}
+
+static void*
+op_rotate_init(struct ida_image *src, struct ida_rect *rect,
+	       struct ida_image_info *i, void *parm)
+{
+    *i = src->i;
+    i->height = src->i.width;
+    i->width  = src->i.height;
+    i->dpi    = src->i.dpi;
+    return &op_none_data;
+}
+
+static void
+op_rotate_cw(struct ida_image *src, struct ida_rect *rect,
+	     unsigned char *dst, int line, void *data)
+{
+    char *pix;
+    unsigned int i;
+
+    pix = src->data + src->i.width * src->i.height * 3 + line * 3;
+    for (i = 0; i < src->i.height; i++) {
+	pix -= src->i.width * 3;
+	dst[0] = pix[0];
+	dst[1] = pix[1];
+	dst[2] = pix[2];
+	dst += 3;
+    }
+}
+
+static void
+op_rotate_ccw(struct ida_image *src, struct ida_rect *rect,
+	      unsigned char *dst, int line, void *data)
+{
+    char *pix;
+    unsigned int i;
+
+    pix = src->data + (src->i.width-line-1) * 3;
+    for (i = 0; i < src->i.height; i++) {
+	dst[0] = pix[0];
+	dst[1] = pix[1];
+	dst[2] = pix[2];
+	pix += src->i.width * 3;
+	dst += 3;
+    }
+}
+
+static void
+op_invert(struct ida_image *src, struct ida_rect *rect,
+	  unsigned char *dst, int line, void *data)
+{
+    unsigned char *scanline;
+    int i;
+
+    scanline = src->data + line * src->i.width * 3;
+    memcpy(dst,scanline,src->i.width * 3);
+    if (line < rect->y1 || line >= rect->y2)
+	return;
+    dst      += 3*rect->x1;
+    scanline += 3*rect->x1;
+    for (i = rect->x1; i < rect->x2; i++) {
+	dst[0] = 255-scanline[0];
+	dst[1] = 255-scanline[1];
+	dst[2] = 255-scanline[2];
+	scanline += 3;
+	dst += 3;
+    }
+}
+
+static void*
+op_crop_init(struct ida_image *src, struct ida_rect *rect,
+	     struct ida_image_info *i, void *parm)
+{
+    if (rect->x2 - rect->x1 == src->i.width &&
+	rect->y2 - rect->y1 == src->i.height)
+	return NULL;
+    *i = src->i;
+    i->width  = rect->x2 - rect->x1;
+    i->height = rect->y2 - rect->y1;
+    return &op_none_data;
+}
+
+static void
+op_crop_work(struct ida_image *src, struct ida_rect *rect,
+	     unsigned char *dst, int line, void *data)
+{
+    unsigned char *scanline;
+    int i;
+
+    scanline = src->data + (line+rect->y1) * src->i.width * 3 + rect->x1 * 3;
+    for (i = rect->x1; i < rect->x2; i++) {
+	dst[0] = scanline[0];
+	dst[1] = scanline[1];
+	dst[2] = scanline[2];
+	scanline += 3;
+	dst += 3;
+    }
+}
+
+static void*
+op_autocrop_init(struct ida_image *src, struct ida_rect *unused,
+		 struct ida_image_info *i, void *parm)
+{
+    static struct op_3x3_parm filter = {
+	f1: { -1, -1, -1 },
+	f2: { -1,  8, -1 },
+	f3: { -1, -1, -1 },
+    };
+    struct ida_rect rect;
+    struct ida_image img;
+    int x,y,limit;
+    unsigned char *line;
+    void *data;
+    
+    /* detect edges */
+    rect.x1 = 0;
+    rect.x2 = src->i.width;
+    rect.y1 = 0;
+    rect.y2 = src->i.height;
+    data = desc_3x3.init(src, &rect, &img.i, &filter);
+
+    img.data   = malloc(img.i.width * img.i.height * 3);
+    for (y = 0; y < (int)img.i.height; y++)
+	desc_3x3.work(src, &rect, img.data+3*img.i.width*y, y, data);
+    desc_3x3.done(data);
+    limit = 64;
+
+    /* y border */
+    for (y = 0; y < (int)img.i.height; y++) {
+	line = img.data + img.i.width*y*3;
+	for (x = 0; x < (int)img.i.width; x++)
+	    if (line[3*x+0] > limit ||
+		line[3*x+1] > limit ||
+		line[3*x+2] > limit)
+		break;
+	if (x != (int)img.i.width)
+	    break;
+    }
+    rect.y1 = y;
+    for (y = (int)img.i.height-1; y > rect.y1; y--) {
+	line = img.data + img.i.width*y*3;
+	for (x = 0; x < (int)img.i.width; x++)
+	    if (line[3*x+0] > limit ||
+		line[3*x+1] > limit ||
+		line[3*x+2] > limit)
+		break;
+	if (x != (int)img.i.width)
+	    break;
+    }
+    rect.y2 = y+1;
+
+    /* x border */
+    for (x = 0; x < (int)img.i.width; x++) {
+	for (y = 0; y < (int)img.i.height; y++) {
+	    line = img.data + (img.i.width*y+x) * 3;
+	    if (line[0] > limit ||
+		line[1] > limit ||
+		line[2] > limit)
+		break;
+	}
+	if (y != (int)img.i.height)
+	    break;
+    }
+    rect.x1 = x;
+    for (x = (int)img.i.width-1; x > rect.x1; x--) {
+	for (y = 0; y < (int)img.i.height; y++) {
+	    line = img.data + (img.i.width*y+x) * 3;
+	    if (line[0] > limit ||
+		line[1] > limit ||
+		line[2] > limit)
+		break;
+	}
+	if (y != (int)img.i.height)
+	    break;
+    }
+    rect.x2 = x+1;
+
+    free(img.data);
+    if (debug)
+	fprintf(stderr,"y: %d-%d/%d  --  x: %d-%d/%d\n",
+		rect.y1, rect.y2, img.i.height,
+		rect.x1, rect.x2, img.i.width);
+
+    if (0 == rect.x2 - rect.x1  ||  0 == rect.y2 - rect.y1)
+	return NULL;
+    
+    *unused = rect;
+    *i = src->i;
+    i->width  = rect.x2 - rect.x1;
+    i->height = rect.y2 - rect.y1;
+    return &op_none_data;
+}
+
+/* ----------------------------------------------------------------------- */
+
+static char op_none_data;
+
+void* op_none_init(struct ida_image *src,  struct ida_rect *sel,
+		   struct ida_image_info *i, void *parm)
+{
+    *i = src->i;
+    return &op_none_data;
+}
+
+void  op_none_done(void *data) {}
+void  op_free_done(void *data) { free(data); }
+
+/* ----------------------------------------------------------------------- */
+
+struct ida_op desc_flip_vert = {
+    name:  "flip-vert",
+    init:  op_none_init,
+    work:  op_flip_vert,
+    done:  op_none_done,
+};
+struct ida_op desc_flip_horz = {
+    name:  "flip-horz",
+    init:  op_none_init,
+    work:  op_flip_horz,
+    done:  op_none_done,
+};
+struct ida_op desc_rotate_cw = {
+    name:  "rotate-cw",
+    init:  op_rotate_init,
+    work:  op_rotate_cw,
+    done:  op_none_done,
+};
+struct ida_op desc_rotate_ccw = {
+    name:  "rotate-ccw",
+    init:  op_rotate_init,
+    work:  op_rotate_ccw,
+    done:  op_none_done,
+};
+struct ida_op desc_invert = {
+    name:  "invert",
+    init:  op_none_init,
+    work:  op_invert,
+    done:  op_none_done,
+};
+struct ida_op desc_crop = {
+    name:  "crop",
+    init:  op_crop_init,
+    work:  op_crop_work,
+    done:  op_none_done,
+};
+struct ida_op desc_autocrop = {
+    name:  "autocrop",
+    init:  op_autocrop_init,
+    work:  op_crop_work,
+    done:  op_none_done,
+};
diff --git a/lib/a2jpeg-6b/op.h b/lib/a2jpeg-6b/op.h
new file mode 100644
index 0000000..4d882f5
--- /dev/null
+++ b/lib/a2jpeg-6b/op.h
@@ -0,0 +1,7 @@
+extern struct ida_op desc_flip_vert;
+extern struct ida_op desc_flip_horz;
+extern struct ida_op desc_rotate_cw;
+extern struct ida_op desc_rotate_ccw;
+extern struct ida_op desc_invert;
+extern struct ida_op desc_crop;
+extern struct ida_op desc_autocrop;
diff --git a/lib/a2jpeg-6b/read-jpeg.c b/lib/a2jpeg-6b/read-jpeg.c
new file mode 100644
index 0000000..b6b13f6
--- /dev/null
+++ b/lib/a2jpeg-6b/read-jpeg.c
@@ -0,0 +1,209 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <stddef.h>
+#include <string.h>
+#include <errno.h>
+#include <jpeglib.h>
+#include <setjmp.h>
+
+#include <libexif/exif-data.h>
+
+#include "readers.h"
+#include "misc.h"
+
+/* ---------------------------------------------------------------------- */
+/* load                                                                   */
+
+struct jpeg_state {
+    FILE * infile;                /* source file */
+    
+    struct jpeg_decompress_struct cinfo;
+    struct jpeg_error_mgr jerr;
+    jmp_buf errjump;
+    JSAMPARRAY buffer;            /* Output row buffer */
+    int row_stride,linelength;    /* physical row width in output buffer */
+    unsigned char *image,*ptr;
+
+    /* thumbnail */
+    unsigned char  *thumbnail;
+    unsigned int   tpos, tsize;
+};
+
+/* ---------------------------------------------------------------------- */
+/* data source manager for thumbnail images                               */
+
+static void thumbnail_src_init(struct jpeg_decompress_struct *cinfo)
+{
+    struct jpeg_state *h  = container_of(cinfo, struct jpeg_state, cinfo);
+    cinfo->src->next_input_byte = h->thumbnail;
+    cinfo->src->bytes_in_buffer = h->tsize;
+}
+
+static int thumbnail_src_fill(struct jpeg_decompress_struct *cinfo)
+{
+    fprintf(stderr,"jpeg: panic: no more thumbnail input data\n");
+    exit(1);
+}
+
+static void thumbnail_src_skip(struct jpeg_decompress_struct *cinfo,
+			       long num_bytes)
+{
+    cinfo->src->next_input_byte += num_bytes;
+}
+
+static void thumbnail_src_term(struct jpeg_decompress_struct *cinfo)
+{
+    /* nothing */
+}
+
+static struct jpeg_source_mgr thumbnail_mgr = {
+    .init_source         = thumbnail_src_init,
+    .fill_input_buffer   = thumbnail_src_fill,
+    .skip_input_data     = thumbnail_src_skip,
+    .resync_to_restart   = jpeg_resync_to_restart,
+    .term_source         = thumbnail_src_term,
+};
+
+/* ---------------------------------------------------------------------- */
+/* jpeg loader                                                            */
+
+static void jerror_exit(j_common_ptr info)
+{
+    struct jpeg_decompress_struct *cinfo = (struct jpeg_decompress_struct *)info;
+    struct jpeg_state *h  = container_of(cinfo, struct jpeg_state, cinfo);
+    cinfo->err->output_message(info);
+    longjmp(h->errjump, 1);
+    jpeg_destroy_decompress(cinfo);
+    exit(1);
+}
+
+static void*
+jpeg_init(FILE *fp, char *filename, unsigned int page,
+	  struct ida_image_info *i, int thumbnail)
+{
+    struct jpeg_state *h;
+    jpeg_saved_marker_ptr mark;
+    
+    h = malloc(sizeof(*h));
+    memset(h,0,sizeof(*h));
+    h->infile = fp;
+
+    h->cinfo.err = jpeg_std_error(&h->jerr);
+    h->cinfo.err->error_exit = jerror_exit;
+    if(setjmp(h->errjump))
+	return 0;
+
+    jpeg_create_decompress(&h->cinfo);
+    jpeg_save_markers(&h->cinfo, JPEG_COM,    0xffff); /* comment */
+    jpeg_save_markers(&h->cinfo, JPEG_APP0+1, 0xffff); /* EXIF */
+    jpeg_stdio_src(&h->cinfo, h->infile);
+    jpeg_read_header(&h->cinfo, TRUE);
+
+    for (mark = h->cinfo.marker_list; NULL != mark; mark = mark->next) {
+	switch (mark->marker) {
+	case JPEG_COM:
+	    if (debug)
+		fprintf(stderr,"jpeg: comment found (COM marker) [%.*s]\n",
+			(int)mark->data_length, mark->data);
+	    load_add_extra(i,EXTRA_COMMENT,mark->data,mark->data_length);
+	    break;
+	case JPEG_APP0 +1:
+	    if (debug)
+		fprintf(stderr,"jpeg: exif data found (APP1 marker)\n");
+	    load_add_extra(i,EXTRA_COMMENT,mark->data,mark->data_length);
+
+	    if (thumbnail) {
+		ExifData *ed;
+		
+		ed = exif_data_new_from_data(mark->data,mark->data_length);
+		if (ed->data &&
+		    ed->data[0] == 0xff &&
+		    ed->data[1] == 0xd8) {
+		    if (debug)
+			fprintf(stderr,"jpeg: exif thumbnail found\n");
+
+		    /* save away thumbnail data */
+		    h->thumbnail = malloc(ed->size);
+		    h->tsize = ed->size;
+		    memcpy(h->thumbnail,ed->data,ed->size);
+		}
+		exif_data_unref(ed);
+	    }
+	    break;
+	}
+    }
+
+    if (h->thumbnail) {
+	/* save image size */
+	i->thumbnail   = 1;
+	i->real_width  = h->cinfo.image_width;
+	i->real_height = h->cinfo.image_height;
+
+	/* re-setup jpeg */
+	jpeg_destroy_decompress(&h->cinfo);
+	fclose(h->infile);
+	h->infile = NULL;
+	jpeg_create_decompress(&h->cinfo);
+	h->cinfo.src = &thumbnail_mgr;
+	jpeg_read_header(&h->cinfo, TRUE);
+    }
+
+    h->cinfo.out_color_space = JCS_RGB;
+    jpeg_start_decompress(&h->cinfo);
+    i->width  = h->cinfo.image_width;
+    i->height = h->cinfo.image_height;
+    i->npages = 1;
+    switch (h->cinfo.density_unit) {
+    case 0: /* unknown */
+	break;
+    case 1: /* dot per inch */
+	i->dpi = h->cinfo.X_density;
+	break;
+    case 2: /* dot per cm */
+	i->dpi = res_cm_to_inch(h->cinfo.X_density);
+	break;
+    }
+
+    return h;
+}
+
+static void
+jpeg_read(unsigned char *dst, unsigned int line, void *data)
+{
+    struct jpeg_state *h = data;
+    JSAMPROW row = dst;
+
+    if(setjmp(h->errjump))
+	return;
+    jpeg_read_scanlines(&h->cinfo, &row, 1);
+}
+
+static void
+jpeg_done(void *data)
+{
+    struct jpeg_state *h = data;
+
+    if (setjmp(h->errjump))
+	return;
+    jpeg_destroy_decompress(&h->cinfo);
+    if (h->infile)
+	fclose(h->infile);
+    if (h->thumbnail)
+	free(h->thumbnail);
+    free(h);
+}
+
+struct ida_loader jpeg_loader = {
+    magic: "\xff\xd8",
+    moff:  0,
+    mlen:  2,
+    name:  "libjpeg",
+    init:  jpeg_init,
+    read:  jpeg_read,
+    done:  jpeg_done,
+};
+
+static void __init init_rd(void)
+{
+    load_register(&jpeg_loader);
+}
diff --git a/lib/a2jpeg-6b/readers.c b/lib/a2jpeg-6b/readers.c
new file mode 100644
index 0000000..065be06
--- /dev/null
+++ b/lib/a2jpeg-6b/readers.c
@@ -0,0 +1,133 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "readers.h"
+
+/* ----------------------------------------------------------------------- */
+
+void load_bits_lsb(unsigned char *dst, unsigned char *src, int width,
+		   int on, int off)
+{
+    int i,mask,bit;
+    
+    for (i = 0; i < width; i++) {
+	mask = 1 << (i & 0x07);
+	bit  = src[i>>3] & mask;
+	dst[0] = bit ? on : off;
+	dst[1] = bit ? on : off;
+	dst[2] = bit ? on : off;
+	dst += 3;
+    }
+}
+
+void load_bits_msb(unsigned char *dst, unsigned char *src, int width,
+		   int on, int off)
+{
+    int i,mask,bit;
+    
+    for (i = 0; i < width; i++) {
+	mask = 1 << (7 - (i & 0x07));
+	bit  = src[i>>3] & mask;
+	dst[0] = bit ? on : off;
+	dst[1] = bit ? on : off;
+	dst[2] = bit ? on : off;
+	dst += 3;
+    }
+}
+
+void load_gray(unsigned char *dst, unsigned char *src, int width)
+{
+    int i;
+
+    for (i = 0; i < width; i++) {
+	dst[0] = src[0];
+	dst[1] = src[0];
+	dst[2] = src[0];
+	dst += 3;
+	src += 1;
+    }
+}
+
+void load_graya(unsigned char *dst, unsigned char *src, int width)
+{
+    int i;
+
+    for (i = 0; i < width; i++) {
+	dst[0] = src[0];
+	dst[1] = src[0];
+	dst[2] = src[0];
+	dst += 3;
+	src += 2;
+    }
+}
+
+void load_rgba(unsigned char *dst, unsigned char *src, int width)
+{
+    int i;
+
+    for (i = 0; i < width; i++) {
+	dst[0] = src[0];
+	dst[1] = src[1];
+	dst[2] = src[2];
+	dst += 3;
+	src += 4;
+    }
+}
+
+/* ----------------------------------------------------------------------- */
+
+int load_add_extra(struct ida_image_info *info, enum ida_extype type,
+		   unsigned char *data, unsigned int size)
+{
+    struct ida_extra *extra;
+
+    extra = malloc(sizeof(*extra));
+    if (NULL == extra)
+	return -1;
+    memset(extra,0,sizeof(*extra));
+    extra->data = malloc(size);
+    if (NULL == extra->data) {
+	free(extra);
+	return -1;
+    }
+    extra->type = type;
+    extra->size = size;
+    memcpy(extra->data,data,size);
+    extra->next = info->extra;
+    info->extra = extra;
+    return 0;
+};
+
+struct ida_extra* load_find_extra(struct ida_image_info *info,
+				  enum ida_extype type)
+{
+    struct ida_extra *extra;
+
+    for (extra = info->extra; NULL != extra; extra = extra->next)
+	if (type == extra->type)
+	    return extra;
+    return NULL;
+}
+
+int load_free_extras(struct ida_image_info *info)
+{
+    struct ida_extra *next;
+
+    while (NULL != info->extra) {
+	next = info->extra->next;
+	free(info->extra->data);
+	free(info->extra);
+	info->extra = next;
+    }
+    return 0;
+}
+
+/* ----------------------------------------------------------------------- */
+
+LIST_HEAD(loaders);
+
+void load_register(struct ida_loader *loader)
+{
+    list_add_tail(&loader->list, &loaders);
+}
diff --git a/lib/a2jpeg-6b/readers.h b/lib/a2jpeg-6b/readers.h
new file mode 100644
index 0000000..b54e5b6
--- /dev/null
+++ b/lib/a2jpeg-6b/readers.h
@@ -0,0 +1,104 @@
+#include "list.h"
+
+enum ida_extype {
+    EXTRA_COMMENT = 1,
+    EXTRA_EXIF    = 2,
+};
+
+struct ida_extra {
+    enum ida_extype   type;
+    unsigned char     *data;
+    unsigned int      size;
+    struct ida_extra  *next;
+};
+
+/* image data and metadata */
+struct ida_image_info {
+    unsigned int      width;
+    unsigned int      height;
+    unsigned int      dpi;
+    unsigned int      npages;
+    struct ida_extra  *extra;
+
+    int               thumbnail;
+    unsigned int      real_width;
+    unsigned int      real_height;
+};
+
+struct ida_image {
+    struct ida_image_info  i;
+    unsigned char          *data;
+};
+struct ida_rect {
+    int x1,y1,x2,y2;
+};
+
+/* load image files */
+struct ida_loader {
+    char  *magic;
+    int   moff;
+    int   mlen;
+    char  *name;
+    void* (*init)(FILE *fp, char *filename, unsigned int page,
+		  struct ida_image_info *i, int thumbnail);
+    void  (*read)(unsigned char *dst, unsigned int line, void *data);
+    void  (*done)(void *data);
+    struct list_head list;
+};
+
+/* filter + operations */
+struct ida_op {
+    char  *name;
+    void* (*init)(struct ida_image *src, struct ida_rect *rect,
+		  struct ida_image_info *i, void *parm);
+    void  (*work)(struct ida_image *src, struct ida_rect *rect,
+		  unsigned char *dst, int line,
+		  void *data);
+    void  (*done)(void *data);
+};
+
+void* op_none_init(struct ida_image *src, struct ida_rect *rect,
+		   struct ida_image_info *i, void *parm);
+void  op_none_done(void *data);
+void  op_free_done(void *data);
+
+/* ----------------------------------------------------------------------- */
+/* resolution                                                              */
+
+#define res_cm_to_inch(x) ((x * 2540 + 5) / 1000)
+#define res_m_to_inch(x)  ((x * 2540 + 5) / 100000)
+#define res_inch_to_m(x)  ((x * 100000 + 5) / 2540)
+
+/* ----------------------------------------------------------------------- */
+
+/* helpers */
+void load_bits_lsb(unsigned char *dst, unsigned char *src, int width,
+		   int on, int off);
+void load_bits_msb(unsigned char *dst, unsigned char *src, int width,
+		   int on, int off);
+void load_gray(unsigned char *dst, unsigned char *src, int width);
+void load_graya(unsigned char *dst, unsigned char *src, int width);
+void load_rgba(unsigned char *dst, unsigned char *src, int width);
+
+int load_add_extra(struct ida_image_info *info, enum ida_extype type,
+		   unsigned char *data, unsigned int size);
+struct ida_extra* load_find_extra(struct ida_image_info *info,
+				  enum ida_extype type);
+int load_free_extras(struct ida_image_info *info);
+
+/* ----------------------------------------------------------------------- */
+
+/* other */
+extern int debug;
+extern struct ida_loader ppm_loader;
+extern struct ida_loader jpeg_loader;
+extern struct ida_loader sane_loader;
+extern struct ida_writer ps_writer;
+extern struct ida_writer jpeg_writer;
+
+/* lists */
+#define __init __attribute__ ((constructor))
+#define __fini __attribute__ ((destructor))
+
+extern struct list_head loaders;
+void load_register(struct ida_loader *loader);
diff --git a/lib/a2jpeg-6b/transupp.c b/lib/a2jpeg-6b/transupp.c
new file mode 100644
index 0000000..e5ec564
--- /dev/null
+++ b/lib/a2jpeg-6b/transupp.c
@@ -0,0 +1,928 @@
+/*
+ * transupp.c
+ *
+ * Copyright (C) 1997, Thomas G. Lane.
+ * This file is part of the Independent JPEG Group's software.
+ * For conditions of distribution and use, see the accompanying README file.
+ *
+ * This file contains image transformation routines and other utility code
+ * used by the jpegtran sample application.  These are NOT part of the core
+ * JPEG library.  But we keep these routines separate from jpegtran.c to
+ * ease the task of maintaining jpegtran-like programs that have other user
+ * interfaces.
+ */
+
+/* Although this file really shouldn't have access to the library internals,
+ * it's helpful to let it call jround_up() and jcopy_block_row().
+ */
+#define JPEG_INTERNALS
+
+#include "jinclude.h"
+#include "jpeglib.h"
+#include "transupp.h"		/* My own external interface */
+
+
+#if TRANSFORMS_SUPPORTED
+
+/*
+ * Lossless image transformation routines.  These routines work on DCT
+ * coefficient arrays and thus do not require any lossy decompression
+ * or recompression of the image.
+ * Thanks to Guido Vollbeding for the initial design and code of this feature.
+ *
+ * Horizontal flipping is done in-place, using a single top-to-bottom
+ * pass through the virtual source array.  It will thus be much the
+ * fastest option for images larger than main memory.
+ *
+ * The other routines require a set of destination virtual arrays, so they
+ * need twice as much memory as jpegtran normally does.  The destination
+ * arrays are always written in normal scan order (top to bottom) because
+ * the virtual array manager expects this.  The source arrays will be scanned
+ * in the corresponding order, which means multiple passes through the source
+ * arrays for most of the transforms.  That could result in much thrashing
+ * if the image is larger than main memory.
+ *
+ * Some notes about the operating environment of the individual transform
+ * routines:
+ * 1. Both the source and destination virtual arrays are allocated from the
+ *    source JPEG object, and therefore should be manipulated by calling the
+ *    source's memory manager.
+ * 2. The destination's component count should be used.  It may be smaller
+ *    than the source's when forcing to grayscale.
+ * 3. Likewise the destination's sampling factors should be used.  When
+ *    forcing to grayscale the destination's sampling factors will be all 1,
+ *    and we may as well take that as the effective iMCU size.
+ * 4. When "trim" is in effect, the destination's dimensions will be the
+ *    trimmed values but the source's will be untrimmed.
+ * 5. All the routines assume that the source and destination buffers are
+ *    padded out to a full iMCU boundary.  This is true, although for the
+ *    source buffer it is an undocumented property of jdcoefct.c.
+ * Notes 2,3,4 boil down to this: generally we should use the destination's
+ * dimensions and ignore the source's.
+ */
+
+
+LOCAL(void)
+do_flip_h (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
+	   jvirt_barray_ptr *src_coef_arrays)
+/* Horizontal flip; done in-place, so no separate dest array is required */
+{
+  JDIMENSION MCU_cols, comp_width, blk_x, blk_y;
+  int ci, k, offset_y;
+  JBLOCKARRAY buffer;
+  JCOEFPTR ptr1, ptr2;
+  JCOEF temp1, temp2;
+  jpeg_component_info *compptr;
+
+  /* Horizontal mirroring of DCT blocks is accomplished by swapping
+   * pairs of blocks in-place.  Within a DCT block, we perform horizontal
+   * mirroring by changing the signs of odd-numbered columns.
+   * Partial iMCUs at the right edge are left untouched.
+   */
+  MCU_cols = dstinfo->image_width / (dstinfo->max_h_samp_factor * DCTSIZE);
+
+  for (ci = 0; ci < dstinfo->num_components; ci++) {
+    compptr = dstinfo->comp_info + ci;
+    comp_width = MCU_cols * compptr->h_samp_factor;
+    for (blk_y = 0; blk_y < compptr->height_in_blocks;
+	 blk_y += compptr->v_samp_factor) {
+      buffer = (*srcinfo->mem->access_virt_barray)
+	((j_common_ptr) srcinfo, src_coef_arrays[ci], blk_y,
+	 (JDIMENSION) compptr->v_samp_factor, TRUE);
+      for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
+	for (blk_x = 0; blk_x * 2 < comp_width; blk_x++) {
+	  ptr1 = buffer[offset_y][blk_x];
+	  ptr2 = buffer[offset_y][comp_width - blk_x - 1];
+	  /* this unrolled loop doesn't need to know which row it's on... */
+	  for (k = 0; k < DCTSIZE2; k += 2) {
+	    temp1 = *ptr1;	/* swap even column */
+	    temp2 = *ptr2;
+	    *ptr1++ = temp2;
+	    *ptr2++ = temp1;
+	    temp1 = *ptr1;	/* swap odd column with sign change */
+	    temp2 = *ptr2;
+	    *ptr1++ = -temp2;
+	    *ptr2++ = -temp1;
+	  }
+	}
+      }
+    }
+  }
+}
+
+
+LOCAL(void)
+do_flip_v (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
+	   jvirt_barray_ptr *src_coef_arrays,
+	   jvirt_barray_ptr *dst_coef_arrays)
+/* Vertical flip */
+{
+  JDIMENSION MCU_rows, comp_height, dst_blk_x, dst_blk_y;
+  int ci, i, j, offset_y;
+  JBLOCKARRAY src_buffer, dst_buffer;
+  JBLOCKROW src_row_ptr, dst_row_ptr;
+  JCOEFPTR src_ptr, dst_ptr;
+  jpeg_component_info *compptr;
+
+  /* We output into a separate array because we can't touch different
+   * rows of the source virtual array simultaneously.  Otherwise, this
+   * is a pretty straightforward analog of horizontal flip.
+   * Within a DCT block, vertical mirroring is done by changing the signs
+   * of odd-numbered rows.
+   * Partial iMCUs at the bottom edge are copied verbatim.
+   */
+  MCU_rows = dstinfo->image_height / (dstinfo->max_v_samp_factor * DCTSIZE);
+
+  for (ci = 0; ci < dstinfo->num_components; ci++) {
+    compptr = dstinfo->comp_info + ci;
+    comp_height = MCU_rows * compptr->v_samp_factor;
+    for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;
+	 dst_blk_y += compptr->v_samp_factor) {
+      dst_buffer = (*srcinfo->mem->access_virt_barray)
+	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
+	 (JDIMENSION) compptr->v_samp_factor, TRUE);
+      if (dst_blk_y < comp_height) {
+	/* Row is within the mirrorable area. */
+	src_buffer = (*srcinfo->mem->access_virt_barray)
+	  ((j_common_ptr) srcinfo, src_coef_arrays[ci],
+	   comp_height - dst_blk_y - (JDIMENSION) compptr->v_samp_factor,
+	   (JDIMENSION) compptr->v_samp_factor, FALSE);
+      } else {
+	/* Bottom-edge blocks will be copied verbatim. */
+	src_buffer = (*srcinfo->mem->access_virt_barray)
+	  ((j_common_ptr) srcinfo, src_coef_arrays[ci], dst_blk_y,
+	   (JDIMENSION) compptr->v_samp_factor, FALSE);
+      }
+      for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
+	if (dst_blk_y < comp_height) {
+	  /* Row is within the mirrorable area. */
+	  dst_row_ptr = dst_buffer[offset_y];
+	  src_row_ptr = src_buffer[compptr->v_samp_factor - offset_y - 1];
+	  for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks;
+	       dst_blk_x++) {
+	    dst_ptr = dst_row_ptr[dst_blk_x];
+	    src_ptr = src_row_ptr[dst_blk_x];
+	    for (i = 0; i < DCTSIZE; i += 2) {
+	      /* copy even row */
+	      for (j = 0; j < DCTSIZE; j++)
+		*dst_ptr++ = *src_ptr++;
+	      /* copy odd row with sign change */
+	      for (j = 0; j < DCTSIZE; j++)
+		*dst_ptr++ = - *src_ptr++;
+	    }
+	  }
+	} else {
+	  /* Just copy row verbatim. */
+	  jcopy_block_row(src_buffer[offset_y], dst_buffer[offset_y],
+			  compptr->width_in_blocks);
+	}
+      }
+    }
+  }
+}
+
+
+LOCAL(void)
+do_transpose (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
+	      jvirt_barray_ptr *src_coef_arrays,
+	      jvirt_barray_ptr *dst_coef_arrays)
+/* Transpose source into destination */
+{
+  JDIMENSION dst_blk_x, dst_blk_y;
+  int ci, i, j, offset_x, offset_y;
+  JBLOCKARRAY src_buffer, dst_buffer;
+  JCOEFPTR src_ptr, dst_ptr;
+  jpeg_component_info *compptr;
+
+  /* Transposing pixels within a block just requires transposing the
+   * DCT coefficients.
+   * Partial iMCUs at the edges require no special treatment; we simply
+   * process all the available DCT blocks for every component.
+   */
+  for (ci = 0; ci < dstinfo->num_components; ci++) {
+    compptr = dstinfo->comp_info + ci;
+    for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;
+	 dst_blk_y += compptr->v_samp_factor) {
+      dst_buffer = (*srcinfo->mem->access_virt_barray)
+	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
+	 (JDIMENSION) compptr->v_samp_factor, TRUE);
+      for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
+	for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks;
+	     dst_blk_x += compptr->h_samp_factor) {
+	  src_buffer = (*srcinfo->mem->access_virt_barray)
+	    ((j_common_ptr) srcinfo, src_coef_arrays[ci], dst_blk_x,
+	     (JDIMENSION) compptr->h_samp_factor, FALSE);
+	  for (offset_x = 0; offset_x < compptr->h_samp_factor; offset_x++) {
+	    src_ptr = src_buffer[offset_x][dst_blk_y + offset_y];
+	    dst_ptr = dst_buffer[offset_y][dst_blk_x + offset_x];
+	    for (i = 0; i < DCTSIZE; i++)
+	      for (j = 0; j < DCTSIZE; j++)
+		dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
+	  }
+	}
+      }
+    }
+  }
+}
+
+
+LOCAL(void)
+do_rot_90 (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
+	   jvirt_barray_ptr *src_coef_arrays,
+	   jvirt_barray_ptr *dst_coef_arrays)
+/* 90 degree rotation is equivalent to
+ *   1. Transposing the image;
+ *   2. Horizontal mirroring.
+ * These two steps are merged into a single processing routine.
+ */
+{
+  JDIMENSION MCU_cols, comp_width, dst_blk_x, dst_blk_y;
+  int ci, i, j, offset_x, offset_y;
+  JBLOCKARRAY src_buffer, dst_buffer;
+  JCOEFPTR src_ptr, dst_ptr;
+  jpeg_component_info *compptr;
+
+  /* Because of the horizontal mirror step, we can't process partial iMCUs
+   * at the (output) right edge properly.  They just get transposed and
+   * not mirrored.
+   */
+  MCU_cols = dstinfo->image_width / (dstinfo->max_h_samp_factor * DCTSIZE);
+
+  for (ci = 0; ci < dstinfo->num_components; ci++) {
+    compptr = dstinfo->comp_info + ci;
+    comp_width = MCU_cols * compptr->h_samp_factor;
+    for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;
+	 dst_blk_y += compptr->v_samp_factor) {
+      dst_buffer = (*srcinfo->mem->access_virt_barray)
+	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
+	 (JDIMENSION) compptr->v_samp_factor, TRUE);
+      for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
+	for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks;
+	     dst_blk_x += compptr->h_samp_factor) {
+	  src_buffer = (*srcinfo->mem->access_virt_barray)
+	    ((j_common_ptr) srcinfo, src_coef_arrays[ci], dst_blk_x,
+	     (JDIMENSION) compptr->h_samp_factor, FALSE);
+	  for (offset_x = 0; offset_x < compptr->h_samp_factor; offset_x++) {
+	    src_ptr = src_buffer[offset_x][dst_blk_y + offset_y];
+	    if (dst_blk_x < comp_width) {
+	      /* Block is within the mirrorable area. */
+	      dst_ptr = dst_buffer[offset_y]
+		[comp_width - dst_blk_x - offset_x - 1];
+	      for (i = 0; i < DCTSIZE; i++) {
+		for (j = 0; j < DCTSIZE; j++)
+		  dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
+		i++;
+		for (j = 0; j < DCTSIZE; j++)
+		  dst_ptr[j*DCTSIZE+i] = -src_ptr[i*DCTSIZE+j];
+	      }
+	    } else {
+	      /* Edge blocks are transposed but not mirrored. */
+	      dst_ptr = dst_buffer[offset_y][dst_blk_x + offset_x];
+	      for (i = 0; i < DCTSIZE; i++)
+		for (j = 0; j < DCTSIZE; j++)
+		  dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
+	    }
+	  }
+	}
+      }
+    }
+  }
+}
+
+
+LOCAL(void)
+do_rot_270 (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
+	    jvirt_barray_ptr *src_coef_arrays,
+	    jvirt_barray_ptr *dst_coef_arrays)
+/* 270 degree rotation is equivalent to
+ *   1. Horizontal mirroring;
+ *   2. Transposing the image.
+ * These two steps are merged into a single processing routine.
+ */
+{
+  JDIMENSION MCU_rows, comp_height, dst_blk_x, dst_blk_y;
+  int ci, i, j, offset_x, offset_y;
+  JBLOCKARRAY src_buffer, dst_buffer;
+  JCOEFPTR src_ptr, dst_ptr;
+  jpeg_component_info *compptr;
+
+  /* Because of the horizontal mirror step, we can't process partial iMCUs
+   * at the (output) bottom edge properly.  They just get transposed and
+   * not mirrored.
+   */
+  MCU_rows = dstinfo->image_height / (dstinfo->max_v_samp_factor * DCTSIZE);
+
+  for (ci = 0; ci < dstinfo->num_components; ci++) {
+    compptr = dstinfo->comp_info + ci;
+    comp_height = MCU_rows * compptr->v_samp_factor;
+    for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;
+	 dst_blk_y += compptr->v_samp_factor) {
+      dst_buffer = (*srcinfo->mem->access_virt_barray)
+	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
+	 (JDIMENSION) compptr->v_samp_factor, TRUE);
+      for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
+	for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks;
+	     dst_blk_x += compptr->h_samp_factor) {
+	  src_buffer = (*srcinfo->mem->access_virt_barray)
+	    ((j_common_ptr) srcinfo, src_coef_arrays[ci], dst_blk_x,
+	     (JDIMENSION) compptr->h_samp_factor, FALSE);
+	  for (offset_x = 0; offset_x < compptr->h_samp_factor; offset_x++) {
+	    dst_ptr = dst_buffer[offset_y][dst_blk_x + offset_x];
+	    if (dst_blk_y < comp_height) {
+	      /* Block is within the mirrorable area. */
+	      src_ptr = src_buffer[offset_x]
+		[comp_height - dst_blk_y - offset_y - 1];
+	      for (i = 0; i < DCTSIZE; i++) {
+		for (j = 0; j < DCTSIZE; j++) {
+		  dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
+		  j++;
+		  dst_ptr[j*DCTSIZE+i] = -src_ptr[i*DCTSIZE+j];
+		}
+	      }
+	    } else {
+	      /* Edge blocks are transposed but not mirrored. */
+	      src_ptr = src_buffer[offset_x][dst_blk_y + offset_y];
+	      for (i = 0; i < DCTSIZE; i++)
+		for (j = 0; j < DCTSIZE; j++)
+		  dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
+	    }
+	  }
+	}
+      }
+    }
+  }
+}
+
+
+LOCAL(void)
+do_rot_180 (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
+	    jvirt_barray_ptr *src_coef_arrays,
+	    jvirt_barray_ptr *dst_coef_arrays)
+/* 180 degree rotation is equivalent to
+ *   1. Vertical mirroring;
+ *   2. Horizontal mirroring.
+ * These two steps are merged into a single processing routine.
+ */
+{
+  JDIMENSION MCU_cols, MCU_rows, comp_width, comp_height, dst_blk_x, dst_blk_y;
+  int ci, i, j, offset_y;
+  JBLOCKARRAY src_buffer, dst_buffer;
+  JBLOCKROW src_row_ptr, dst_row_ptr;
+  JCOEFPTR src_ptr, dst_ptr;
+  jpeg_component_info *compptr;
+
+  MCU_cols = dstinfo->image_width / (dstinfo->max_h_samp_factor * DCTSIZE);
+  MCU_rows = dstinfo->image_height / (dstinfo->max_v_samp_factor * DCTSIZE);
+
+  for (ci = 0; ci < dstinfo->num_components; ci++) {
+    compptr = dstinfo->comp_info + ci;
+    comp_width = MCU_cols * compptr->h_samp_factor;
+    comp_height = MCU_rows * compptr->v_samp_factor;
+    for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;
+	 dst_blk_y += compptr->v_samp_factor) {
+      dst_buffer = (*srcinfo->mem->access_virt_barray)
+	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
+	 (JDIMENSION) compptr->v_samp_factor, TRUE);
+      if (dst_blk_y < comp_height) {
+	/* Row is within the vertically mirrorable area. */
+	src_buffer = (*srcinfo->mem->access_virt_barray)
+	  ((j_common_ptr) srcinfo, src_coef_arrays[ci],
+	   comp_height - dst_blk_y - (JDIMENSION) compptr->v_samp_factor,
+	   (JDIMENSION) compptr->v_samp_factor, FALSE);
+      } else {
+	/* Bottom-edge rows are only mirrored horizontally. */
+	src_buffer = (*srcinfo->mem->access_virt_barray)
+	  ((j_common_ptr) srcinfo, src_coef_arrays[ci], dst_blk_y,
+	   (JDIMENSION) compptr->v_samp_factor, FALSE);
+      }
+      for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
+	if (dst_blk_y < comp_height) {
+	  /* Row is within the mirrorable area. */
+	  dst_row_ptr = dst_buffer[offset_y];
+	  src_row_ptr = src_buffer[compptr->v_samp_factor - offset_y - 1];
+	  /* Process the blocks that can be mirrored both ways. */
+	  for (dst_blk_x = 0; dst_blk_x < comp_width; dst_blk_x++) {
+	    dst_ptr = dst_row_ptr[dst_blk_x];
+	    src_ptr = src_row_ptr[comp_width - dst_blk_x - 1];
+	    for (i = 0; i < DCTSIZE; i += 2) {
+	      /* For even row, negate every odd column. */
+	      for (j = 0; j < DCTSIZE; j += 2) {
+		*dst_ptr++ = *src_ptr++;
+		*dst_ptr++ = - *src_ptr++;
+	      }
+	      /* For odd row, negate every even column. */
+	      for (j = 0; j < DCTSIZE; j += 2) {
+		*dst_ptr++ = - *src_ptr++;
+		*dst_ptr++ = *src_ptr++;
+	      }
+	    }
+	  }
+	  /* Any remaining right-edge blocks are only mirrored vertically. */
+	  for (; dst_blk_x < compptr->width_in_blocks; dst_blk_x++) {
+	    dst_ptr = dst_row_ptr[dst_blk_x];
+	    src_ptr = src_row_ptr[dst_blk_x];
+	    for (i = 0; i < DCTSIZE; i += 2) {
+	      for (j = 0; j < DCTSIZE; j++)
+		*dst_ptr++ = *src_ptr++;
+	      for (j = 0; j < DCTSIZE; j++)
+		*dst_ptr++ = - *src_ptr++;
+	    }
+	  }
+	} else {
+	  /* Remaining rows are just mirrored horizontally. */
+	  dst_row_ptr = dst_buffer[offset_y];
+	  src_row_ptr = src_buffer[offset_y];
+	  /* Process the blocks that can be mirrored. */
+	  for (dst_blk_x = 0; dst_blk_x < comp_width; dst_blk_x++) {
+	    dst_ptr = dst_row_ptr[dst_blk_x];
+	    src_ptr = src_row_ptr[comp_width - dst_blk_x - 1];
+	    for (i = 0; i < DCTSIZE2; i += 2) {
+	      *dst_ptr++ = *src_ptr++;
+	      *dst_ptr++ = - *src_ptr++;
+	    }
+	  }
+	  /* Any remaining right-edge blocks are only copied. */
+	  for (; dst_blk_x < compptr->width_in_blocks; dst_blk_x++) {
+	    dst_ptr = dst_row_ptr[dst_blk_x];
+	    src_ptr = src_row_ptr[dst_blk_x];
+	    for (i = 0; i < DCTSIZE2; i++)
+	      *dst_ptr++ = *src_ptr++;
+	  }
+	}
+      }
+    }
+  }
+}
+
+
+LOCAL(void)
+do_transverse (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
+	       jvirt_barray_ptr *src_coef_arrays,
+	       jvirt_barray_ptr *dst_coef_arrays)
+/* Transverse transpose is equivalent to
+ *   1. 180 degree rotation;
+ *   2. Transposition;
+ * or
+ *   1. Horizontal mirroring;
+ *   2. Transposition;
+ *   3. Horizontal mirroring.
+ * These steps are merged into a single processing routine.
+ */
+{
+  JDIMENSION MCU_cols, MCU_rows, comp_width, comp_height, dst_blk_x, dst_blk_y;
+  int ci, i, j, offset_x, offset_y;
+  JBLOCKARRAY src_buffer, dst_buffer;
+  JCOEFPTR src_ptr, dst_ptr;
+  jpeg_component_info *compptr;
+
+  MCU_cols = dstinfo->image_width / (dstinfo->max_h_samp_factor * DCTSIZE);
+  MCU_rows = dstinfo->image_height / (dstinfo->max_v_samp_factor * DCTSIZE);
+
+  for (ci = 0; ci < dstinfo->num_components; ci++) {
+    compptr = dstinfo->comp_info + ci;
+    comp_width = MCU_cols * compptr->h_samp_factor;
+    comp_height = MCU_rows * compptr->v_samp_factor;
+    for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;
+	 dst_blk_y += compptr->v_samp_factor) {
+      dst_buffer = (*srcinfo->mem->access_virt_barray)
+	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
+	 (JDIMENSION) compptr->v_samp_factor, TRUE);
+      for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
+	for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks;
+	     dst_blk_x += compptr->h_samp_factor) {
+	  src_buffer = (*srcinfo->mem->access_virt_barray)
+	    ((j_common_ptr) srcinfo, src_coef_arrays[ci], dst_blk_x,
+	     (JDIMENSION) compptr->h_samp_factor, FALSE);
+	  for (offset_x = 0; offset_x < compptr->h_samp_factor; offset_x++) {
+	    if (dst_blk_y < comp_height) {
+	      src_ptr = src_buffer[offset_x]
+		[comp_height - dst_blk_y - offset_y - 1];
+	      if (dst_blk_x < comp_width) {
+		/* Block is within the mirrorable area. */
+		dst_ptr = dst_buffer[offset_y]
+		  [comp_width - dst_blk_x - offset_x - 1];
+		for (i = 0; i < DCTSIZE; i++) {
+		  for (j = 0; j < DCTSIZE; j++) {
+		    dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
+		    j++;
+		    dst_ptr[j*DCTSIZE+i] = -src_ptr[i*DCTSIZE+j];
+		  }
+		  i++;
+		  for (j = 0; j < DCTSIZE; j++) {
+		    dst_ptr[j*DCTSIZE+i] = -src_ptr[i*DCTSIZE+j];
+		    j++;
+		    dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
+		  }
+		}
+	      } else {
+		/* Right-edge blocks are mirrored in y only */
+		dst_ptr = dst_buffer[offset_y][dst_blk_x + offset_x];
+		for (i = 0; i < DCTSIZE; i++) {
+		  for (j = 0; j < DCTSIZE; j++) {
+		    dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
+		    j++;
+		    dst_ptr[j*DCTSIZE+i] = -src_ptr[i*DCTSIZE+j];
+		  }
+		}
+	      }
+	    } else {
+	      src_ptr = src_buffer[offset_x][dst_blk_y + offset_y];
+	      if (dst_blk_x < comp_width) {
+		/* Bottom-edge blocks are mirrored in x only */
+		dst_ptr = dst_buffer[offset_y]
+		  [comp_width - dst_blk_x - offset_x - 1];
+		for (i = 0; i < DCTSIZE; i++) {
+		  for (j = 0; j < DCTSIZE; j++)
+		    dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
+		  i++;
+		  for (j = 0; j < DCTSIZE; j++)
+		    dst_ptr[j*DCTSIZE+i] = -src_ptr[i*DCTSIZE+j];
+		}
+	      } else {
+		/* At lower right corner, just transpose, no mirroring */
+		dst_ptr = dst_buffer[offset_y][dst_blk_x + offset_x];
+		for (i = 0; i < DCTSIZE; i++)
+		  for (j = 0; j < DCTSIZE; j++)
+		    dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
+	      }
+	    }
+	  }
+	}
+      }
+    }
+  }
+}
+
+
+/* Request any required workspace.
+ *
+ * We allocate the workspace virtual arrays from the source decompression
+ * object, so that all the arrays (both the original data and the workspace)
+ * will be taken into account while making memory management decisions.
+ * Hence, this routine must be called after jpeg_read_header (which reads
+ * the image dimensions) and before jpeg_read_coefficients (which realizes
+ * the source's virtual arrays).
+ */
+
+GLOBAL(void)
+jtransform_request_workspace (j_decompress_ptr srcinfo,
+			      jpeg_transform_info *info)
+{
+  jvirt_barray_ptr *coef_arrays = NULL;
+  jpeg_component_info *compptr;
+  int ci;
+
+  if (info->force_grayscale &&
+      srcinfo->jpeg_color_space == JCS_YCbCr &&
+      srcinfo->num_components == 3) {
+    /* We'll only process the first component */
+    info->num_components = 1;
+  } else {
+    /* Process all the components */
+    info->num_components = srcinfo->num_components;
+  }
+
+  switch (info->transform) {
+  case JXFORM_NONE:
+  case JXFORM_FLIP_H:
+    /* Don't need a workspace array */
+    break;
+  case JXFORM_FLIP_V:
+  case JXFORM_ROT_180:
+    /* Need workspace arrays having same dimensions as source image.
+     * Note that we allocate arrays padded out to the next iMCU boundary,
+     * so that transform routines need not worry about missing edge blocks.
+     */
+    coef_arrays = (jvirt_barray_ptr *)
+      (*srcinfo->mem->alloc_small) ((j_common_ptr) srcinfo, JPOOL_IMAGE,
+	SIZEOF(jvirt_barray_ptr) * info->num_components);
+    for (ci = 0; ci < info->num_components; ci++) {
+      compptr = srcinfo->comp_info + ci;
+      coef_arrays[ci] = (*srcinfo->mem->request_virt_barray)
+	((j_common_ptr) srcinfo, JPOOL_IMAGE, FALSE,
+	 (JDIMENSION) jround_up((long) compptr->width_in_blocks,
+				(long) compptr->h_samp_factor),
+	 (JDIMENSION) jround_up((long) compptr->height_in_blocks,
+				(long) compptr->v_samp_factor),
+	 (JDIMENSION) compptr->v_samp_factor);
+    }
+    break;
+  case JXFORM_TRANSPOSE:
+  case JXFORM_TRANSVERSE:
+  case JXFORM_ROT_90:
+  case JXFORM_ROT_270:
+    /* Need workspace arrays having transposed dimensions.
+     * Note that we allocate arrays padded out to the next iMCU boundary,
+     * so that transform routines need not worry about missing edge blocks.
+     */
+    coef_arrays = (jvirt_barray_ptr *)
+      (*srcinfo->mem->alloc_small) ((j_common_ptr) srcinfo, JPOOL_IMAGE,
+	SIZEOF(jvirt_barray_ptr) * info->num_components);
+    for (ci = 0; ci < info->num_components; ci++) {
+      compptr = srcinfo->comp_info + ci;
+      coef_arrays[ci] = (*srcinfo->mem->request_virt_barray)
+	((j_common_ptr) srcinfo, JPOOL_IMAGE, FALSE,
+	 (JDIMENSION) jround_up((long) compptr->height_in_blocks,
+				(long) compptr->v_samp_factor),
+	 (JDIMENSION) jround_up((long) compptr->width_in_blocks,
+				(long) compptr->h_samp_factor),
+	 (JDIMENSION) compptr->h_samp_factor);
+    }
+    break;
+  }
+  info->workspace_coef_arrays = coef_arrays;
+}
+
+
+/* Transpose destination image parameters */
+
+LOCAL(void)
+transpose_critical_parameters (j_compress_ptr dstinfo)
+{
+  int tblno, i, j, ci, itemp;
+  jpeg_component_info *compptr;
+  JQUANT_TBL *qtblptr;
+  JDIMENSION dtemp;
+  UINT16 qtemp;
+
+  /* Transpose basic image dimensions */
+  dtemp = dstinfo->image_width;
+  dstinfo->image_width = dstinfo->image_height;
+  dstinfo->image_height = dtemp;
+
+  /* Transpose sampling factors */
+  for (ci = 0; ci < dstinfo->num_components; ci++) {
+    compptr = dstinfo->comp_info + ci;
+    itemp = compptr->h_samp_factor;
+    compptr->h_samp_factor = compptr->v_samp_factor;
+    compptr->v_samp_factor = itemp;
+  }
+
+  /* Transpose quantization tables */
+  for (tblno = 0; tblno < NUM_QUANT_TBLS; tblno++) {
+    qtblptr = dstinfo->quant_tbl_ptrs[tblno];
+    if (qtblptr != NULL) {
+      for (i = 0; i < DCTSIZE; i++) {
+	for (j = 0; j < i; j++) {
+	  qtemp = qtblptr->quantval[i*DCTSIZE+j];
+	  qtblptr->quantval[i*DCTSIZE+j] = qtblptr->quantval[j*DCTSIZE+i];
+	  qtblptr->quantval[j*DCTSIZE+i] = qtemp;
+	}
+      }
+    }
+  }
+}
+
+
+/* Trim off any partial iMCUs on the indicated destination edge */
+
+LOCAL(void)
+trim_right_edge (j_compress_ptr dstinfo)
+{
+  int ci, max_h_samp_factor;
+  JDIMENSION MCU_cols;
+
+  /* We have to compute max_h_samp_factor ourselves,
+   * because it hasn't been set yet in the destination
+   * (and we don't want to use the source's value).
+   */
+  max_h_samp_factor = 1;
+  for (ci = 0; ci < dstinfo->num_components; ci++) {
+    int h_samp_factor = dstinfo->comp_info[ci].h_samp_factor;
+    max_h_samp_factor = MAX(max_h_samp_factor, h_samp_factor);
+  }
+  MCU_cols = dstinfo->image_width / (max_h_samp_factor * DCTSIZE);
+  if (MCU_cols > 0)		/* can't trim to 0 pixels */
+    dstinfo->image_width = MCU_cols * (max_h_samp_factor * DCTSIZE);
+}
+
+LOCAL(void)
+trim_bottom_edge (j_compress_ptr dstinfo)
+{
+  int ci, max_v_samp_factor;
+  JDIMENSION MCU_rows;
+
+  /* We have to compute max_v_samp_factor ourselves,
+   * because it hasn't been set yet in the destination
+   * (and we don't want to use the source's value).
+   */
+  max_v_samp_factor = 1;
+  for (ci = 0; ci < dstinfo->num_components; ci++) {
+    int v_samp_factor = dstinfo->comp_info[ci].v_samp_factor;
+    max_v_samp_factor = MAX(max_v_samp_factor, v_samp_factor);
+  }
+  MCU_rows = dstinfo->image_height / (max_v_samp_factor * DCTSIZE);
+  if (MCU_rows > 0)		/* can't trim to 0 pixels */
+    dstinfo->image_height = MCU_rows * (max_v_samp_factor * DCTSIZE);
+}
+
+
+/* Adjust output image parameters as needed.
+ *
+ * This must be called after jpeg_copy_critical_parameters()
+ * and before jpeg_write_coefficients().
+ *
+ * The return value is the set of virtual coefficient arrays to be written
+ * (either the ones allocated by jtransform_request_workspace, or the
+ * original source data arrays).  The caller will need to pass this value
+ * to jpeg_write_coefficients().
+ */
+
+GLOBAL(jvirt_barray_ptr *)
+jtransform_adjust_parameters (j_decompress_ptr srcinfo,
+			      j_compress_ptr dstinfo,
+			      jvirt_barray_ptr *src_coef_arrays,
+			      jpeg_transform_info *info)
+{
+  /* If force-to-grayscale is requested, adjust destination parameters */
+  if (info->force_grayscale) {
+    /* We use jpeg_set_colorspace to make sure subsidiary settings get fixed
+     * properly.  Among other things, the target h_samp_factor & v_samp_factor
+     * will get set to 1, which typically won't match the source.
+     * In fact we do this even if the source is already grayscale; that
+     * provides an easy way of coercing a grayscale JPEG with funny sampling
+     * factors to the customary 1,1.  (Some decoders fail on other factors.)
+     */
+    if ((dstinfo->jpeg_color_space == JCS_YCbCr &&
+	 dstinfo->num_components == 3) ||
+	(dstinfo->jpeg_color_space == JCS_GRAYSCALE &&
+	 dstinfo->num_components == 1)) {
+      /* We have to preserve the source's quantization table number. */
+      int sv_quant_tbl_no = dstinfo->comp_info[0].quant_tbl_no;
+      jpeg_set_colorspace(dstinfo, JCS_GRAYSCALE);
+      dstinfo->comp_info[0].quant_tbl_no = sv_quant_tbl_no;
+    } else {
+      /* Sorry, can't do it */
+      ERREXIT(dstinfo, JERR_CONVERSION_NOTIMPL);
+    }
+  }
+
+  /* Correct the destination's image dimensions etc if necessary */
+  switch (info->transform) {
+  case JXFORM_NONE:
+    /* Nothing to do */
+    break;
+  case JXFORM_FLIP_H:
+    if (info->trim)
+      trim_right_edge(dstinfo);
+    break;
+  case JXFORM_FLIP_V:
+    if (info->trim)
+      trim_bottom_edge(dstinfo);
+    break;
+  case JXFORM_TRANSPOSE:
+    transpose_critical_parameters(dstinfo);
+    /* transpose does NOT have to trim anything */
+    break;
+  case JXFORM_TRANSVERSE:
+    transpose_critical_parameters(dstinfo);
+    if (info->trim) {
+      trim_right_edge(dstinfo);
+      trim_bottom_edge(dstinfo);
+    }
+    break;
+  case JXFORM_ROT_90:
+    transpose_critical_parameters(dstinfo);
+    if (info->trim)
+      trim_right_edge(dstinfo);
+    break;
+  case JXFORM_ROT_180:
+    if (info->trim) {
+      trim_right_edge(dstinfo);
+      trim_bottom_edge(dstinfo);
+    }
+    break;
+  case JXFORM_ROT_270:
+    transpose_critical_parameters(dstinfo);
+    if (info->trim)
+      trim_bottom_edge(dstinfo);
+    break;
+  }
+
+  /* Return the appropriate output data set */
+  if (info->workspace_coef_arrays != NULL)
+    return info->workspace_coef_arrays;
+  return src_coef_arrays;
+}
+
+
+/* Execute the actual transformation, if any.
+ *
+ * This must be called *after* jpeg_write_coefficients, because it depends
+ * on jpeg_write_coefficients to have computed subsidiary values such as
+ * the per-component width and height fields in the destination object.
+ *
+ * Note that some transformations will modify the source data arrays!
+ */
+
+GLOBAL(void)
+jtransform_execute_transformation (j_decompress_ptr srcinfo,
+				   j_compress_ptr dstinfo,
+				   jvirt_barray_ptr *src_coef_arrays,
+				   jpeg_transform_info *info)
+{
+  jvirt_barray_ptr *dst_coef_arrays = info->workspace_coef_arrays;
+
+  switch (info->transform) {
+  case JXFORM_NONE:
+    break;
+  case JXFORM_FLIP_H:
+    do_flip_h(srcinfo, dstinfo, src_coef_arrays);
+    break;
+  case JXFORM_FLIP_V:
+    do_flip_v(srcinfo, dstinfo, src_coef_arrays, dst_coef_arrays);
+    break;
+  case JXFORM_TRANSPOSE:
+    do_transpose(srcinfo, dstinfo, src_coef_arrays, dst_coef_arrays);
+    break;
+  case JXFORM_TRANSVERSE:
+    do_transverse(srcinfo, dstinfo, src_coef_arrays, dst_coef_arrays);
+    break;
+  case JXFORM_ROT_90:
+    do_rot_90(srcinfo, dstinfo, src_coef_arrays, dst_coef_arrays);
+    break;
+  case JXFORM_ROT_180:
+    do_rot_180(srcinfo, dstinfo, src_coef_arrays, dst_coef_arrays);
+    break;
+  case JXFORM_ROT_270:
+    do_rot_270(srcinfo, dstinfo, src_coef_arrays, dst_coef_arrays);
+    break;
+  }
+}
+
+#endif /* TRANSFORMS_SUPPORTED */
+
+
+/* Setup decompression object to save desired markers in memory.
+ * This must be called before jpeg_read_header() to have the desired effect.
+ */
+
+GLOBAL(void)
+jcopy_markers_setup (j_decompress_ptr srcinfo, JCOPY_OPTION option)
+{
+#ifdef SAVE_MARKERS_SUPPORTED
+  int m;
+
+  /* Save comments except under NONE option */
+  if (option != JCOPYOPT_NONE) {
+    jpeg_save_markers(srcinfo, JPEG_COM, 0xFFFF);
+  }
+  /* Save all types of APPn markers iff ALL option */
+  if (option == JCOPYOPT_ALL) {
+    for (m = 0; m < 16; m++)
+      jpeg_save_markers(srcinfo, JPEG_APP0 + m, 0xFFFF);
+  }
+#endif /* SAVE_MARKERS_SUPPORTED */
+}
+
+/* Copy markers saved in the given source object to the destination object.
+ * This should be called just after jpeg_start_compress() or
+ * jpeg_write_coefficients().
+ * Note that those routines will have written the SOI, and also the
+ * JFIF APP0 or Adobe APP14 markers if selected.
+ */
+
+GLOBAL(void)
+jcopy_markers_execute (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
+		       JCOPY_OPTION option)
+{
+  jpeg_saved_marker_ptr marker;
+
+  /* In the current implementation, we don't actually need to examine the
+   * option flag here; we just copy everything that got saved.
+   * But to avoid confusion, we do not output JFIF and Adobe APP14 markers
+   * if the encoder library already wrote one.
+   */
+  for (marker = srcinfo->marker_list; marker != NULL; marker = marker->next) {
+    if (dstinfo->write_JFIF_header &&
+	marker->marker == JPEG_APP0 &&
+	marker->data_length >= 5 &&
+	GETJOCTET(marker->data[0]) == 0x4A &&
+	GETJOCTET(marker->data[1]) == 0x46 &&
+	GETJOCTET(marker->data[2]) == 0x49 &&
+	GETJOCTET(marker->data[3]) == 0x46 &&
+	GETJOCTET(marker->data[4]) == 0)
+      continue;			/* reject duplicate JFIF */
+    if (dstinfo->write_Adobe_marker &&
+	marker->marker == JPEG_APP0+14 &&
+	marker->data_length >= 5 &&
+	GETJOCTET(marker->data[0]) == 0x41 &&
+	GETJOCTET(marker->data[1]) == 0x64 &&
+	GETJOCTET(marker->data[2]) == 0x6F &&
+	GETJOCTET(marker->data[3]) == 0x62 &&
+	GETJOCTET(marker->data[4]) == 0x65)
+      continue;			/* reject duplicate Adobe */
+#ifdef NEED_FAR_POINTERS
+    /* We could use jpeg_write_marker if the data weren't FAR... */
+    {
+      unsigned int i;
+      jpeg_write_m_header(dstinfo, marker->marker, marker->data_length);
+      for (i = 0; i < marker->data_length; i++)
+	jpeg_write_m_byte(dstinfo, marker->data[i]);
+    }
+#else
+    jpeg_write_marker(dstinfo, marker->marker,
+		      marker->data, marker->data_length);
+#endif
+  }
+}
diff --git a/lib/a2jpeg-6b/transupp.h b/lib/a2jpeg-6b/transupp.h
new file mode 100644
index 0000000..5c2d32a
--- /dev/null
+++ b/lib/a2jpeg-6b/transupp.h
@@ -0,0 +1,135 @@
+/*
+ * transupp.h
+ *
+ * Copyright (C) 1997, Thomas G. Lane.
+ * This file is part of the Independent JPEG Group's software.
+ * For conditions of distribution and use, see the accompanying README file.
+ *
+ * This file contains declarations for image transformation routines and
+ * other utility code used by the jpegtran sample application.  These are
+ * NOT part of the core JPEG library.  But we keep these routines separate
+ * from jpegtran.c to ease the task of maintaining jpegtran-like programs
+ * that have other user interfaces.
+ *
+ * NOTE: all the routines declared here have very specific requirements
+ * about when they are to be executed during the reading and writing of the
+ * source and destination files.  See the comments in transupp.c, or see
+ * jpegtran.c for an example of correct usage.
+ */
+
+/* If you happen not to want the image transform support, disable it here */
+#ifndef TRANSFORMS_SUPPORTED
+#define TRANSFORMS_SUPPORTED 1		/* 0 disables transform code */
+#endif
+
+/* Short forms of external names for systems with brain-damaged linkers. */
+
+#ifdef NEED_SHORT_EXTERNAL_NAMES
+#define jtransform_request_workspace		jTrRequest
+#define jtransform_adjust_parameters		jTrAdjust
+#define jtransform_execute_transformation	jTrExec
+#define jcopy_markers_setup			jCMrkSetup
+#define jcopy_markers_execute			jCMrkExec
+#endif /* NEED_SHORT_EXTERNAL_NAMES */
+
+
+/*
+ * Codes for supported types of image transformations.
+ */
+
+typedef enum {
+	JXFORM_NONE,		/* no transformation */
+	JXFORM_FLIP_H,		/* horizontal flip */
+	JXFORM_FLIP_V,		/* vertical flip */
+	JXFORM_TRANSPOSE,	/* transpose across UL-to-LR axis */
+	JXFORM_TRANSVERSE,	/* transpose across UR-to-LL axis */
+	JXFORM_ROT_90,		/* 90-degree clockwise rotation */
+	JXFORM_ROT_180,		/* 180-degree rotation */
+	JXFORM_ROT_270		/* 270-degree clockwise (or 90 ccw) */
+} JXFORM_CODE;
+
+/*
+ * Although rotating and flipping data expressed as DCT coefficients is not
+ * hard, there is an asymmetry in the JPEG format specification for images
+ * whose dimensions aren't multiples of the iMCU size.  The right and bottom
+ * image edges are padded out to the next iMCU boundary with junk data; but
+ * no padding is possible at the top and left edges.  If we were to flip
+ * the whole image including the pad data, then pad garbage would become
+ * visible at the top and/or left, and real pixels would disappear into the
+ * pad margins --- perhaps permanently, since encoders & decoders may not
+ * bother to preserve DCT blocks that appear to be completely outside the
+ * nominal image area.  So, we have to exclude any partial iMCUs from the
+ * basic transformation.
+ *
+ * Transpose is the only transformation that can handle partial iMCUs at the
+ * right and bottom edges completely cleanly.  flip_h can flip partial iMCUs
+ * at the bottom, but leaves any partial iMCUs at the right edge untouched.
+ * Similarly flip_v leaves any partial iMCUs at the bottom edge untouched.
+ * The other transforms are defined as combinations of these basic transforms
+ * and process edge blocks in a way that preserves the equivalence.
+ *
+ * The "trim" option causes untransformable partial iMCUs to be dropped;
+ * this is not strictly lossless, but it usually gives the best-looking
+ * result for odd-size images.  Note that when this option is active,
+ * the expected mathematical equivalences between the transforms may not hold.
+ * (For example, -rot 270 -trim trims only the bottom edge, but -rot 90 -trim
+ * followed by -rot 180 -trim trims both edges.)
+ *
+ * We also offer a "force to grayscale" option, which simply discards the
+ * chrominance channels of a YCbCr image.  This is lossless in the sense that
+ * the luminance channel is preserved exactly.  It's not the same kind of
+ * thing as the rotate/flip transformations, but it's convenient to handle it
+ * as part of this package, mainly because the transformation routines have to
+ * be aware of the option to know how many components to work on.
+ */
+
+typedef struct {
+  /* Options: set by caller */
+  JXFORM_CODE transform;	/* image transform operator */
+  boolean trim;			/* if TRUE, trim partial MCUs as needed */
+  boolean force_grayscale;	/* if TRUE, convert color image to grayscale */
+
+  /* Internal workspace: caller should not touch these */
+  int num_components;		/* # of components in workspace */
+  jvirt_barray_ptr * workspace_coef_arrays; /* workspace for transformations */
+} jpeg_transform_info;
+
+
+#if TRANSFORMS_SUPPORTED
+
+/* Request any required workspace */
+EXTERN(void) jtransform_request_workspace
+	JPP((j_decompress_ptr srcinfo, jpeg_transform_info *info));
+/* Adjust output image parameters */
+EXTERN(jvirt_barray_ptr *) jtransform_adjust_parameters
+	JPP((j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
+	     jvirt_barray_ptr *src_coef_arrays,
+	     jpeg_transform_info *info));
+/* Execute the actual transformation, if any */
+EXTERN(void) jtransform_execute_transformation
+	JPP((j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
+	     jvirt_barray_ptr *src_coef_arrays,
+	     jpeg_transform_info *info));
+
+#endif /* TRANSFORMS_SUPPORTED */
+
+
+/*
+ * Support for copying optional markers from source to destination file.
+ */
+
+typedef enum {
+	JCOPYOPT_NONE,		/* copy no optional markers */
+	JCOPYOPT_COMMENTS,	/* copy only comment (COM) markers */
+	JCOPYOPT_ALL		/* copy all optional markers */
+} JCOPY_OPTION;
+
+#define JCOPYOPT_DEFAULT  JCOPYOPT_COMMENTS	/* recommended default */
+
+/* Setup decompression object to save desired markers in memory */
+EXTERN(void) jcopy_markers_setup
+	JPP((j_decompress_ptr srcinfo, JCOPY_OPTION option));
+/* Copy markers saved in the given source object to the destination object */
+EXTERN(void) jcopy_markers_execute
+	JPP((j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
+	     JCOPY_OPTION option));
diff --git a/lib/a2jpeg-6b/write-jpeg.c b/lib/a2jpeg-6b/write-jpeg.c
new file mode 100644
index 0000000..3336a24
--- /dev/null
+++ b/lib/a2jpeg-6b/write-jpeg.c
@@ -0,0 +1,47 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <stddef.h>
+#include <string.h>
+#include <errno.h>
+#include <jpeglib.h>
+
+#include "readers.h"
+#include "writers.h"
+#include "misc.h"
+
+#include "write-jpeg.h"
+
+static int jpeg_quality = 75;
+
+int
+jpeg_write(FILE *fp, struct ida_image *img)
+{
+    struct jpeg_compress_struct cinfo;
+    struct jpeg_error_mgr jerr;
+    unsigned char *line;
+    unsigned int i;
+
+    cinfo.err = jpeg_std_error(&jerr);
+    jpeg_create_compress(&cinfo);
+    jpeg_stdio_dest(&cinfo, fp);
+    cinfo.image_width  = img->i.width;
+    cinfo.image_height = img->i.height;
+    if (img->i.dpi) {
+	cinfo.density_unit = 1;
+	cinfo.X_density = img->i.dpi;
+	cinfo.Y_density = img->i.dpi;
+    }
+    cinfo.input_components = 3;
+    cinfo.in_color_space = JCS_RGB;
+    jpeg_set_defaults(&cinfo);
+    jpeg_set_quality(&cinfo, jpeg_quality, TRUE);
+    jpeg_start_compress(&cinfo, TRUE);
+
+    for (i = 0, line = img->data; i < img->i.height; i++, line += img->i.width*3)
+        jpeg_write_scanlines(&cinfo, &line, 1);
+    
+    jpeg_finish_compress(&(cinfo));
+    jpeg_destroy_compress(&(cinfo));
+    return 0;
+}
+
diff --git a/lib/a2jpeg-6b/write-jpeg.h b/lib/a2jpeg-6b/write-jpeg.h
new file mode 100644
index 0000000..b774adc
--- /dev/null
+++ b/lib/a2jpeg-6b/write-jpeg.h
@@ -0,0 +1,24 @@
+/* 
+ * File:   write-jpeg.h
+ * Author: noundou
+ *
+ * Created on January 30, 2011, 1:40 PM
+ */
+
+#ifndef WRITE_JPEG_H
+#define	WRITE_JPEG_H
+
+#ifdef	__cplusplus
+extern "C" {
+#endif
+
+
+int jpeg_write(FILE *fp, struct ida_image *img);
+
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* WRITE_JPEG_H */
+
diff --git a/lib/a2jpeg-6b/writers.c b/lib/a2jpeg-6b/writers.c
new file mode 100644
index 0000000..39e5387
--- /dev/null
+++ b/lib/a2jpeg-6b/writers.c
@@ -0,0 +1,10 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "readers.h"
+#include "writers.h"
+
+/* ----------------------------------------------------------------------- */
+
+LIST_HEAD(writers);
diff --git a/lib/a2jpeg-6b/writers.h b/lib/a2jpeg-6b/writers.h
new file mode 100644
index 0000000..1dde0ba
--- /dev/null
+++ b/lib/a2jpeg-6b/writers.h
@@ -0,0 +1,3 @@
+#include "list.h"
+
+extern struct list_head writers;
diff --git a/lib/a2jpeg/README b/lib/a2jpeg/README
new file mode 100644
index 0000000..76e7464
--- /dev/null
+++ b/lib/a2jpeg/README
@@ -0,0 +1,2 @@
+some source files copyed over from
+The Independent JPEG Group's JPEG software
diff --git a/lib/a2jpeg/dither.c b/lib/a2jpeg/dither.c
new file mode 100644
index 0000000..2eaeb31
--- /dev/null
+++ b/lib/a2jpeg/dither.c
@@ -0,0 +1,193 @@
+/*
+ * ordered dither rotines
+ *
+ * stolen from The GIMP and trimmed for speed
+ *
+ */
+
+#include <stdlib.h>
+#include "dither.h"
+
+#define DITHER_LEVEL 8
+
+void (*dither_line)(unsigned char *, unsigned char *, int, int);
+
+static long     red_mult, green_mult;
+static long     red_dither[256];
+static long     green_dither[256];
+static long     blue_dither[256];
+static long     gray_dither[256];
+
+typedef unsigned long vector[DITHER_LEVEL];
+typedef vector  matrix[DITHER_LEVEL];
+
+#if DITHER_LEVEL == 8
+#define DITHER_MASK 7
+static matrix   DM =
+{
+    {0, 32, 8, 40, 2, 34, 10, 42},
+    {48, 16, 56, 24, 50, 18, 58, 26},
+    {12, 44, 4, 36, 14, 46, 6, 38},
+    {60, 28, 52, 20, 62, 30, 54, 22},
+    {3, 35, 11, 43, 1, 33, 9, 41},
+    {51, 19, 59, 27, 49, 17, 57, 25},
+    {15, 47, 7, 39, 13, 45, 5, 37},
+    {63, 31, 55, 23, 61, 29, 53, 21}
+};
+
+#endif
+
+#if DITHER_LEVEL == 4
+#define DITHER_MASK 3
+static matrix   DM =
+{
+    {0, 8, 2, 10},
+    {12, 4, 14, 6},
+    {3, 11, 1, 9},
+    {15, 7, 13, 5}
+};
+
+#endif
+
+void
+init_dither(int shades_r, int shades_g, int shades_b, int shades_gray)
+{
+    int             i, j;
+    unsigned char   low_shade, high_shade;
+    unsigned short  index;
+    float           red_colors_per_shade;
+    float           green_colors_per_shade;
+    float           blue_colors_per_shade;
+    float           gray_colors_per_shade;
+
+    red_mult = shades_g * shades_b;
+    green_mult = shades_b;
+
+    red_colors_per_shade = 256.0 / (shades_r - 1);
+    green_colors_per_shade = 256.0 / (shades_g - 1);
+    blue_colors_per_shade = 256.0 / (shades_b - 1);
+    gray_colors_per_shade = 256.0 / (shades_gray - 1);
+
+    /* this avoids a shift when checking these values */
+    for (i = 0; i < DITHER_LEVEL; i++)
+	for (j = 0; j < DITHER_LEVEL; j++)
+	    DM[i][j] *= 0x10000;
+
+    /*  setup arrays containing three bytes of information for red, green, & blue  */
+    /*  the arrays contain :
+     *    1st byte:    low end shade value
+     *    2nd byte:    high end shade value
+     *    3rd & 4th bytes:    ordered dither matrix index
+     */
+
+    for (i = 0; i < 256; i++) {
+
+	/*  setup the red information  */
+	{
+	    low_shade = (unsigned char) (i / red_colors_per_shade);
+	    high_shade = low_shade + 1;
+
+	    index = (unsigned short)
+		(((i - low_shade * red_colors_per_shade) / red_colors_per_shade) *
+		 (DITHER_LEVEL * DITHER_LEVEL + 1));
+
+	    low_shade *= red_mult;
+	    high_shade *= red_mult;
+
+	    red_dither[i] = (index << 16) + (high_shade << 8) + (low_shade);
+	}
+
+	/*  setup the green information  */
+	{
+	    low_shade = (unsigned char) (i / green_colors_per_shade);
+	    high_shade = low_shade + 1;
+
+	    index = (unsigned short)
+		(((i - low_shade * green_colors_per_shade) / green_colors_per_shade) *
+		 (DITHER_LEVEL * DITHER_LEVEL + 1));
+
+	    low_shade *= green_mult;
+	    high_shade *= green_mult;
+
+	    green_dither[i] = (index << 16) + (high_shade << 8) + (low_shade);
+	}
+
+	/*  setup the blue information  */
+	{
+	    low_shade = (unsigned char) (i / blue_colors_per_shade);
+	    high_shade = low_shade + 1;
+
+	    index = (unsigned short)
+		(((i - low_shade * blue_colors_per_shade) / blue_colors_per_shade) *
+		 (DITHER_LEVEL * DITHER_LEVEL + 1));
+
+	    blue_dither[i] = (index << 16) + (high_shade << 8) + (low_shade);
+	}
+
+	/*  setup the gray information  */
+	{
+	    low_shade = (unsigned char) (i / gray_colors_per_shade);
+	    high_shade = low_shade + 1;
+
+	    index = (unsigned short)
+		(((i - low_shade * gray_colors_per_shade) / gray_colors_per_shade) *
+		 (DITHER_LEVEL * DITHER_LEVEL + 1));
+
+	    gray_dither[i] = (index << 16) + (high_shade << 8) + (low_shade);
+	}
+    }
+}
+
+void
+dither_line_color(unsigned char *src, unsigned char *dest, int y, int width)
+{
+    register long   a, b;
+    long           *ymod, xmod;
+
+    ymod = DM[y & DITHER_MASK];
+
+    while (width--) {
+	xmod = width & DITHER_MASK;
+
+	b = red_dither[*(src++)];
+	if (ymod[xmod] < b)
+	    b >>= 8;
+
+	a = green_dither[*(src++)];
+	if (ymod[xmod] < a)
+	    a >>= 8;
+	b += a;
+
+	a = blue_dither[*(src++)];
+	if (ymod[xmod] < a)
+	    a >>= 8;
+	b += a;
+
+	*(dest++) = b & 0xff;
+    }
+}
+
+void
+dither_line_gray(unsigned char *src, unsigned char *dest, int y, int width)
+{
+    long           *ymod, xmod;
+    register long   a,g;
+
+    ymod = DM[y & DITHER_MASK];
+
+    while (width--) {
+	xmod = width & DITHER_MASK;
+
+#if 1
+	g = (src[0]*3 + src[1]*6 + src[2]) / 10;
+	a = gray_dither[g];
+	src += 3;
+#else
+	a = gray_dither[*(src++)];
+#endif
+	if (ymod[xmod] < a)
+	    a >>= 8;
+
+	*(dest++) = a & 0xff;
+    }
+}
diff --git a/lib/a2jpeg/dither.h b/lib/a2jpeg/dither.h
new file mode 100644
index 0000000..b209de6
--- /dev/null
+++ b/lib/a2jpeg/dither.h
@@ -0,0 +1,6 @@
+
+extern void (*dither_line)(unsigned char *, unsigned char *, int, int);
+
+void init_dither(int, int, int, int);
+void dither_line_color(unsigned char *, unsigned char *, int, int);
+void dither_line_gray(unsigned char *, unsigned char *, int, int);
diff --git a/lib/a2jpeg/filter.c b/lib/a2jpeg/filter.c
new file mode 100644
index 0000000..283a1fa
--- /dev/null
+++ b/lib/a2jpeg/filter.c
@@ -0,0 +1,495 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <math.h>
+#include <string.h>
+
+#include "readers.h"
+#include "filter.h"
+
+int debug = 0;
+
+/* ----------------------------------------------------------------------- */
+
+static void
+op_grayscale(struct ida_image *src, struct ida_rect *rect,
+	     unsigned char *dst, int line, void *data)
+{
+    unsigned char *scanline;
+    int i,g;
+
+    scanline = src->data + line * src->i.width * 3;
+    memcpy(dst,scanline,src->i.width * 3);
+    if (line < rect->y1 || line >= rect->y2)
+	return;
+    dst      += 3*rect->x1;
+    scanline += 3*rect->x1;
+    for (i = rect->x1; i < rect->x2; i++) {
+	g = (scanline[0]*30 + scanline[1]*59+scanline[2]*11)/100;
+	dst[0] = g;
+	dst[1] = g;
+	dst[2] = g;
+	scanline += 3;
+	dst += 3;
+    }
+}
+
+/* ----------------------------------------------------------------------- */
+
+struct op_3x3_handle {
+    struct op_3x3_parm filter;
+    int *linebuf;
+};
+
+static void*
+op_3x3_init(struct ida_image *src, struct ida_rect *rect,
+	    struct ida_image_info *i, void *parm)
+{
+    struct op_3x3_parm *args = parm;
+    struct op_3x3_handle *h;
+
+    h = malloc(sizeof(*h));
+    memcpy(&h->filter,args,sizeof(*args));
+    h->linebuf = malloc(sizeof(int)*3*(src->i.width));
+
+    *i = src->i;
+    return h;
+}
+
+static int inline
+op_3x3_calc_pixel(struct op_3x3_parm *p, unsigned char *s1,
+		  unsigned char *s2, unsigned char *s3)
+{
+    int val = 0;
+
+    val += p->f1[0] * s1[0];
+    val += p->f1[1] * s1[3];
+    val += p->f1[2] * s1[6];
+    val += p->f2[0] * s2[0];
+    val += p->f2[1] * s2[3];
+    val += p->f2[2] * s2[6];
+    val += p->f3[0] * s3[0];
+    val += p->f3[1] * s3[3];
+    val += p->f3[2] * s3[6];
+    if (p->mul && p->div)
+	val = val * p->mul / p->div;
+    val += p->add;
+    return val;
+}
+
+static void
+op_3x3_calc_line(struct ida_image *src, struct ida_rect *rect,
+		 int *dst, unsigned int line, struct op_3x3_parm *p)
+{
+    unsigned char b1[9],b2[9],b3[9];
+    unsigned char *s1,*s2,*s3;
+    unsigned int i,left,right;
+
+    s1 = src->data + (line-1) * src->i.width * 3;
+    s2 = src->data +  line    * src->i.width * 3;
+    s3 = src->data + (line+1) * src->i.width * 3;
+    if (0 == line)
+	s1 = src->data + line * src->i.width * 3;
+    if (src->i.height-1 == line)
+	s3 = src->data + line * src->i.width * 3;
+
+    left  = rect->x1;
+    right = rect->x2;
+    if (0 == left) {
+	/* left border special case: dup first col */
+	memcpy(b1,s1,3);
+	memcpy(b2,s2,3);
+	memcpy(b3,s3,3);
+	memcpy(b1+3,s1,6);
+	memcpy(b2+3,s2,6);
+	memcpy(b3+3,s3,6);
+	dst[0] = op_3x3_calc_pixel(p,b1,b2,b3);
+	dst[1] = op_3x3_calc_pixel(p,b1+1,b2+1,b3+1);
+	dst[2] = op_3x3_calc_pixel(p,b1+2,b2+2,b3+2);
+	left++;
+    }
+    if (src->i.width == right) {
+	/* right border */
+	memcpy(b1,s1+src->i.width*3-6,6);
+	memcpy(b2,s2+src->i.width*3-6,6);
+	memcpy(b3,s3+src->i.width*3-6,6);
+	memcpy(b1+3,s1+src->i.width*3-3,3);
+	memcpy(b2+3,s2+src->i.width*3-3,3);
+	memcpy(b3+3,s3+src->i.width*3-3,3);
+	dst[src->i.width*3-3] = op_3x3_calc_pixel(p,b1,b2,b3);
+	dst[src->i.width*3-2] = op_3x3_calc_pixel(p,b1+1,b2+1,b3+1);
+	dst[src->i.width*3-1] = op_3x3_calc_pixel(p,b1+2,b2+2,b3+2);
+	right--;
+    }
+    
+    dst += 3*left;
+    s1  += 3*(left-1);
+    s2  += 3*(left-1);
+    s3  += 3*(left-1);
+    for (i = left; i < right; i++) {
+	dst[0] = op_3x3_calc_pixel(p,s1++,s2++,s3++);
+	dst[1] = op_3x3_calc_pixel(p,s1++,s2++,s3++);
+	dst[2] = op_3x3_calc_pixel(p,s1++,s2++,s3++);
+	dst += 3;
+    }
+}
+
+static void
+op_3x3_clip_line(unsigned char *dst, int *src, int left, int right)
+{
+    int i,val;
+
+    src += left*3;
+    dst += left*3;
+    for (i = left*3; i < right*3; i++) {
+	val = *(src++);
+	if (val < 0)
+	    val = 0;
+	if (val > 255)
+	    val = 255;
+	*(dst++) = val;
+    }
+}
+
+static void
+op_3x3_work(struct ida_image *src, struct ida_rect *rect,
+	    unsigned char *dst, int line, void *data)
+{
+    struct op_3x3_handle *h = data;
+    unsigned char *scanline;
+
+    scanline = src->data + line * src->i.width * 3;
+    memcpy(dst,scanline,src->i.width * 3);
+    if (line < rect->y1 || line >= rect->y2)
+	return;
+
+    op_3x3_calc_line(src,rect,h->linebuf,line,&h->filter);
+    op_3x3_clip_line(dst,h->linebuf,rect->x1,rect->x2);
+}
+
+static void
+op_3x3_free(void *data)
+{
+    struct op_3x3_handle *h = data;
+
+    free(h->linebuf);
+    free(h);
+}
+	    
+/* ----------------------------------------------------------------------- */
+
+struct op_sharpe_handle {
+    int  factor;
+    int  *linebuf;
+};
+
+static void*
+op_sharpe_init(struct ida_image *src, struct ida_rect *rect,
+	       struct ida_image_info *i, void *parm)
+{
+    struct op_sharpe_parm *args = parm;
+    struct op_sharpe_handle *h;
+
+    h = malloc(sizeof(*h));
+    h->factor  = args->factor;
+    h->linebuf = malloc(sizeof(int)*3*(src->i.width));
+
+    *i = src->i;
+    return h;
+}
+
+static void
+op_sharpe_work(struct ida_image *src, struct ida_rect *rect,
+	       unsigned char *dst, int line, void *data)
+{
+    static struct op_3x3_parm laplace = {
+	f1: {  1,  1,  1 },
+	f2: {  1, -8,  1 },
+	f3: {  1,  1,  1 },
+    };
+    struct op_sharpe_handle *h = data;
+    unsigned char *scanline;
+    int i;
+
+    scanline = src->data + line * src->i.width * 3;
+    memcpy(dst,scanline,src->i.width * 3);
+    if (line < rect->y1 || line >= rect->y2)
+	return;
+
+    op_3x3_calc_line(src,rect,h->linebuf,line,&laplace);
+    for (i = rect->x1*3; i < rect->x2*3; i++)
+	h->linebuf[i] = scanline[i] - h->linebuf[i] * h->factor / 256;
+    op_3x3_clip_line(dst,h->linebuf,rect->x1,rect->x2);
+}
+
+static void
+op_sharpe_free(void *data)
+{
+    struct op_sharpe_handle *h = data;
+
+    free(h->linebuf);
+    free(h);
+}
+
+/* ----------------------------------------------------------------------- */
+
+struct op_resize_state {
+    float xscale,yscale,inleft;
+    float *rowbuf;
+    unsigned int width,height,srcrow;
+};
+
+static void*
+op_resize_init(struct ida_image *src, struct ida_rect *rect,
+	       struct ida_image_info *i, void *parm)
+{
+    struct op_resize_parm *args = parm;
+    struct op_resize_state *h;
+
+    h = malloc(sizeof(*h));
+    h->width  = args->width;
+    h->height = args->height;
+    h->xscale = (float)args->width/src->i.width;
+    h->yscale = (float)args->height/src->i.height;
+    h->rowbuf = malloc(src->i.width * 3 * sizeof(float));
+    h->srcrow = 0;
+    h->inleft = 1;
+
+    *i = src->i;
+    i->width  = args->width;
+    i->height = args->height;
+    i->dpi    = args->dpi;
+    return h;
+}
+
+static void
+op_resize_work(struct ida_image *src, struct ida_rect *rect,
+	       unsigned char *dst, int line, void *data)
+{
+    struct op_resize_state *h = data;
+    float outleft,left,weight,d0,d1,d2;
+    unsigned char *csrcline;
+    float *fsrcline;
+    unsigned int i,sx,dx;
+
+    /* scale y */
+    memset(h->rowbuf, 0, src->i.width * 3 * sizeof(float));
+    outleft = 1/h->yscale;
+    while (outleft > 0  &&  h->srcrow < src->i.height) {
+	if (outleft < h->inleft) {
+	    weight     = outleft * h->yscale;
+	    h->inleft -= outleft;
+	    outleft    = 0;
+	} else {
+	    weight     = h->inleft * h->yscale;
+	    outleft   -= h->inleft;
+	    h->inleft  = 0;
+	}
+#if 0
+	if (debug)
+	    fprintf(stderr,"y:  %6.2f%%: %d/%d => %d/%d\n",
+		    weight*100,h->srcrow,src->height,line,h->height);
+#endif
+	csrcline = src->data + h->srcrow * src->i.width * 3;
+	for (i = 0; i < src->i.width * 3; i++)
+	    h->rowbuf[i] += (float)csrcline[i] * weight;
+	if (0 == h->inleft) {
+	    h->inleft = 1;
+	    h->srcrow++;
+	}
+    }
+
+    /* scale x */
+    left = 1;
+    fsrcline = h->rowbuf;
+    for (sx = 0, dx = 0; dx < h->width; dx++) {
+	d0 = d1 = d2 = 0;
+	outleft = 1/h->xscale;
+	while (outleft > 0  &&  dx < h->width  &&  sx < src->i.width) {
+	    if (outleft < left) {
+		weight   = outleft * h->xscale;
+		left    -= outleft;
+		outleft  = 0;
+	    } else {
+		weight   = left * h->xscale;
+		outleft -= left;
+		left     = 0;
+	    }
+#if 0
+	    if (debug)
+		fprintf(stderr," x: %6.2f%%: %d/%d => %d/%d\n",
+			weight*100,sx,src->width,dx,h->width);
+#endif
+	    d0 += fsrcline[3*sx+0] * weight;
+	    d1 += fsrcline[3*sx+1] * weight;
+	    d2 += fsrcline[3*sx+2] * weight;
+	    if (0 == left) {
+		left = 1;
+		sx++;
+	    }
+	}
+	dst[0] = d0;
+	dst[1] = d1;
+	dst[2] = d2;
+	dst += 3;
+    }
+}
+
+static void
+op_resize_done(void *data)
+{
+    struct op_resize_state *h = data;
+
+    free(h->rowbuf);
+    free(h);
+}
+    
+/* ----------------------------------------------------------------------- */
+
+struct op_rotate_state {
+    float angle,sina,cosa;
+    struct ida_rect calc;
+    int cx,cy;
+};
+
+static void*
+op_rotate_init(struct ida_image *src, struct ida_rect *rect,
+	       struct ida_image_info *i, void *parm)
+{
+    struct op_rotate_parm *args = parm;
+    struct op_rotate_state *h;
+    float  diag;
+
+    h = malloc(sizeof(*h));
+    h->angle = args->angle * 2 * M_PI / 360;
+    h->sina  = sin(h->angle);
+    h->cosa  = cos(h->angle);
+    h->cx    = (rect->x2 - rect->x1) / 2 + rect->x1;
+    h->cy    = (rect->y2 - rect->y1) / 2 + rect->y1;
+
+    /* the area we have to process (worst case: 45°) */
+    diag     = sqrt((rect->x2 - rect->x1)*(rect->x2 - rect->x1) +
+		    (rect->y2 - rect->y1)*(rect->y2 - rect->y1))/2;
+    h->calc.x1 = h->cx - diag;
+    h->calc.x2 = h->cx + diag;
+    h->calc.y1 = h->cy - diag;
+    h->calc.y2 = h->cy + diag;
+    if (h->calc.x1 < 0)
+	h->calc.x1 = 0;
+    if (h->calc.x2 > src->i.width)
+	h->calc.x2 = src->i.width;
+    if (h->calc.y1 < 0)
+	h->calc.y1 = 0;
+    if (h->calc.y2 > src->i.height)
+	h->calc.y2 = src->i.height;
+
+    *i = src->i;
+    return h;
+}
+
+static inline
+unsigned char* op_rotate_getpixel(struct ida_image *src, struct ida_rect *rect,
+				  int sx, int sy, int dx, int dy)
+{
+    static unsigned char black[] = { 0, 0, 0};
+
+    if (sx < rect->x1 || sx >= rect->x2 ||
+	sy < rect->y1 || sy >= rect->y2) {
+	if (dx < rect->x1 || dx >= rect->x2 ||
+	    dy < rect->y1 || dy >= rect->y2)
+	    return src->data + dy * src->i.width * 3 + dx * 3;
+	return black;
+    }
+    return src->data + sy * src->i.width * 3 + sx * 3;
+}
+
+static void
+op_rotate_work(struct ida_image *src, struct ida_rect *rect,
+	       unsigned char *dst, int y, void *data)
+{
+    struct op_rotate_state *h = data;
+    unsigned char *pix;
+    float fx,fy,w;
+    int x,sx,sy;
+
+    pix = src->data + y * src->i.width * 3;
+    memcpy(dst,pix,src->i.width * 3);
+    if (y < h->calc.y1 || y >= h->calc.y2)
+	return;
+
+    dst += 3*h->calc.x1;
+    memset(dst, 0, (h->calc.x2-h->calc.x1) * 3);
+    for (x = h->calc.x1; x < h->calc.x2; x++, dst+=3) {
+	fx = h->cosa * (x - h->cx) - h->sina * (y - h->cy) + h->cx;
+	fy = h->sina * (x - h->cx) + h->cosa * (y - h->cy) + h->cy;
+	sx = (int)fx;
+	sy = (int)fy;
+	if (fx < 0)
+	    sx--;
+	if (fy < 0)
+	    sy--;
+	fx -= sx;
+	fy -= sy;
+
+	pix = op_rotate_getpixel(src,rect,sx,sy,x,y);
+	w = (1-fx) * (1-fy);
+	dst[0] += pix[0] * w;
+	dst[1] += pix[1] * w;
+	dst[2] += pix[2] * w;
+	pix = op_rotate_getpixel(src,rect,sx+1,sy,x,y);
+	w = fx * (1-fy);
+	dst[0] += pix[0] * w;
+	dst[1] += pix[1] * w;
+	dst[2] += pix[2] * w;
+	pix = op_rotate_getpixel(src,rect,sx,sy+1,x,y);
+	w = (1-fx) * fy;
+	dst[0] += pix[0] * w;
+	dst[1] += pix[1] * w;
+	dst[2] += pix[2] * w;
+	pix = op_rotate_getpixel(src,rect,sx+1,sy+1,x,y);
+	w = fx * fy;
+	dst[0] += pix[0] * w;
+	dst[1] += pix[1] * w;
+	dst[2] += pix[2] * w;
+    }
+}
+
+static void
+op_rotate_done(void *data)
+{
+    struct op_rotate_state *h = data;
+
+    free(h);
+}
+
+/* ----------------------------------------------------------------------- */
+
+struct ida_op desc_grayscale = {
+    name:  "grayscale",
+    init:  op_none_init,
+    work:  op_grayscale,
+    done:  op_none_done,
+};
+struct ida_op desc_3x3 = {
+    name:  "3x3",
+    init:  op_3x3_init,
+    work:  op_3x3_work,
+    done:  op_3x3_free,
+};
+struct ida_op desc_sharpe = {
+    name:  "sharpe",
+    init:  op_sharpe_init,
+    work:  op_sharpe_work,
+    done:  op_sharpe_free,
+};
+struct ida_op desc_resize = {
+    name:  "resize",
+    init:  op_resize_init,
+    work:  op_resize_work,
+    done:  op_resize_done,
+};
+struct ida_op desc_rotate = {
+    name:  "rotate",
+    init:  op_rotate_init,
+    work:  op_rotate_work,
+    done:  op_rotate_done,
+};
diff --git a/lib/a2jpeg/filter.h b/lib/a2jpeg/filter.h
new file mode 100644
index 0000000..37d67ee
--- /dev/null
+++ b/lib/a2jpeg/filter.h
@@ -0,0 +1,27 @@
+
+struct op_3x3_parm {
+    int f1[3];
+    int f2[3];
+    int f3[3];
+    int mul,div,add;
+};
+
+struct op_sharpe_parm {
+    int factor;
+};
+
+struct op_resize_parm {
+    int width;
+    int height;
+    int dpi;
+};
+
+struct op_rotate_parm {
+    int angle;
+};
+
+extern struct ida_op desc_grayscale;
+extern struct ida_op desc_3x3;
+extern struct ida_op desc_sharpe;
+extern struct ida_op desc_resize;
+extern struct ida_op desc_rotate;
diff --git a/lib/a2jpeg/genthumbnail.c b/lib/a2jpeg/genthumbnail.c
new file mode 100644
index 0000000..aabe64e
--- /dev/null
+++ b/lib/a2jpeg/genthumbnail.c
@@ -0,0 +1,295 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <stddef.h>
+#include <unistd.h>
+#include <errno.h>
+#include <string.h>
+
+#include <jpeglib.h>
+//#include "transupp.h"		/* Support routines for jpegtran */
+#include "jpegtools.h"
+
+#include "misc.h"
+
+#include "readers.h"
+#include "filter.h"
+#include "genthumbnail.h"
+
+/* ---------------------------------------------------------------------- */
+
+struct ida_image*
+read_jpeg(char *filename)
+{
+    struct ida_image *img;
+    FILE *fp;
+    unsigned int y;
+    void *data;
+    
+    /* open file */
+    if (NULL == (fp = fopen(filename, "r"))) {
+	fprintf(stderr,"open %s: %s\n",filename,strerror(errno));
+	return NULL;
+    }
+
+    /* load image */
+    img = malloc(sizeof(*img));
+    memset(img,0,sizeof(*img));
+    data = jpeg_loader.init(fp,filename,0,&img->i,0);
+    if (NULL == data) {
+	fprintf(stderr,"loading %s [%s] FAILED\n",filename,jpeg_loader.name);
+	free(img);
+	return NULL;
+    }
+    img->data = malloc(img->i.width * img->i.height * 3);
+    for (y = 0; y < img->i.height; y++)
+  	jpeg_loader.read(img->data + img->i.width * 3 * y, y, data);
+    jpeg_loader.done(data);
+    return img;
+}
+
+
+/* ---------------------------------------------------------------------- */
+
+struct ida_image*
+a2_scale_thumbnail(struct ida_image *src, int scale_h, int scale_w)
+{
+    struct op_resize_parm p;
+    struct ida_rect  rect;
+    struct ida_image *dest;
+    void *data;
+    unsigned int y;
+    float xs,ys;
+
+    dest = malloc(sizeof(*dest));
+    memset(dest,0,sizeof(*dest));
+    memset(&rect,0,sizeof(rect));
+    memset(&p,0,sizeof(p));
+
+    p.width  = src->i.width  * scale_w;
+    p.height = src->i.height * scale_h;
+    p.dpi    = src->i.dpi;
+    if (0 == p.width)
+	p.width = 1;
+    if (0 == p.height)
+	p.height = 1;
+
+    data = desc_resize.init(src,&rect,&dest->i,&p);
+    dest->data = malloc(dest->i.width * dest->i.height * 3);
+    for (y = 0; y < dest->i.height; y++)
+	desc_resize.work(src,&rect,
+			 dest->data + 3 * dest->i.width * y,
+			 y, data);
+    desc_resize.done(data);
+    return dest;
+}
+
+/* ---------------------------------------------------------------------- */
+
+struct ida_image*
+scale_thumbnail(struct ida_image *src, int max)
+{
+    struct op_resize_parm p;
+    struct ida_rect  rect;
+    struct ida_image *dest;
+    void *data;
+    unsigned int y;
+    float xs,ys,scale;
+    
+    xs = (float)max / src->i.width;
+    ys = (float)max / src->i.height;
+    scale = (xs < ys) ? xs : ys;
+
+    float scale_w = (float)max / src->i.width;
+    float scale_h = (float)max / src->i.height;
+
+    dest = malloc(sizeof(*dest));
+    memset(dest,0,sizeof(*dest));
+    memset(&rect,0,sizeof(rect));
+    memset(&p,0,sizeof(p));
+    
+    p.width  = src->i.width  * scale_w;
+    p.height = src->i.height * scale_h;
+    p.dpi    = src->i.dpi;
+    if (0 == p.width)
+	p.width = 1;
+    if (0 == p.height)
+	p.height = 1;
+    
+    data = desc_resize.init(src,&rect,&dest->i,&p);
+    dest->data = malloc(dest->i.width * dest->i.height * 3);
+    for (y = 0; y < dest->i.height; y++)
+	desc_resize.work(src,&rect,
+			 dest->data + 3 * dest->i.width * y,
+			 y, data);
+    desc_resize.done(data);
+    return dest;
+}
+
+/* ---------------------------------------------------------------------- */
+
+struct ida_image*
+ece459_scale_thumbnail(struct ida_image *src, int max)
+{
+    struct op_resize_parm p;
+    struct ida_rect  rect;
+    struct ida_image *dest;
+    void *data;
+    unsigned int y;
+
+    float scale_w = (float)max / src->i.width;
+    float scale_h = (float)max / src->i.height;
+
+    dest = malloc(sizeof(*dest));
+    memset(dest,0,sizeof(*dest));
+    memset(&rect,0,sizeof(rect));
+    memset(&p,0,sizeof(p));
+
+    p.width  = src->i.width  * scale_w;
+    p.height = src->i.height * scale_h;
+    p.dpi    = src->i.dpi;
+    if (0 == p.width)
+	p.width = 1;
+    if (0 == p.height)
+	p.height = 1;
+
+    data = desc_resize.init(src,&rect,&dest->i,&p);
+    dest->data = malloc(dest->i.width * dest->i.height * 3);
+    for (y = 0; y < dest->i.height; y++)
+	desc_resize.work(src,&rect,
+			 dest->data + 3 * dest->i.width * y,
+			 y, data);
+    desc_resize.done(data);
+    return dest;
+}
+
+/* ---------------------------------------------------------------------- */
+
+struct thc {
+    struct jpeg_compress_struct dst;
+    struct jpeg_error_mgr err;
+    unsigned char *out;
+    int osize;
+};
+
+static void thc_dest_init(struct jpeg_compress_struct *cinfo)
+{
+    struct thc *h  = container_of(cinfo, struct thc, dst);
+    cinfo->dest->next_output_byte = h->out;
+    cinfo->dest->free_in_buffer   = h->osize;
+}
+
+static boolean thc_dest_flush(struct jpeg_compress_struct *cinfo)
+{
+    fprintf(stderr,"jpeg: panic: output buffer full\n");
+    exit(1);
+}
+
+static void thc_dest_term(struct jpeg_compress_struct *cinfo)
+{
+    struct thc *h  = container_of(cinfo, struct thc, dst);
+    h->osize -= cinfo->dest->free_in_buffer;
+}
+
+static struct jpeg_destination_mgr thumbnail_dst = {
+    .init_destination    = thc_dest_init,
+    .empty_output_buffer = thc_dest_flush,
+    .term_destination    = thc_dest_term,
+};
+
+int
+compress_thumbnail(struct ida_image *img, char *dest, int max)
+{
+    struct thc thc;
+    unsigned char *line;
+    unsigned int i;
+
+    memset(&thc,0,sizeof(thc));
+    thc.dst.err = jpeg_std_error(&thc.err);
+    jpeg_create_compress(&thc.dst);
+    thc.dst.dest = &thumbnail_dst;
+    thc.out = dest;
+    thc.osize = max;
+
+    thc.dst.image_width  = img->i.width;
+    thc.dst.image_height = img->i.height;
+    thc.dst.input_components = 3;
+    thc.dst.in_color_space = JCS_RGB;
+    jpeg_set_defaults(&thc.dst);
+    jpeg_start_compress(&thc.dst, TRUE);
+
+    for (i = 0, line = img->data; i < img->i.height; i++, line += img->i.width*3)
+        jpeg_write_scanlines(&thc.dst, &line, 1);
+    
+    jpeg_finish_compress(&(thc.dst));
+    jpeg_destroy_compress(&(thc.dst));
+
+    return thc.osize;
+}
+
+/* ---------------------------------------------------------------------- */
+
+int create_thumbnail(char *filename, unsigned char *dest, int max)
+{
+    struct ida_image *img,*thumb;
+    int size;
+
+    //fprintf(stderr,"%s: read ",filename);
+    img = read_jpeg(filename);
+    if (!img) {
+	fprintf(stderr,"FAILED\n");
+	return -1;
+    }
+    
+    //fprintf(stderr,"scale ");
+    thumb = scale_thumbnail(img,160);
+    if (!thumb) {
+	free(img->data);
+	free(img);
+	fprintf(stderr,"FAILED\n");
+	return -1;
+    }
+
+    //fprintf(stderr,"compress ");
+    size = compress_thumbnail(thumb,dest,max);
+
+    /* cleanup */
+    free(img->data);
+    free(img);
+    free(thumb->data);
+    free(thumb);
+    return size;
+}
+
+/* ---------------------------------------------------------------------- */
+
+#if 0
+
+#define THUMB_MAX 65536
+
+static int handle_image(char *filename)
+{
+    char *dest;
+    int size;
+
+    dest = malloc(THUMB_MAX);
+    size = create_thumbnail(filename,dest,THUMB_MAX);
+
+    fprintf(stderr,"transform ");
+    jpeg_transform_inplace(filename, JXFORM_NONE, NULL,
+			   dest, size, JFLAG_UPDATE_THUMBNAIL);
+
+    fprintf(stderr,"done\n");
+    return 0;
+}
+
+int main(int argc, char *argv[])
+{
+    int i;
+
+    for (i = 1; i < argc; i++)
+	handle_image(argv[i]);
+    return 0;
+}
+
+#endif
+
diff --git a/lib/a2jpeg/genthumbnail.h b/lib/a2jpeg/genthumbnail.h
new file mode 100644
index 0000000..fa0c2ed
--- /dev/null
+++ b/lib/a2jpeg/genthumbnail.h
@@ -0,0 +1,11 @@
+int create_thumbnail(char *filename, unsigned char *dest, int max);
+
+//Scale image to (max x max)
+struct ida_image* ece459_scale_thumbnail(struct ida_image *src, int max);
+
+struct ida_image* scale_thumbnail(struct ida_image *src, int max);
+
+int compress_thumbnail(struct ida_image *img, char *dest, int max);
+
+struct ida_image* read_jpeg(char *filename);
+
diff --git a/lib/a2jpeg/ida.c b/lib/a2jpeg/ida.c
new file mode 100644
index 0000000..65e1d0a
--- /dev/null
+++ b/lib/a2jpeg/ida.c
@@ -0,0 +1,1909 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <errno.h>
+#include <signal.h>
+#include <locale.h>
+#include <langinfo.h>
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/wait.h>
+
+#include <X11/Intrinsic.h>
+#include <X11/StringDefs.h>
+#include <Xm/Xm.h>
+#include <Xm/Primitive.h>
+#include <Xm/Label.h>
+#include <Xm/CascadeB.h>
+#include <Xm/PushB.h>
+#include <Xm/Separator.h>
+#include <Xm/RowColumn.h>
+#include <Xm/ScrolledW.h>
+#include <Xm/Protocols.h>
+#include <Xm/List.h>
+#include <Xm/Form.h>
+#include <Xm/MessageB.h>
+#include <Xm/SelectioB.h>
+#include <Xm/Scale.h>
+#include <Xm/Text.h>
+#include <Xm/FileSB.h>
+#include <Xm/ToggleB.h>
+#include <Xm/DrawingA.h>
+#include <Xm/Transfer.h>
+#include <Xm/TransferP.h>
+
+#include "RegEdit.h"
+#include "ida.h"
+#include "x11.h"
+#include "man.h"
+#include "readers.h"
+#include "writers.h"
+#include "viewer.h"
+#include "op.h"
+#include "lut.h"
+#include "filter.h"
+#include "color.h"
+#include "icons.h"
+#include "browser.h"
+#include "filelist.h"
+#include "xdnd.h"
+#include "selections.h"
+#include "sane.h"
+#include "curl.h"
+#include "idaconfig.h"
+
+/* ---------------------------------------------------------------------- */
+
+static void popup_ac(Widget, XEvent*, String*, Cardinal*);
+static void exit_ac(Widget, XEvent*, String*, Cardinal*);
+static void next_ac(Widget, XEvent*, String*, Cardinal*);
+static void prev_ac(Widget, XEvent*, String*, Cardinal*);
+static void next_page_ac(Widget, XEvent*, String*, Cardinal*);
+static void prev_page_ac(Widget, XEvent*, String*, Cardinal*);
+static void zoom_ac(Widget, XEvent*, String*, Cardinal*);
+static void scroll_ac(Widget, XEvent*, String*, Cardinal*);
+static void debug_ac(Widget, XEvent*, String*, Cardinal*);
+static void load_ac(Widget, XEvent*, String*, Cardinal*);
+static void save_ac(Widget, XEvent*, String*, Cardinal*);
+static void scan_ac(Widget, XEvent*, String*, Cardinal*);
+static void print_ac(Widget, XEvent*, String*, Cardinal*);
+
+static void undo_ac(Widget, XEvent*, String*, Cardinal*);
+static void filter_ac(Widget, XEvent*, String*, Cardinal*);
+static void gamma_ac(Widget, XEvent*, String*, Cardinal*);
+static void bright_ac(Widget, XEvent*, String*, Cardinal*);
+static void contrast_ac(Widget, XEvent*, String*, Cardinal*);
+static void color_ac(Widget, XEvent*, String*, Cardinal*);
+static void f3x3_ac(Widget, XEvent*, String*, Cardinal*);
+static void resize_ac(Widget, XEvent*, String*, Cardinal*);
+static void rotate_ac(Widget, XEvent*, String*, Cardinal*);
+static void sharpe_ac(Widget, XEvent*, String*, Cardinal*);
+
+static XtActionsRec actionTable[] = {
+    { "Exit",     exit_ac      },
+    { "Next",     next_ac      },
+    { "Prev",     prev_ac      },
+    { "NextPage", next_page_ac },
+    { "PrevPage", prev_page_ac },
+    { "Zoom",     zoom_ac      },
+    { "Scroll",   scroll_ac    },
+    { "Debug",    debug_ac     },
+    { "Popup",    popup_ac     },
+    { "Man",      man_action   },
+    { "Load",     load_ac      },
+    { "Save",     save_ac      },
+    { "Scan",     scan_ac      },
+    { "Print",    print_ac     },
+    { "Browser",  browser_ac   },
+    { "Filelist", filelist_ac  },
+
+    { "Undo",     undo_ac      },
+    { "Filter",   filter_ac    },
+    { "Gamma",    gamma_ac     },
+    { "Bright",   bright_ac    },
+    { "Contrast", contrast_ac  },
+    { "Color",    color_ac     },
+    { "F3x3",     f3x3_ac      },
+    { "Resize",   resize_ac    },
+    { "Rotate",   rotate_ac    },
+    { "Sharpe",   sharpe_ac    },
+
+    { "Ipc",      ipc_ac       },
+    { "Xdnd",     XdndAction   },
+};
+
+/* ---------------------------------------------------------------------- */
+
+XtAppContext       app_context;
+Display            *dpy;
+Widget             app_shell;
+int                gray=0;
+char               *binary;
+struct ida_viewer  *ida;
+
+/* ---------------------------------------------------------------------- */
+
+struct ARGS args;
+unsigned int pcd_res;
+unsigned int sane_res;
+
+XtResource args_desc[] = {
+    {
+	"debug",
+	XtCBoolean, XtRBoolean, sizeof(Boolean),
+	XtOffset(struct ARGS*,debug),
+	XtRString, "false"
+    },{
+	"help",
+	XtCBoolean, XtRBoolean, sizeof(Boolean),
+	XtOffset(struct ARGS*,help),
+	XtRString, "false"
+    },{
+	"testload",
+	XtCBoolean, XtRBoolean, sizeof(Boolean),
+	XtOffset(struct ARGS*,testload),
+	XtRString, "false"
+    }
+};
+const int args_count = XtNumber(args_desc);
+
+XrmOptionDescRec opt_desc[] = {
+    { "-d",          "debug",       XrmoptionNoArg,  "true" },
+    { "-debug",      "debug",       XrmoptionNoArg,  "true" },
+    { "-testload",   "testload",    XrmoptionNoArg,  "true" },
+    { "-h",          "help",        XrmoptionNoArg,  "true" },
+    { "-help",       "help",        XrmoptionNoArg,  "true" },
+    { "--help",      "help",        XrmoptionNoArg,  "true" },
+};
+const int opt_count = (sizeof(opt_desc)/sizeof(XrmOptionDescRec));
+
+static String fallback_ressources[] = {
+#include "Ida.ad.h"
+    NULL
+};
+
+/* ---------------------------------------------------------------------- */
+
+static struct ida_writer *cwriter;
+static char *save_filename;
+static char *print_command;
+
+static Widget control_shell,status;
+static Atom   wm_delete_window;
+
+static Widget view,loadbox,savebox,printbox;
+
+/* file list */
+static Widget wlist;
+static char **files = NULL;
+static int  cfile   = -1;
+static int  nfiles  = 0;
+static int  cpage   = 0;
+static int  npages  = 1;
+
+/* filter controls */
+static int gamma_val    = 100;
+static int bright_val   = 0;
+static int contrast_val = 0;
+static int rotate_val   = 0;
+static int sharpe_val   = 10;
+
+static struct MY_TOPLEVELS {
+    char        *name;
+    Widget      *shell;
+    int         mapped;
+} my_toplevels [] = {
+    { "control",   &control_shell },
+};
+#define TOPLEVELS (sizeof(my_toplevels)/sizeof(struct MY_TOPLEVELS))
+
+/* ---------------------------------------------------------------------- */
+
+static void
+popup_ac(Widget widget, XEvent *event,
+	 String *params, Cardinal *num_params)
+{
+    unsigned int i;
+
+    /* which window we are talking about ? */
+    if (*num_params > 0) {
+	for (i = 0; i < TOPLEVELS; i++) {
+	    if (0 == strcasecmp(my_toplevels[i].name,params[0]))
+		break;
+	}
+	if (i == TOPLEVELS) {
+	    fprintf(stderr,"PopupAction: oops: shell not found (name=%s)\n",
+		    params[0]);
+	    return;
+	}
+    } else {
+	for (i = 0; i < TOPLEVELS; i++) {
+	    if (*(my_toplevels[i].shell) == widget)
+		break;
+	}
+	if (i == TOPLEVELS) {
+	    fprintf(stderr,"PopupAction: oops: shell not found (%p:%s)\n",
+		    widget,XtName(widget));
+	    return;
+	}
+    }
+
+    /* popup/down window */
+    if (!my_toplevels[i].mapped) {
+	XtPopup(*(my_toplevels[i].shell), XtGrabNone);
+	my_toplevels[i].mapped = 1;
+    } else {
+	XtPopdown(*(my_toplevels[i].shell));
+	my_toplevels[i].mapped = 0;
+    }
+}
+
+static void
+popupdown_cb(Widget widget, XtPointer clientdata, XtPointer call_data)
+{
+    int i = 0;
+    popup_ac(clientdata, NULL, NULL, &i);
+}
+
+/* ---------------------------------------------------------------------- */
+
+void
+destroy_cb(Widget widget, XtPointer clientdata, XtPointer call_data)
+{
+    XtDestroyWidget(clientdata);
+}
+
+void
+action_cb(Widget widget, XtPointer clientdata, XtPointer call_data)
+{
+    char *calls, *action, *argv[16]; /* max: F3x3(9 args) */
+    int argc;
+
+    calls = strdup(clientdata);
+    action = strtok(calls,"(),");
+    for (argc = 0; NULL != (argv[argc] = strtok(NULL,"(),")); argc++)
+	/* nothing */;
+    XtCallActionProc(widget,action,NULL,argv,argc);
+    free(calls);
+}
+
+static void
+about_cb(Widget widget, XtPointer clientdata, XtPointer call_data)
+{
+    Widget msgbox;
+    
+    msgbox = XmCreateInformationDialog(app_shell,"aboutbox",NULL,0);
+    XtUnmanageChild(XmMessageBoxGetChild(msgbox,XmDIALOG_HELP_BUTTON));
+    XtUnmanageChild(XmMessageBoxGetChild(msgbox,XmDIALOG_CANCEL_BUTTON));
+    XtAddCallback(msgbox,XmNokCallback,destroy_cb,msgbox);
+    XtManageChild(msgbox);
+}
+
+#if 0
+static void
+sorry_cb(Widget widget, XtPointer clientdata, XtPointer call_data)
+{
+    Widget msgbox;
+    
+    msgbox = XmCreateErrorDialog(app_shell,"sorrybox",NULL,0);
+    XtUnmanageChild(XmMessageBoxGetChild(msgbox,XmDIALOG_HELP_BUTTON));
+    XtUnmanageChild(XmMessageBoxGetChild(msgbox,XmDIALOG_CANCEL_BUTTON));
+    XtAddCallback(msgbox,XmNokCallback,destroy_cb,msgbox);
+    XtManageChild(msgbox);
+}
+#endif
+
+void
+debug_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
+{
+    unsigned int i;
+
+    fprintf(stderr,"Debug:");
+    for (i = 0; i < *num; i++)
+	fprintf(stderr," %s",params[i]);
+    fprintf(stderr,"\n");
+}
+
+static void
+display_cb(Widget widget, XtPointer clientdata, XtPointer call_data)
+{
+    XmDisplayCallbackStruct *arg = call_data;
+    
+    switch (arg->reason) {
+    case XmCR_NO_RENDITION:
+	fprintf(stderr,"display_cb: no rendition: \"%s\"\n",arg->tag);
+	break;
+    case XmCR_NO_FONT:
+	fprintf(stderr,"display_cb: no font: \"%s\"\n",arg->font_name);
+	break;
+    default:
+	/* should not happen */
+	fprintf(stderr,"display_cb: unknown reason [%d]\n",arg->reason);
+	break;
+    }
+}
+
+/* ---------------------------------------------------------------------- */
+
+struct ptr_list {
+    struct ptr_list *next;
+    Widget widget;
+};
+struct ptr_list *ptr_head;
+
+void ptr_register(Widget widget)
+{
+    struct ptr_list *item;
+
+    if (XtWindow(widget))
+	XDefineCursor(XtDisplay(widget), XtWindow(widget),
+		      ptrs[POINTER_NORMAL]);
+    item = malloc(sizeof(*item));
+    memset(item,0,sizeof(*item));
+    item->widget = widget;
+    item->next = ptr_head;
+    ptr_head = item;
+}
+
+void ptr_unregister(Widget widget)
+{
+    struct ptr_list *item,*fitem;
+
+    if (ptr_head->widget == widget) {
+	fitem = ptr_head;
+	ptr_head = ptr_head->next;
+	free(fitem);
+	return;
+    }
+    for (item = ptr_head; NULL != item->next; item = item->next) {
+	if (item->next->widget == widget) {
+	    fitem = item->next;
+	    item->next = fitem->next;
+	    free(fitem);
+	    return;
+	}
+    }
+    /* shouldn't happen */
+    fprintf(stderr,"Oops: widget not found in list\n");
+}
+
+void ptr_busy(void)
+{
+    struct ptr_list *item;
+
+    for (item = ptr_head; NULL != item; item = item->next) {
+	if (!XtWindow(item->widget))
+	    continue;
+	XDefineCursor(XtDisplay(item->widget), XtWindow(item->widget),
+		      ptrs[POINTER_BUSY]);
+    }
+    XSync(dpy,False);
+}
+
+void ptr_idle(void)
+{
+    struct ptr_list *item;
+
+    for (item = ptr_head; NULL != item; item = item->next) {
+	if (!XtWindow(item->widget))
+	    continue;
+	XDefineCursor(XtDisplay(item->widget), XtWindow(item->widget),
+		      ptrs[POINTER_NORMAL]);
+    }
+}
+
+/* ---------------------------------------------------------------------- */
+
+static Boolean
+exit_wp(XtPointer client_data)
+{
+    exit(0);
+}
+
+static void
+exit_cb(Widget widget, XtPointer client_data, XtPointer calldata)
+{
+    XtAppAddWorkProc(app_context,exit_wp, NULL);
+    XtDestroyWidget(app_shell);
+}
+
+void
+exit_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
+{
+    exit_cb(widget,NULL,NULL);
+}
+
+/* ---------------------------------------------------------------------- */
+
+static void
+list_update(void)
+{
+    XmStringTable tab;
+    int i;
+
+    tab = malloc(nfiles * sizeof(XmString));
+    for (i = 0; i < nfiles; i++)
+	tab[i] = XmStringGenerate(files[i], NULL, XmMULTIBYTE_TEXT, NULL);
+    XtVaSetValues(wlist,
+		  XmNitems, tab,
+		  XmNitemCount, nfiles,
+		  NULL);
+    for (i = 0; i < nfiles; i++)
+	XmStringFree(tab[i]);
+    free(tab);
+}
+
+static int
+list_append(char *filename)
+{
+    int i;
+
+    for (i = 0; i < nfiles; i++)
+	if (0 == strcmp(files[i],filename))
+	    return i;
+    files = realloc(files,sizeof(char*)*(nfiles+1));
+    files[nfiles] = strdup(filename);
+    nfiles++;
+    return nfiles-1;
+}
+
+static void
+list_cb(Widget widget, XtPointer client_data, XtPointer calldata)
+{
+    XmListCallbackStruct *list = calldata;
+
+    if (0 == list->selected_item_count)
+	return;
+    cfile = list->selected_item_positions[0]-1;
+    cpage = 0;
+    npages = viewer_loadimage(ida,files[cfile],cpage);
+    if (-1 == npages)
+	return;
+    resize_shell();
+}
+
+static void
+pcd_set(Widget widget)
+{
+    WidgetList items;
+    Cardinal nitems;
+    unsigned int i;
+    int value;
+
+    value = GET_PHOTOCD_RES();
+    XtVaGetValues(widget,XtNchildren,&items,
+		  XtNnumChildren,&nitems,NULL);
+    for (i = 0; i < nitems; i++)
+	XmToggleButtonSetState(items[i],value == i+1,False);
+    pcd_res      = value;
+}
+
+static void
+pcd_cb(Widget widget, XtPointer client_data, XtPointer calldata)
+{
+    cfg_set_int(O_PHOTOCD_RES,(intptr_t)client_data);
+    pcd_set(XtParent(widget));
+}
+
+static void
+cfg_bool_cb(Widget widget, XtPointer client_data, XtPointer calldata)
+{
+    char *option = XtName(widget);
+    Boolean value = XmToggleButtonGetState(widget);
+    cfg_set_bool(O_OPTIONS, option, value);
+}
+
+static void
+cfg_save_cb(Widget widget, XtPointer client_data, XtPointer calldata)
+{
+    ida_write_config();
+}
+
+static void
+create_control(void)
+{
+    Widget form,menubar,tool,menu,smenu,push;
+
+    control_shell = XtVaAppCreateShell("ctrl","Iv",
+				       topLevelShellWidgetClass,
+				       dpy,
+				       XtNclientLeader,app_shell,
+				       XmNdeleteResponse,XmDO_NOTHING,
+				       NULL);
+    XmdRegisterEditres(control_shell);
+    XmAddWMProtocolCallback(control_shell,wm_delete_window,
+			    popupdown_cb,control_shell);
+
+    /* widgets */
+    form = XtVaCreateManagedWidget("form", xmFormWidgetClass, control_shell,
+				   NULL);
+    menubar = XmCreateMenuBar(form,"bar",NULL,0);
+    XtManageChild(menubar);
+    tool = XtVaCreateManagedWidget("tool",xmRowColumnWidgetClass, form,
+				   NULL);
+    status = XtVaCreateManagedWidget("status", xmLabelWidgetClass, form,
+				     NULL);
+    wlist = XmCreateScrolledList(form,"list",NULL,0);
+    XtManageChild(wlist);
+    XtAddCallback(wlist,XmNdefaultActionCallback,list_cb,NULL);
+    XtAddCallback(wlist,XmNdestinationCallback,selection_dest,NULL);
+    dnd_add(wlist);
+    
+    /* menu - file */
+    menu = XmCreatePulldownMenu(menubar,"fileM",NULL,0);
+    XtVaCreateManagedWidget("file",xmCascadeButtonWidgetClass,menubar,
+			    XmNsubMenuId,menu,NULL);
+    push = XtVaCreateManagedWidget("load",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Load()");
+    push = XtVaCreateManagedWidget("save",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Save()");
+    push = XtVaCreateManagedWidget("browse",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Browser()");
+    push = XtVaCreateManagedWidget("filelist",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Filelist()");
+    XtVaCreateManagedWidget("sep",xmSeparatorWidgetClass,menu,NULL);
+#ifdef HAVE_LIBSANE
+    sane_menu(menu);
+#endif
+    push = XtVaCreateManagedWidget("print",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Print()");
+    XtVaCreateManagedWidget("sep",xmSeparatorWidgetClass,menu,NULL);
+    push = XtVaCreateManagedWidget("quit",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,exit_cb,NULL);
+
+    /* menu - edit */
+    menu = XmCreatePulldownMenu(menubar,"editM",NULL,0);
+    XtVaCreateManagedWidget("edit",xmCascadeButtonWidgetClass,menubar,
+			    XmNsubMenuId,menu,NULL);
+    push = XtVaCreateManagedWidget("undo",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Undo()");
+    XtVaCreateManagedWidget("sep",xmSeparatorWidgetClass,menu,NULL);
+    push = XtVaCreateManagedWidget("copy",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Ipc(copy)");
+    push = XtVaCreateManagedWidget("paste",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Ipc(paste)");
+    XtVaCreateManagedWidget("sep",xmSeparatorWidgetClass,menu,NULL);
+    push = XtVaCreateManagedWidget("flipv",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Filter(flip-vert)");
+    push = XtVaCreateManagedWidget("fliph",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Filter(flip-horz)");
+    push = XtVaCreateManagedWidget("rotcw",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Filter(rotate-cw)");
+    push = XtVaCreateManagedWidget("rotccw",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Filter(rotate-ccw)");
+    push = XtVaCreateManagedWidget("invert",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Filter(invert)");
+    XtVaCreateManagedWidget("sep",xmSeparatorWidgetClass,menu,NULL);
+    push = XtVaCreateManagedWidget("crop",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Filter(crop)");
+    push = XtVaCreateManagedWidget("acrop",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Filter(autocrop)");
+    push = XtVaCreateManagedWidget("scale",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Resize()");
+    push = XtVaCreateManagedWidget("rotany",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Rotate()");
+
+    /* menu - filters / operations */
+    menu = XmCreatePulldownMenu(menubar,"opM",NULL,0);
+    XtVaCreateManagedWidget("op",xmCascadeButtonWidgetClass,menubar,
+			    XmNsubMenuId,menu,NULL);
+    push = XtVaCreateManagedWidget("gamma",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Gamma()");
+    push = XtVaCreateManagedWidget("bright",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Bright()");
+    push = XtVaCreateManagedWidget("contr",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Contrast()");
+    push = XtVaCreateManagedWidget("color",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Color()");
+    push = XtVaCreateManagedWidget("gray",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Filter(grayscale)");
+    XtVaCreateManagedWidget("sep",xmSeparatorWidgetClass,menu,NULL);
+    push = XtVaCreateManagedWidget("blur",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,
+		  "F3x3(1,1,1, 1,1,1, 1,1,1, 1,9,0)");
+    push = XtVaCreateManagedWidget("sharpe",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Sharpe()");
+    push = XtVaCreateManagedWidget("edge",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,
+		  "F3x3(-1,-1,-1, -1,8,-1, -1,-1,-1)");
+    push = XtVaCreateManagedWidget("emboss",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,
+		  "F3x3(1,0,0, 0,0,0, 0,0,-1, 0,0,128)");
+
+    /* menu - view */
+    menu = XmCreatePulldownMenu(menubar,"viewM",NULL,0);
+    XtVaCreateManagedWidget("view",xmCascadeButtonWidgetClass,menubar,
+			    XmNsubMenuId,menu,NULL);
+    push = XtVaCreateManagedWidget("prev",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Prev()");
+    push = XtVaCreateManagedWidget("next",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Next()");
+    XtVaCreateManagedWidget("sep",xmSeparatorWidgetClass,menu,NULL);
+    push = XtVaCreateManagedWidget("prevpage",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"PrevPage()");
+    push = XtVaCreateManagedWidget("nextpage",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"NextPage()");
+    XtVaCreateManagedWidget("sep",xmSeparatorWidgetClass,menu,NULL);
+    push = XtVaCreateManagedWidget("zoomin",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Zoom(inc)");
+    push = XtVaCreateManagedWidget("zoomout",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Zoom(dec)");
+
+    /* menu - options */
+    menu = XmCreatePulldownMenu(menubar,"optM",NULL,0);
+    push = XtVaCreateManagedWidget("opt",xmCascadeButtonWidgetClass,menubar,
+				   XmNsubMenuId,menu,NULL);
+    smenu = XmCreatePulldownMenu(menu,"pcdM",NULL,0);
+    XtVaCreateManagedWidget("pcd",xmCascadeButtonWidgetClass,menu,
+			    XmNsubMenuId,smenu,NULL);
+    push = XtVaCreateManagedWidget("1",xmToggleButtonWidgetClass,smenu,NULL);
+    XtAddCallback(push,XmNvalueChangedCallback,pcd_cb,(XtPointer)1);
+    push = XtVaCreateManagedWidget("2",xmToggleButtonWidgetClass,smenu,NULL);
+    XtAddCallback(push,XmNvalueChangedCallback,pcd_cb,(XtPointer)2);
+    push = XtVaCreateManagedWidget("3",xmToggleButtonWidgetClass,smenu,NULL);
+    XtAddCallback(push,XmNvalueChangedCallback,pcd_cb,(XtPointer)3);
+    push = XtVaCreateManagedWidget("4",xmToggleButtonWidgetClass,smenu,NULL);
+    XtAddCallback(push,XmNvalueChangedCallback,pcd_cb,(XtPointer)4);
+    push = XtVaCreateManagedWidget("5",xmToggleButtonWidgetClass,smenu,NULL);
+    XtAddCallback(push,XmNvalueChangedCallback,pcd_cb,(XtPointer)5);
+    pcd_set(smenu);
+
+    push = XtVaCreateManagedWidget("autozoom",xmToggleButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNvalueChangedCallback,cfg_bool_cb,NULL);
+    XmToggleButtonSetState(push,GET_AUTOZOOM(),False);
+
+    XtVaCreateManagedWidget("sep",xmSeparatorWidgetClass,menu,NULL);
+    push = XtVaCreateManagedWidget("cfgsave",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,cfg_save_cb,NULL);
+    
+    /* menu - help */
+    menu = XmCreatePulldownMenu(menubar,"helpM",NULL,0);
+    push = XtVaCreateManagedWidget("help",xmCascadeButtonWidgetClass,menubar,
+				   XmNsubMenuId,menu,NULL);
+    XtVaSetValues(menubar,XmNmenuHelpWidget,push,NULL);
+    push = XtVaCreateManagedWidget("man",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Man(ida)");
+    XtVaCreateManagedWidget("sep",xmSeparatorWidgetClass,menu,NULL);
+    push = XtVaCreateManagedWidget("about",xmPushButtonWidgetClass,menu,NULL);
+    XtAddCallback(push,XmNactivateCallback,about_cb,NULL);
+
+    /* toolbar */
+    push = XtVaCreateManagedWidget("prev",xmPushButtonWidgetClass,tool,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Prev()");
+    push = XtVaCreateManagedWidget("next",xmPushButtonWidgetClass,tool,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Next()");
+    push = XtVaCreateManagedWidget("zoomin",xmPushButtonWidgetClass,tool,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Zoom(inc)");
+    push = XtVaCreateManagedWidget("zoomout",xmPushButtonWidgetClass,tool,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Zoom(dec)");
+
+    XtVaCreateManagedWidget("sep",xmSeparatorWidgetClass,tool,NULL);
+    push = XtVaCreateManagedWidget("flipv",xmPushButtonWidgetClass,tool,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Filter(flip-vert)");
+    push = XtVaCreateManagedWidget("fliph",xmPushButtonWidgetClass,tool,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Filter(flip-horz)");
+    push = XtVaCreateManagedWidget("rotccw",xmPushButtonWidgetClass,tool,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Filter(rotate-ccw)");
+    push = XtVaCreateManagedWidget("rotcw",xmPushButtonWidgetClass,tool,NULL);
+    XtAddCallback(push,XmNactivateCallback,action_cb,"Filter(rotate-cw)");
+
+    XtVaCreateManagedWidget("sep",xmSeparatorWidgetClass,tool,NULL);
+    push = XtVaCreateManagedWidget("exit",xmPushButtonWidgetClass,tool,NULL);
+    XtAddCallback(push,XmNactivateCallback,exit_cb,NULL);
+}
+
+/* ---------------------------------------------------------------------- */
+
+void
+resize_shell(void)
+{
+    char *title,*base;
+    Dimension x,y,w,h,sw,sh;
+    XmString str;
+    int len;
+    
+    XtVaGetValues(app_shell, XtNx,&x, XtNy,&y, NULL);
+
+    /* resize shell + move shell
+       size: image size + 2*shadowThickness */
+    w = ida->scrwidth+2;
+    h = ida->scrheight+2;
+    sw = XtScreen(ida->widget)->width;
+    sh = XtScreen(ida->widget)->height;
+    if (w > sw)
+	w = sw;
+    if (h > sh)
+	h = sh;
+    if (x+w > sw)
+	x = sw-w;
+    if (y+h > sh)
+	y = sh-h;
+
+    base = strrchr(ida->file,'/');
+    if (base)
+	base++;
+    else
+	base = ida->file;
+    title = malloc(strlen(base)+128);
+    len = sprintf(title,"%s (%dx%d", base,
+		  ida->img.i.width, ida->img.i.height);
+    if (ida->img.i.dpi)
+	len += sprintf(title+len," | %d dpi",
+		       ida->img.i.dpi);
+    if (ida->img.i.npages > 1)
+        len += sprintf(title+len," | page %d/%d",
+		       cpage+1, ida->img.i.npages);
+    len += sprintf(title+len," | %d%%)", viewer_i2s(ida->zoom,100));
+    XtVaSetValues(app_shell, XtNtitle,title,
+		  /* XtNx,x, XtNy,y, */ XtNwidth,w, XtNheight,h,
+		  NULL);
+    str = XmStringGenerate(title,NULL,XmMULTIBYTE_TEXT,NULL);
+    XtVaSetValues(status,XmNlabelString,str,NULL);
+    XmStringFree(str);
+    free(title);
+}
+
+static int
+load_file(int nr, int np)
+{
+    if(nr < 0 || nr >= nfiles)
+        return -1;
+    npages = viewer_loadimage(ida,files[nr],np);
+    if (-1 == npages)
+	return -1;
+    resize_shell();
+#if 0
+    XmListSelectPos(wlist,nr+1,False);
+    cfile = nr;
+#endif
+    return npages;
+}
+
+char*
+load_tmpfile(char *base)
+{
+    char *tmpdir;
+    char *filename;
+
+    tmpdir = getenv("TMPDIR");
+    if (NULL == tmpdir)
+	tmpdir="/tmp";
+    filename = malloc(strlen(tmpdir)+strlen(base)+16);
+    sprintf(filename,"%s/%s-XXXXXX",tmpdir,base);
+    return filename;
+}
+
+static void
+load_logo(void)
+{
+    static unsigned char logo[] = {
+#include "logo.h"
+    };
+    char *filename = load_tmpfile("ida-logo");
+    int fd;
+    fd = mkstemp(filename);
+    write(fd,logo,sizeof(logo));
+    close(fd);
+    cpage = 0;
+    npages = 1;
+    if (0 < viewer_loadimage(ida,filename,cpage)) {
+	ida->file = "ida " VERSION;
+	resize_shell();
+    }
+    unlink(filename);
+    free(filename);
+}
+
+static void
+load_stdin(void)
+{
+    char *filename = load_tmpfile("ida-stdin");
+    char buf[4096];
+    int rc,fd;
+    fd = mkstemp(filename);
+    for (;;) {
+	rc = read(0,buf,sizeof(buf));
+	if (rc <= 0)
+	    break;
+	write(fd,buf,rc);
+    }
+    close(fd);
+    cpage = 0;
+    npages = 1;
+    if (0 < viewer_loadimage(ida,filename,cpage)) {
+	ida->file = "stdin";
+	resize_shell();
+    }
+    unlink(filename);
+    free(filename);
+}
+
+void
+next_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
+{
+    for (;;) {
+	if (cfile >= nfiles-1)
+	    return;
+	cfile++;
+        cpage = 0;
+	if (0 <= load_file(cfile,cpage))
+	    break;
+    }
+}
+
+void
+prev_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
+{
+    for (;;) {
+	if (cfile < 1)
+	    return;
+	cfile--;
+        cpage = 0;
+	if (0 <= load_file(cfile,cpage))
+	    break;
+    }
+}
+
+void
+next_page_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
+{
+    for (;;) {
+	if (cpage >= npages-1)
+	    return;
+	cpage++;
+	if (0 <= load_file(cfile,cpage))
+	    break;
+    }
+}
+
+void
+prev_page_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
+{
+    for (;;) {
+	if (cpage <= 0)
+	    return;
+	cpage--;
+	if (0 <= load_file(cfile,cpage))
+	    break;
+    }
+}
+
+void
+zoom_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
+{
+    int zoom;
+    
+    if (0 == *num)
+	return;
+
+    if (0 == strcasecmp(params[0],"auto")) {
+	viewer_autozoom(ida);
+	return;
+    }
+
+    if (0 == strcasecmp(params[0],"inc")) {
+	zoom = ida->zoom+1;
+    } else if (0 == strcasecmp(params[0],"dec")) {
+	zoom = ida->zoom-1;
+    } else {
+	zoom = atoi(params[0]);
+    }
+    viewer_setzoom(ida,zoom);
+    resize_shell();
+}
+
+void
+scroll_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
+{
+    fprintf(stderr,"Scroll(): %s\n",XtName(widget));
+}
+
+/* ---------------------------------------------------------------------- */
+
+void new_file(char *name, int complain)
+{
+    struct stat st;
+    int n;
+
+    if (curl_is_url(name))
+	goto load;
+
+    if (0 == strncasecmp(name,"file:",5))
+	name += 5;
+    if (-1 == stat(name,&st)) {
+	if (complain)
+	    fprintf(stderr,"stat %s: %s\n",name,strerror(errno));
+	return;
+    }
+    switch (st.st_mode & S_IFMT) {
+    case S_IFDIR:
+	browser_window(name);
+	break;
+    case S_IFREG:
+	goto load;
+	break;
+    }
+    return;
+    
+ load:
+    n = list_append(name);
+    list_update();
+    cpage = 0;
+    load_file(n,cpage);
+}
+
+static void
+load_done_cb(Widget widget, XtPointer clientdata, XtPointer call_data)
+{
+    XmFileSelectionBoxCallbackStruct *cb = call_data;
+    char *line;
+
+    if (cb->reason == XmCR_OK) {
+        line = XmStringUnparse(cb->value,NULL,
+                               XmMULTIBYTE_TEXT,XmMULTIBYTE_TEXT,
+                               NULL,0,0);
+	new_file(line,1);
+    }
+    XtUnmanageChild(widget);
+}
+
+void
+load_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
+{
+    Widget help;
+
+    if (NULL == loadbox) {
+	loadbox = XmCreateFileSelectionDialog(app_shell,"load",NULL,0);
+	help = XmFileSelectionBoxGetChild(loadbox,XmDIALOG_HELP_BUTTON);
+	XtUnmanageChild(help);
+	XtAddCallback(loadbox,XmNokCallback,load_done_cb,NULL);
+	XtAddCallback(loadbox,XmNcancelCallback,load_done_cb,NULL);
+    } else {
+	XmFileSelectionDoSearch(loadbox,NULL);
+    }
+    XtManageChild(loadbox);
+}
+
+void
+scan_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
+{
+#ifdef HAVE_LIBSANE
+    cpage = 0;
+    if (*num)
+	npages = viewer_loader_start(ida, &sane_loader, NULL, params[0], 0);
+    else
+	npages = viewer_loader_start(ida, &sane_loader, NULL, "", 0);
+    if (-1 == npages)
+	return;
+    ida->file = "scanned image";
+    resize_shell();
+#endif
+}
+
+/* ---------------------------------------------------------------------- */
+
+void
+do_save_print(void)
+{
+    FILE *fp;
+    
+    if (save_filename) {
+	XtUnmanageChild(savebox);
+	ptr_busy();
+	if (NULL == (fp = fopen(save_filename,"wb"))) {
+	    fprintf(stderr,"save: can't open %s: %s\n",
+		    save_filename,strerror(errno));
+	} else if (-1 == cwriter->write(fp,&ida->img)) {
+	    fclose(fp);
+	    fprintf(stderr,"saving %s FAILED",save_filename);
+	} else {
+	    fclose(fp);
+	    list_append(save_filename);
+	    list_update();
+	}
+	ptr_idle();
+    }
+    if (print_command) {
+	XtUnmanageChild(printbox);
+	ptr_busy();
+	if (NULL == (fp = popen(print_command,"w"))) {
+	    fprintf(stderr,"print: can't exec %s: %s\n",
+		    print_command,strerror(errno));
+	} else {
+	    if (-1 == cwriter->write(fp,&ida->img))
+		fprintf(stderr,"printing FAILED");
+	    fclose(fp);
+	}
+	ptr_idle();
+    }
+}
+
+static void
+save_done_cb(Widget widget, XtPointer clientdata, XtPointer call_data)
+{
+    XmFileSelectionBoxCallbackStruct *cb = call_data;
+
+    if (cb->reason == XmCR_OK) {
+	print_command = NULL;
+	save_filename = XmStringUnparse(cb->value,NULL,
+					XmMULTIBYTE_TEXT,XmMULTIBYTE_TEXT,
+					NULL,0,0);
+	if (cwriter->conf) {
+	    cwriter->conf(widget,&ida->img);
+	} else {
+	    do_save_print();
+	}
+    } else {
+	XtUnmanageChild(widget);
+    }
+}
+
+static void
+save_fmt_cb(Widget widget, XtPointer clientdata, XtPointer call_data)
+{
+    cwriter = clientdata;
+}
+
+static void
+save_ext_cb(Widget widget, XtPointer clientdata, XtPointer call_data)
+{
+    Widget option = clientdata;
+    Widget menu;
+    WidgetList children;
+    Cardinal nchildren;
+    struct ida_writer *wr = NULL;
+    struct list_head *item;
+    char *name,*ext;
+    int i,j,pick;
+
+    name = XmTextGetString(widget);
+    ext = strrchr(name,'.');
+    if (NULL == ext)
+	return;
+    if (strchr(ext,'/'))
+	return;
+    ext++;
+
+    i = 0; pick = -1;
+    list_for_each(item,&writers) {
+	wr = list_entry(item, struct ida_writer, list);
+	for (j = 0; NULL != wr->ext[j]; j++)
+	    if (0 == strcasecmp(ext,wr->ext[j]))
+		pick = i;
+	if (-1 != pick)
+	    break;
+	i++;
+    }
+    if (-1 == pick)
+	return;
+
+    XtVaGetValues(option,XmNsubMenuId,&menu,NULL);
+    XtVaGetValues(menu,XtNchildren,&children,
+		  XtNnumChildren,&nchildren,NULL);
+    XtVaSetValues(option,XmNmenuHistory,children[pick],NULL);
+    cwriter = wr;
+}
+
+static void
+save_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
+{
+    Widget help,menu,option,push,text;
+    Arg args[2];
+    struct ida_writer *wr = NULL;
+    struct list_head *item;
+
+    if (NULL == savebox) {
+	savebox = XmCreateFileSelectionDialog(app_shell,"save",NULL,0);
+	help = XmFileSelectionBoxGetChild(savebox,XmDIALOG_HELP_BUTTON);
+	text = XmFileSelectionBoxGetChild(savebox,XmDIALOG_TEXT);
+	XtUnmanageChild(help);
+
+	menu = XmCreatePulldownMenu(savebox,"formatM",NULL,0);
+	XtSetArg(args[0],XmNsubMenuId,menu);
+	option = XmCreateOptionMenu(savebox,"format",args,1);
+	XtManageChild(option);
+	list_for_each(item,&writers) {
+	    wr = list_entry(item, struct ida_writer, list);
+	    push = XtVaCreateManagedWidget(wr->label,
+					   xmPushButtonWidgetClass,menu,
+					   NULL);
+	    XtAddCallback(push,XmNactivateCallback,save_fmt_cb,wr);
+	}
+	cwriter = list_entry(writers.next, struct ida_writer, list);
+
+	XtAddCallback(text,XmNvalueChangedCallback,save_ext_cb,option);
+	XtAddCallback(savebox,XmNokCallback,save_done_cb,NULL);
+	XtAddCallback(savebox,XmNcancelCallback,save_done_cb,NULL);
+    } else {
+	XmFileSelectionDoSearch(savebox,NULL);
+    }
+    XtManageChild(savebox);
+}
+
+/* ---------------------------------------------------------------------- */
+
+static void
+print_done_cb(Widget widget, XtPointer clientdata, XtPointer call_data)
+{
+    XmSelectionBoxCallbackStruct *cb = call_data;
+
+    if (cb->reason == XmCR_OK) {
+	save_filename = NULL;
+	print_command = XmStringUnparse(cb->value,NULL,
+					XmMULTIBYTE_TEXT,XmMULTIBYTE_TEXT,
+					NULL,0,0);
+	cwriter = &ps_writer;
+	cwriter->conf(widget,&ida->img);
+    } else {
+	XtUnmanageChild(widget);
+    }
+}
+
+static void
+print_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
+{
+    if (NULL == printbox) {
+	printbox = XmCreatePromptDialog(app_shell,"print",NULL,0);
+	XtUnmanageChild(XmSelectionBoxGetChild(printbox,XmDIALOG_HELP_BUTTON));
+	XtAddCallback(printbox,XmNokCallback,print_done_cb,NULL);
+	XtAddCallback(printbox,XmNcancelCallback,print_done_cb,NULL);
+    }
+    XtManageChild(printbox);
+}
+
+/* ---------------------------------------------------------------------- */
+
+static struct ida_op *ops[] = {
+    &desc_flip_vert,
+    &desc_flip_horz,
+    &desc_rotate_cw,
+    &desc_rotate_ccw,
+    &desc_invert,
+    &desc_crop,
+    &desc_autocrop,
+    &desc_grayscale,
+    NULL
+};
+
+void
+filter_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
+{
+    struct ida_op *op = NULL;
+    int i;
+
+    if (*num < 1)
+	return;
+    for (i = 0; NULL != ops[i]; i++) {
+	op = ops[i];
+	if (0 == strcasecmp(op->name,params[0]))
+	    break;
+    }
+    if (NULL == ops[i]) {
+	fprintf(stderr,"Oops: unknown filter: %s\n",params[0]);
+	return;
+    }
+
+    viewer_start_op(ida,op,NULL);
+    if (ida->op_src.i.width  != ida->img.i.width ||
+	ida->op_src.i.height != ida->img.i.height)
+	resize_shell();
+}
+
+void
+f3x3_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
+{
+    struct op_3x3_parm p;
+
+    if (*num < 9) {
+	fprintf(stderr,"F3x3: wrong number of args (%d, need 9)\n",*num);
+	return;
+    }
+    memset(&p,0,sizeof(p));
+    p.f1[0] = atoi(params[0]);
+    p.f1[1] = atoi(params[1]);
+    p.f1[2] = atoi(params[2]);
+    p.f2[0] = atoi(params[3]);
+    p.f2[1] = atoi(params[4]);
+    p.f2[2] = atoi(params[5]);
+    p.f3[0] = atoi(params[6]);
+    p.f3[1] = atoi(params[7]);
+    p.f3[2] = atoi(params[8]);
+    if (*num >  9) p.mul = atoi(params[ 9]);
+    if (*num > 10) p.div = atoi(params[10]);
+    if (*num > 11) p.add = atoi(params[11]);
+    if (debug) {
+	fprintf(stderr,"f3x3: -----------\n");
+	fprintf(stderr,"f3x3: %3d %3d %3d\n",p.f1[0],p.f1[1],p.f1[2]);
+	fprintf(stderr,"f3x3: %3d %3d %3d\n",p.f2[0],p.f2[1],p.f2[2]);
+	fprintf(stderr,"f3x3: %3d %3d %3d\n",p.f3[0],p.f3[1],p.f3[2]);
+	fprintf(stderr,"f3x3: *%d/%d+%d\n",p.mul,p.div,p.add);
+    }
+    viewer_start_op(ida,&desc_3x3,&p);
+}
+
+void
+undo_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
+{
+    Widget msgbox;
+    int resize;
+
+    resize = (ida->undo.i.width  != ida->img.i.width ||
+	      ida->undo.i.height != ida->img.i.height);
+    if (-1 == viewer_undo(ida)) {
+	msgbox = XmCreateInformationDialog(app_shell,"noundobox",NULL,0);
+	XtUnmanageChild(XmMessageBoxGetChild(msgbox,XmDIALOG_HELP_BUTTON));
+	XtUnmanageChild(XmMessageBoxGetChild(msgbox,XmDIALOG_CANCEL_BUTTON));
+	XtAddCallback(msgbox,XmNokCallback,destroy_cb,msgbox);
+	XtManageChild(msgbox);
+    } else {
+	if (resize)
+	    resize_shell();
+    }
+}
+
+/* ---------------------------------------------------------------------- */
+
+struct ida_prompt {
+    Widget shell;
+    Widget box;
+    Widget scale;
+    Widget text;
+    int apply;
+    int value;
+    int decimal;
+    int factor;    /* 10^decimal */
+    void (*notify)(int value, int preview);
+};
+
+static void
+prompt_setvalue(struct ida_prompt *me, int value, int scale, int text)
+{
+    char str[32];
+    int min,max;
+    
+    if (me->value == value)
+	return;
+    XtVaGetValues(me->scale,XmNminimum,&min,XmNmaximum,&max,NULL);
+    if (value < min || value > max)
+	return;
+
+    me->value = value;
+    if (scale)
+	XmScaleSetValue(me->scale,value);
+    if (text) {
+	if (me->decimal) {
+	    sprintf(str,"%*.*f",me->decimal+2,me->decimal,
+		    (float)value/me->factor);
+	} else {
+	    sprintf(str,"%d",value);
+	}
+	XmTextSetString(me->text,str);
+    }
+    if (me->notify)
+	me->notify(value,1);
+}
+
+static void
+prompt_scale_cb(Widget widget, XtPointer client_data, XtPointer calldata)
+{
+    struct ida_prompt *me = client_data;
+    XmScaleCallbackStruct *cd = calldata;
+
+    prompt_setvalue(me,cd->value,0,1);
+}
+
+static void
+prompt_text_cb(Widget widget, XtPointer client_data, XtPointer calldata)
+{
+    struct ida_prompt *me = client_data;
+    float fvalue;
+    int value;
+
+    if (me->decimal) {
+	fvalue  = atof(XmTextGetString(me->text));
+	fvalue += 0.5/me->factor;
+	value = (int)(fvalue * me->factor);
+    } else {
+	value = atoi(XmTextGetString(me->text));
+    }
+    prompt_setvalue(me,value,1,0);
+}
+
+static void
+prompt_box_cb(Widget widget, XtPointer client_data, XtPointer calldata)
+{
+    struct ida_prompt *me = client_data;
+    XmSelectionBoxCallbackStruct *cd = calldata;
+
+    if (XmCR_OK == cd->reason)
+	me->apply = 1;
+    XtDestroyWidget(me->shell);
+}
+
+static void
+prompt_shell_cb(Widget widget, XtPointer client_data, XtPointer calldata)
+{
+    struct ida_prompt *me = client_data;
+
+    if (me->apply)
+	me->notify(me->value,0);
+    else
+	viewer_cancel_preview(ida);
+    free(me);
+}
+
+static void
+prompt_init(char *name, int decimal, int value,
+	    void (*notify)(int value, int preview))
+{
+    struct ida_prompt *me;
+
+    me = malloc(sizeof(*me));
+    memset(me,0,sizeof(*me));
+    if (decimal) {
+	int i;
+	me->decimal = decimal;
+	me->factor = 1;
+	for (i = 0; i < decimal; i++)
+	    me->factor *= 10;
+    }
+    me->notify = notify;
+    
+    me->box = XmCreatePromptDialog(app_shell,name,NULL,0);
+    me->shell = XtParent(me->box);
+    me->text = XmSelectionBoxGetChild(me->box,XmDIALOG_TEXT);
+    XmdRegisterEditres(XtParent(me->box));
+    XtUnmanageChild(XmSelectionBoxGetChild(me->box,XmDIALOG_HELP_BUTTON));
+    me->scale = XtVaCreateManagedWidget("scale",xmScaleWidgetClass,
+					me->box,NULL);
+
+    XtAddCallback(me->scale,XmNdragCallback,prompt_scale_cb,me);
+    XtAddCallback(me->scale,XmNvalueChangedCallback,prompt_scale_cb,me);
+    XtAddCallback(me->text,XmNvalueChangedCallback,prompt_text_cb,me);
+    XtAddCallback(me->box,XmNokCallback,prompt_box_cb,me);
+    XtAddCallback(me->box,XmNcancelCallback,prompt_box_cb,me);
+    XtAddCallback(me->shell,XmNdestroyCallback,prompt_shell_cb,me);
+    
+    XtManageChild(me->box);
+    prompt_setvalue(me,value,1,1);
+}
+
+/* ---------------------------------------------------------------------- */
+
+static void
+gamma_notify(int value, int preview)
+{
+    struct op_map_parm param;
+    float gamma = (float)value/100;
+
+    param.red = op_map_nothing;
+    param.red.gamma   = gamma;
+    param.green = param.red;
+    param.blue  = param.red;
+    if (preview) {
+	viewer_start_preview(ida,&desc_map,&param);
+    } else {
+	gamma_val = value;
+	viewer_start_op(ida,&desc_map,&param);
+    }
+}
+
+void
+gamma_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
+{
+    prompt_init("gamma",2,gamma_val,gamma_notify);
+}
+
+static void
+bright_notify(int value, int preview)
+{
+    struct op_map_parm param;
+
+    param.red = op_map_nothing;
+    param.red.bottom += value;
+    param.red.top    += value;
+    param.green = param.red;
+    param.blue  = param.red;
+    if (preview) {
+	viewer_start_preview(ida,&desc_map,&param);
+    } else {
+	bright_val = value;
+	viewer_start_op(ida,&desc_map,&param);
+    }
+}
+
+void
+bright_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
+{
+    prompt_init("bright",0,bright_val,bright_notify);
+}
+
+static void
+contrast_notify(int value, int preview)
+{
+    struct op_map_parm param;
+
+    param.red = op_map_nothing;
+    param.red.bottom -= value;
+    param.red.top    += value;
+    param.green = param.red;
+    param.blue  = param.red;
+    if (preview) {
+	viewer_start_preview(ida,&desc_map,&param);
+    } else {
+	contrast_val = value;
+	viewer_start_op(ida,&desc_map,&param);
+    }
+}
+
+void
+contrast_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
+{
+    prompt_init("contrast",0,contrast_val,contrast_notify);
+}
+
+static void
+rotate_notify(int value, int preview)
+{
+    struct op_rotate_parm parm;
+
+    parm.angle = value;
+    if (preview) {
+	viewer_start_preview(ida,&desc_rotate,&parm);
+    } else {
+	rotate_val = value;
+	viewer_start_op(ida,&desc_rotate,&parm);
+    }
+}
+
+void
+rotate_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
+{
+    prompt_init("rotate",0,rotate_val,rotate_notify);
+}
+
+static void
+sharpe_notify(int value, int preview)
+{
+    struct op_sharpe_parm parm;
+
+    parm.factor = value;
+    if (preview) {
+	viewer_start_preview(ida,&desc_sharpe,&parm);
+    } else {
+	sharpe_val = value;
+	viewer_start_op(ida,&desc_sharpe,&parm);
+    }
+}
+
+void
+sharpe_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
+{
+    prompt_init("sharpe",0,sharpe_val,sharpe_notify);
+}
+
+void
+color_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
+{
+    color_init(&ida->img);
+}
+
+/* ---------------------------------------------------------------------- */
+
+struct ida_resize {
+    Widget dlg,tx,ty,tr,lock,size,res,label;
+    int yupdate,xupdate,rupdate;
+    int apply;
+};
+
+static void
+resize_phys_size(struct ida_resize *h)
+{
+    char buf[128];
+    XmString str;
+    int dpi;
+    float x,y;
+
+    dpi = atoi(XmTextGetString(h->tr));
+    if (dpi) {
+	x = (float)atoi(XmTextGetString(h->tx)) / dpi;
+	y = (float)atoi(XmTextGetString(h->ty)) / dpi;
+	sprintf(buf,"%.2f x %.2f inch\n%.2f x %.2f cm",
+		x,y, x*2.54, y*2.54);
+    } else {
+	strcpy(buf,"unknown");
+    }
+    str = XmStringGenerate(buf, NULL, XmMULTIBYTE_TEXT,NULL);
+    XtVaSetValues(h->label,XmNlabelString,str,NULL);
+}
+
+static void
+resize_sync_cb(Widget widget, XtPointer client_data, XtPointer calldata)
+{
+    struct ida_resize *h = client_data;
+    char buf[32];
+    int i,lock,res;
+
+    lock = XmToggleButtonGetState(h->lock);
+    res  = XmToggleButtonGetState(h->res);
+
+    /* update text fields */
+    if (h->tx == widget) {
+	if (h->xupdate) {
+	    h->xupdate--;
+	    return;
+	}
+	i = atoi(XmTextGetString(h->tx));
+	if (lock) {
+	    sprintf(buf,"%d",i * ida->img.i.height / ida->img.i.width);
+	    h->yupdate++;
+	    XmTextSetString(h->ty,buf);
+	    if (res) {
+		sprintf(buf,"%d", ida->img.i.dpi * i / ida->img.i.width);
+		h->rupdate++;
+		XmTextSetString(h->tr,buf);
+	    }
+	} else {
+	    if (res) {
+		h->rupdate++;
+		XmTextSetString(h->tr,"0");
+	    }
+	}
+	resize_phys_size(h);
+    }
+    if (h->ty == widget) {
+	if (h->yupdate) {
+	    h->yupdate--;
+	    return;
+	}
+	i = atoi(XmTextGetString(h->ty));
+	if (lock) {
+	    sprintf(buf,"%d",i * ida->img.i.width / ida->img.i.height);
+	    h->xupdate++;
+	    XmTextSetString(h->tx,buf);
+	    if (res) {
+		sprintf(buf,"%d", ida->img.i.dpi * i / ida->img.i.height);
+		h->rupdate++;
+		XmTextSetString(h->tr,buf);
+	    }
+	} else {
+	    if (res) {
+		h->rupdate++;
+		XmTextSetString(h->tr,"0");
+	    }
+	}
+	resize_phys_size(h);
+    }
+    if (h->tr == widget) {
+	if (h->rupdate) {
+	    h->rupdate--;
+	    return;
+	}
+	i = atoi(XmTextGetString(h->tr));
+	sprintf(buf,"%d", ida->img.i.width * i / ida->img.i.dpi);
+	h->xupdate++;
+	XmTextSetString(h->tx,buf);
+	sprintf(buf,"%d", ida->img.i.height * i / ida->img.i.dpi);
+	h->yupdate++;
+	XmTextSetString(h->ty,buf);
+	resize_phys_size(h);
+    }
+
+    /* radio buttons pressed */
+    if (h->size == widget && XmToggleButtonGetState(h->size)) {
+	XmToggleButtonSetState(h->res,0,False);
+	sprintf(buf,"%d", ida->img.i.dpi);
+	h->rupdate++;
+	XmTextSetString(h->tr,buf);
+	XtVaSetValues(h->tr,XmNsensitive,False,NULL);
+	resize_phys_size(h);
+    }
+    if (h->res == widget && XmToggleButtonGetState(h->res)) {
+	XmToggleButtonSetState(h->size,0,False);
+	XtVaSetValues(h->tr,XmNsensitive,True,NULL);
+    }
+}
+
+static void
+resize_button_cb(Widget widget, XtPointer client_data, XtPointer calldata)
+{
+    struct ida_resize *h = client_data;
+    XmSelectionBoxCallbackStruct *cb = calldata;
+
+    if (cb->reason == XmCR_OK)
+	h->apply = 1;
+    XtDestroyWidget(XtParent(h->dlg));
+}
+
+static void
+resize_destroy(Widget widget, XtPointer client_data, XtPointer calldata)
+{
+    struct ida_resize *h = client_data;
+    struct op_resize_parm param;
+
+    if (!h->apply)
+	return;
+    param.width  = atoi(XmTextGetString(h->tx));
+    param.height = atoi(XmTextGetString(h->ty));
+    param.dpi    = atoi(XmTextGetString(h->tr));
+    if (0 == param.width  ||
+	0 == param.height) {
+	fprintf(stderr,"resize: invalid argument\n");
+	return;
+    }
+	
+    viewer_start_op(ida,&desc_resize,&param);
+    resize_shell();
+    free(h);
+}
+
+static void
+resize_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
+{
+    Widget rc,rc2;
+    char buf[32];
+    struct ida_resize *h;
+
+    h = malloc(sizeof(*h));
+    memset(h,0,sizeof(*h));
+    
+    h->dlg = XmCreatePromptDialog(app_shell,"resize",NULL,0);
+    XmdRegisterEditres(XtParent(h->dlg));
+    XtUnmanageChild(XmSelectionBoxGetChild(h->dlg,XmDIALOG_SELECTION_LABEL));
+    XtUnmanageChild(XmSelectionBoxGetChild(h->dlg,XmDIALOG_HELP_BUTTON));
+    XtUnmanageChild(XmSelectionBoxGetChild(h->dlg,XmDIALOG_TEXT));
+    rc = XtVaCreateManagedWidget("rc", xmRowColumnWidgetClass,h->dlg, NULL);
+    XtVaCreateManagedWidget("lx", xmLabelWidgetClass,rc, NULL);
+    h->tx = XtVaCreateManagedWidget("tx", xmTextWidgetClass,rc, NULL);
+    XtVaCreateManagedWidget("ly", xmLabelWidgetClass,rc, NULL);
+    h->ty = XtVaCreateManagedWidget("ty", xmTextWidgetClass,rc, NULL);
+    XtVaCreateManagedWidget("lr", xmLabelWidgetClass,rc, NULL);
+    h->tr = XtVaCreateManagedWidget("tr", xmTextWidgetClass,rc, NULL);
+    h->lock = XtVaCreateManagedWidget("lock", xmToggleButtonWidgetClass,
+				      rc, NULL);
+    rc2 = XtVaCreateManagedWidget("rc", xmRowColumnWidgetClass,rc, NULL);
+    h->size = XtVaCreateManagedWidget("size", xmToggleButtonWidgetClass,
+				      rc2, NULL);
+    h->res  = XtVaCreateManagedWidget("res", xmToggleButtonWidgetClass,
+				      rc2, NULL);
+    XtVaCreateManagedWidget("phys", xmLabelWidgetClass,rc,NULL);
+    h->label = XtVaCreateManagedWidget("label", xmLabelWidgetClass,
+				       rc, NULL);
+
+    sprintf(buf,"%d",ida->img.i.width);
+    XmTextSetString(h->tx,buf);
+    sprintf(buf,"%d",ida->img.i.height);
+    XmTextSetString(h->ty,buf);
+    sprintf(buf,"%d",ida->img.i.dpi);
+    XmTextSetString(h->tr,buf);
+    XtVaSetValues(h->tr,XmNsensitive,False,NULL);
+    XmToggleButtonSetState(h->lock,1,False);
+    XmToggleButtonSetState(h->size,1,False);
+    XmToggleButtonSetState(h->res,0,False);
+    if (!ida->img.i.dpi) {
+    	XtVaSetValues(h->size,XmNsensitive,False,NULL);
+	XtVaSetValues(h->res, XmNsensitive,False,NULL);
+    }
+    resize_phys_size(h);
+    
+    XtAddCallback(XtParent(h->dlg),XmNdestroyCallback,resize_destroy,h);
+    XtAddCallback(h->dlg, XmNokCallback,           resize_button_cb, h);
+    XtAddCallback(h->dlg, XmNcancelCallback,       resize_button_cb, h);
+    XtAddCallback(h->tx,  XmNvalueChangedCallback, resize_sync_cb,   h);
+    XtAddCallback(h->ty,  XmNvalueChangedCallback, resize_sync_cb,   h);
+    XtAddCallback(h->tr,  XmNvalueChangedCallback, resize_sync_cb,   h);
+    XtAddCallback(h->size,XmNvalueChangedCallback, resize_sync_cb,   h);
+    XtAddCallback(h->res, XmNvalueChangedCallback, resize_sync_cb,   h);
+    XtManageChild(h->dlg);
+}
+
+/* ---------------------------------------------------------------------- */
+
+struct stderr_handler {
+    Widget box;
+    XmString str;
+    int pipe,err;
+    XtInputId id;
+};
+
+static void
+stderr_input(XtPointer clientdata, int *src, XtInputId *id)
+{
+    struct stderr_handler *h = clientdata;
+    XmString item;
+    Widget label;
+    char buf[1024];
+    int rc;
+
+    rc = read(h->pipe,buf,sizeof(buf)-1);
+    if (rc <= 0) {
+	/* Oops */
+	XtRemoveInput(h->id);
+	close(h->pipe);
+	XtDestroyWidget(h->box);
+	free(h);
+    }
+    buf[rc] = 0;
+    write(h->err,buf,rc);
+    item = XmStringGenerate(buf, NULL, XmMULTIBYTE_TEXT,NULL);
+    h->str = XmStringConcatAndFree(h->str,item);
+    label = XmMessageBoxGetChild(h->box,XmDIALOG_MESSAGE_LABEL);
+    XtVaSetValues(label,XmNlabelString,h->str,NULL);
+    XtManageChild(h->box);
+}
+
+static void
+stderr_ok_cb(Widget widget, XtPointer clientdata, XtPointer call_data)
+{
+    struct stderr_handler *h = clientdata;
+
+    XmStringFree(h->str);
+    h->str = XmStringGenerate("", NULL, XmMULTIBYTE_TEXT,NULL);
+    XtUnmanageChild(h->box);
+}
+
+static void
+stderr_close_cb(Widget widget, XtPointer clientdata, XtPointer call_data)
+{
+    struct stderr_handler *h = clientdata;
+
+    XmStringFree(h->str);
+    h->str = XmStringGenerate("", NULL, XmMULTIBYTE_TEXT,NULL);
+}
+
+static void
+stderr_init(void)
+{
+    struct stderr_handler *h;
+    int p[2];
+
+    h = malloc(sizeof(*h));
+    memset(h,0,sizeof(*h));
+    h->str = XmStringGenerate("", NULL, XmMULTIBYTE_TEXT,NULL);
+    h->box = XmCreateErrorDialog(app_shell,"errbox",NULL,0);
+    XtUnmanageChild(XmMessageBoxGetChild(h->box,XmDIALOG_HELP_BUTTON));
+    XtUnmanageChild(XmMessageBoxGetChild(h->box,XmDIALOG_CANCEL_BUTTON));
+    XtAddCallback(h->box,XmNokCallback,stderr_ok_cb,h);
+    XtAddCallback(XtParent(h->box),XmNpopdownCallback,stderr_close_cb,h);
+    XSync(XtDisplay(app_shell),False);
+    if (!debug) {
+	pipe(p);
+	h->err = dup(2);
+	dup2(p[1],2);
+	close(p[1]);
+	h->pipe = p[0];
+	h->id = XtAppAddInput(app_context,h->pipe,(XtPointer)XtInputReadMask,
+			      stderr_input,h);
+    }
+}
+
+/* ---------------------------------------------------------------------- */
+
+static void
+create_mainwindow(void)
+{
+    Widget img;
+
+    XmdRegisterEditres(app_shell);
+    view = XmCreateScrolledWindow(app_shell,"view",NULL,0);
+    XtManageChild(view);
+    img = XtVaCreateManagedWidget("image", xmDrawingAreaWidgetClass,view,NULL);
+    XtAddCallback(img,XmNdestinationCallback,selection_dest,NULL);
+    XtAddCallback(img,XmNconvertCallback,selection_convert,NULL);
+    dnd_add(img);
+    ida = viewer_init(img);
+    XtInstallAllAccelerators(img,app_shell);
+}
+
+static void
+usage(void)
+{
+    fprintf(stderr,
+	    "ida " VERSION " - image viewer & editor\n"
+	    "usage: ida [ options ] [ files ]\n"
+	    "options:\n"
+	    "   -h, -help    this text\n"
+	    "       -pcd n   pick PhotoCD size (n = 1 .. 5, default 3)\n"
+	    "   -d, -debug   enable debug messages\n");
+    exit(0);
+}
+
+int
+main(int argc, char *argv[])
+{
+    int i, files, zero = 0;
+    struct stat st;
+    Pixel background;
+
+    setlocale(LC_ALL,"");
+    if (0 == strcasecmp("utf-8", nl_langinfo(CODESET))) {
+	/* ### FIXME ###
+	 * for not-yet known reasons ida crashes somewhere deep in
+	 * the Motif libraries when running in utf-8 locale ... */
+	setenv("LC_ALL", "POSIX", 1);
+	setlocale(LC_ALL,"");
+    }
+    
+    binary = argv[0];
+    ida_init_config();
+    ida_read_config();
+
+    XtSetLanguageProc(NULL,NULL,NULL);
+    app_shell = XtAppInitialize(&app_context, "Ida",
+				opt_desc, opt_count,
+				&argc, argv,
+				fallback_ressources,
+				NULL, 0);
+    dpy = XtDisplay(app_shell);
+    XtGetApplicationResources(app_shell,&args,
+			      args_desc,args_count,
+			      NULL,0);
+    pcd_res  = GET_PHOTOCD_RES();
+    sane_res = GET_SANE_RES();
+    if (args.help)
+	usage();
+    if (args.debug) {
+	debug=1;
+	xdnd_debug = 1;
+	XSynchronize(dpy,1);
+    }
+
+    XtAppAddActions(app_context, actionTable,
+		    sizeof(actionTable) / sizeof(XtActionsRec));
+    if (0) {
+	XtAddCallback(XmGetXmDisplay(dpy),XmNnoFontCallback,
+		      display_cb,NULL);
+	XtAddCallback(XmGetXmDisplay(dpy),XmNnoRenditionCallback,
+		      display_cb,NULL);
+    }
+    XtVaGetValues(app_shell, XtNbackground,&background, NULL);
+    x11_color_init(app_shell,&gray);
+    x11_icons_init(dpy, background /* x11_gray */);
+    stderr_init();
+    ipc_init();
+
+    wm_delete_window = XInternAtom(dpy,"WM_DELETE_WINDOW",False);
+    create_mainwindow();
+    create_control();
+    XtRealizeWidget(app_shell);
+    ptr_register(ida->widget);
+    ptr_register(control_shell);
+
+    /* handle cmd line args */
+    if (2 == argc && 0 == strcmp(argv[1],"-")) {
+	load_stdin();
+    } else if (argc > 1) {
+	for (files = 0, i = 1; i < argc; i++) {
+ 	    if (curl_is_url(argv[i])) {
+		list_append(argv[i]);
+		files++;
+		continue;
+	    }
+	    if (-1 == stat(argv[i],&st)) {
+		if (debug)
+		    fprintf(stderr,"stat %s: %s\n",argv[i],strerror(errno));
+		continue;
+	    }
+	    switch (st.st_mode & S_IFMT) {
+	    case S_IFDIR:
+		browser_window(argv[i]);
+		break;
+	    case S_IFREG:
+		list_append(argv[i]);
+		files++;
+		break;
+	    }
+	}
+	if (files) {
+	    list_update();
+	    next_ac(ida->widget,NULL,NULL,&zero);
+	}
+    }
+
+    if (NULL == ida->file)
+	load_logo();
+
+    XtAppMainLoop(app_context);
+    return 0; /* keep compiler happy */
+}
diff --git a/lib/a2jpeg/jinclude.h b/lib/a2jpeg/jinclude.h
new file mode 100644
index 0000000..0a4f151
--- /dev/null
+++ b/lib/a2jpeg/jinclude.h
@@ -0,0 +1,91 @@
+/*
+ * jinclude.h
+ *
+ * Copyright (C) 1991-1994, Thomas G. Lane.
+ * This file is part of the Independent JPEG Group's software.
+ * For conditions of distribution and use, see the accompanying README file.
+ *
+ * This file exists to provide a single place to fix any problems with
+ * including the wrong system include files.  (Common problems are taken
+ * care of by the standard jconfig symbols, but on really weird systems
+ * you may have to edit this file.)
+ *
+ * NOTE: this file is NOT intended to be included by applications using the
+ * JPEG library.  Most applications need only include jpeglib.h.
+ */
+
+
+/* Include auto-config file to find out which system include files we need. */
+
+#include "jconfig.h"		/* auto configuration options */
+#define JCONFIG_INCLUDED	/* so that jpeglib.h doesn't do it again */
+
+/*
+ * We need the NULL macro and size_t typedef.
+ * On an ANSI-conforming system it is sufficient to include <stddef.h>.
+ * Otherwise, we get them from <stdlib.h> or <stdio.h>; we may have to
+ * pull in <sys/types.h> as well.
+ * Note that the core JPEG library does not require <stdio.h>;
+ * only the default error handler and data source/destination modules do.
+ * But we must pull it in because of the references to FILE in jpeglib.h.
+ * You can remove those references if you want to compile without <stdio.h>.
+ */
+
+#ifdef HAVE_STDDEF_H
+#include <stddef.h>
+#endif
+
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+
+#ifdef NEED_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+
+#include <stdio.h>
+
+/*
+ * We need memory copying and zeroing functions, plus strncpy().
+ * ANSI and System V implementations declare these in <string.h>.
+ * BSD doesn't have the mem() functions, but it does have bcopy()/bzero().
+ * Some systems may declare memset and memcpy in <memory.h>.
+ *
+ * NOTE: we assume the size parameters to these functions are of type size_t.
+ * Change the casts in these macros if not!
+ */
+
+#ifdef NEED_BSD_STRINGS
+
+#include <strings.h>
+#define MEMZERO(target,size)	bzero((void *)(target), (size_t)(size))
+#define MEMCOPY(dest,src,size)	bcopy((const void *)(src), (void *)(dest), (size_t)(size))
+
+#else /* not BSD, assume ANSI/SysV string lib */
+
+#include <string.h>
+#define MEMZERO(target,size)	memset((void *)(target), 0, (size_t)(size))
+#define MEMCOPY(dest,src,size)	memcpy((void *)(dest), (const void *)(src), (size_t)(size))
+
+#endif
+
+/*
+ * In ANSI C, and indeed any rational implementation, size_t is also the
+ * type returned by sizeof().  However, it seems there are some irrational
+ * implementations out there, in which sizeof() returns an int even though
+ * size_t is defined as long or unsigned long.  To ensure consistent results
+ * we always use this SIZEOF() macro in place of using sizeof() directly.
+ */
+
+#define SIZEOF(object)	((size_t) sizeof(object))
+
+/*
+ * The modules that use fread() and fwrite() always invoke them through
+ * these macros.  On some systems you may need to twiddle the argument casts.
+ * CAUTION: argument order is different from underlying functions!
+ */
+
+#define JFREAD(file,buf,sizeofbuf)  \
+  ((size_t) fread((void *) (buf), (size_t) 1, (size_t) (sizeofbuf), (file)))
+#define JFWRITE(file,buf,sizeofbuf)  \
+  ((size_t) fwrite((const void *) (buf), (size_t) 1, (size_t) (sizeofbuf), (file)))
diff --git a/lib/a2jpeg/jpegint.h b/lib/a2jpeg/jpegint.h
new file mode 100644
index 0000000..0c27a4e
--- /dev/null
+++ b/lib/a2jpeg/jpegint.h
@@ -0,0 +1,407 @@
+/*
+ * jpegint.h
+ *
+ * Copyright (C) 1991-1997, Thomas G. Lane.
+ * Modified 1997-2009 by Guido Vollbeding.
+ * This file is part of the Independent JPEG Group's software.
+ * For conditions of distribution and use, see the accompanying README file.
+ *
+ * This file provides common declarations for the various JPEG modules.
+ * These declarations are considered internal to the JPEG library; most
+ * applications using the library shouldn't need to include this file.
+ */
+
+
+/* Declarations for both compression & decompression */
+
+typedef enum {			/* Operating modes for buffer controllers */
+	JBUF_PASS_THRU,		/* Plain stripwise operation */
+	/* Remaining modes require a full-image buffer to have been created */
+	JBUF_SAVE_SOURCE,	/* Run source subobject only, save output */
+	JBUF_CRANK_DEST,	/* Run dest subobject only, using saved data */
+	JBUF_SAVE_AND_PASS	/* Run both subobjects, save output */
+} J_BUF_MODE;
+
+/* Values of global_state field (jdapi.c has some dependencies on ordering!) */
+#define CSTATE_START	100	/* after create_compress */
+#define CSTATE_SCANNING	101	/* start_compress done, write_scanlines OK */
+#define CSTATE_RAW_OK	102	/* start_compress done, write_raw_data OK */
+#define CSTATE_WRCOEFS	103	/* jpeg_write_coefficients done */
+#define DSTATE_START	200	/* after create_decompress */
+#define DSTATE_INHEADER	201	/* reading header markers, no SOS yet */
+#define DSTATE_READY	202	/* found SOS, ready for start_decompress */
+#define DSTATE_PRELOAD	203	/* reading multiscan file in start_decompress*/
+#define DSTATE_PRESCAN	204	/* performing dummy pass for 2-pass quant */
+#define DSTATE_SCANNING	205	/* start_decompress done, read_scanlines OK */
+#define DSTATE_RAW_OK	206	/* start_decompress done, read_raw_data OK */
+#define DSTATE_BUFIMAGE	207	/* expecting jpeg_start_output */
+#define DSTATE_BUFPOST	208	/* looking for SOS/EOI in jpeg_finish_output */
+#define DSTATE_RDCOEFS	209	/* reading file in jpeg_read_coefficients */
+#define DSTATE_STOPPING	210	/* looking for EOI in jpeg_finish_decompress */
+
+
+/* Declarations for compression modules */
+
+/* Master control module */
+struct jpeg_comp_master {
+  JMETHOD(void, prepare_for_pass, (j_compress_ptr cinfo));
+  JMETHOD(void, pass_startup, (j_compress_ptr cinfo));
+  JMETHOD(void, finish_pass, (j_compress_ptr cinfo));
+
+  /* State variables made visible to other modules */
+  boolean call_pass_startup;	/* True if pass_startup must be called */
+  boolean is_last_pass;		/* True during last pass */
+};
+
+/* Main buffer control (downsampled-data buffer) */
+struct jpeg_c_main_controller {
+  JMETHOD(void, start_pass, (j_compress_ptr cinfo, J_BUF_MODE pass_mode));
+  JMETHOD(void, process_data, (j_compress_ptr cinfo,
+			       JSAMPARRAY input_buf, JDIMENSION *in_row_ctr,
+			       JDIMENSION in_rows_avail));
+};
+
+/* Compression preprocessing (downsampling input buffer control) */
+struct jpeg_c_prep_controller {
+  JMETHOD(void, start_pass, (j_compress_ptr cinfo, J_BUF_MODE pass_mode));
+  JMETHOD(void, pre_process_data, (j_compress_ptr cinfo,
+				   JSAMPARRAY input_buf,
+				   JDIMENSION *in_row_ctr,
+				   JDIMENSION in_rows_avail,
+				   JSAMPIMAGE output_buf,
+				   JDIMENSION *out_row_group_ctr,
+				   JDIMENSION out_row_groups_avail));
+};
+
+/* Coefficient buffer control */
+struct jpeg_c_coef_controller {
+  JMETHOD(void, start_pass, (j_compress_ptr cinfo, J_BUF_MODE pass_mode));
+  JMETHOD(boolean, compress_data, (j_compress_ptr cinfo,
+				   JSAMPIMAGE input_buf));
+};
+
+/* Colorspace conversion */
+struct jpeg_color_converter {
+  JMETHOD(void, start_pass, (j_compress_ptr cinfo));
+  JMETHOD(void, color_convert, (j_compress_ptr cinfo,
+				JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+				JDIMENSION output_row, int num_rows));
+};
+
+/* Downsampling */
+struct jpeg_downsampler {
+  JMETHOD(void, start_pass, (j_compress_ptr cinfo));
+  JMETHOD(void, downsample, (j_compress_ptr cinfo,
+			     JSAMPIMAGE input_buf, JDIMENSION in_row_index,
+			     JSAMPIMAGE output_buf,
+			     JDIMENSION out_row_group_index));
+
+  boolean need_context_rows;	/* TRUE if need rows above & below */
+};
+
+/* Forward DCT (also controls coefficient quantization) */
+typedef JMETHOD(void, forward_DCT_ptr,
+		(j_compress_ptr cinfo, jpeg_component_info * compptr,
+		 JSAMPARRAY sample_data, JBLOCKROW coef_blocks,
+		 JDIMENSION start_row, JDIMENSION start_col,
+		 JDIMENSION num_blocks));
+
+struct jpeg_forward_dct {
+  JMETHOD(void, start_pass, (j_compress_ptr cinfo));
+  /* It is useful to allow each component to have a separate FDCT method. */
+  forward_DCT_ptr forward_DCT[MAX_COMPONENTS];
+};
+
+/* Entropy encoding */
+struct jpeg_entropy_encoder {
+  JMETHOD(void, start_pass, (j_compress_ptr cinfo, boolean gather_statistics));
+  JMETHOD(boolean, encode_mcu, (j_compress_ptr cinfo, JBLOCKROW *MCU_data));
+  JMETHOD(void, finish_pass, (j_compress_ptr cinfo));
+};
+
+/* Marker writing */
+struct jpeg_marker_writer {
+  JMETHOD(void, write_file_header, (j_compress_ptr cinfo));
+  JMETHOD(void, write_frame_header, (j_compress_ptr cinfo));
+  JMETHOD(void, write_scan_header, (j_compress_ptr cinfo));
+  JMETHOD(void, write_file_trailer, (j_compress_ptr cinfo));
+  JMETHOD(void, write_tables_only, (j_compress_ptr cinfo));
+  /* These routines are exported to allow insertion of extra markers */
+  /* Probably only COM and APPn markers should be written this way */
+  JMETHOD(void, write_marker_header, (j_compress_ptr cinfo, int marker,
+				      unsigned int datalen));
+  JMETHOD(void, write_marker_byte, (j_compress_ptr cinfo, int val));
+};
+
+
+/* Declarations for decompression modules */
+
+/* Master control module */
+struct jpeg_decomp_master {
+  JMETHOD(void, prepare_for_output_pass, (j_decompress_ptr cinfo));
+  JMETHOD(void, finish_output_pass, (j_decompress_ptr cinfo));
+
+  /* State variables made visible to other modules */
+  boolean is_dummy_pass;	/* True during 1st pass for 2-pass quant */
+};
+
+/* Input control module */
+struct jpeg_input_controller {
+  JMETHOD(int, consume_input, (j_decompress_ptr cinfo));
+  JMETHOD(void, reset_input_controller, (j_decompress_ptr cinfo));
+  JMETHOD(void, start_input_pass, (j_decompress_ptr cinfo));
+  JMETHOD(void, finish_input_pass, (j_decompress_ptr cinfo));
+
+  /* State variables made visible to other modules */
+  boolean has_multiple_scans;	/* True if file has multiple scans */
+  boolean eoi_reached;		/* True when EOI has been consumed */
+};
+
+/* Main buffer control (downsampled-data buffer) */
+struct jpeg_d_main_controller {
+  JMETHOD(void, start_pass, (j_decompress_ptr cinfo, J_BUF_MODE pass_mode));
+  JMETHOD(void, process_data, (j_decompress_ptr cinfo,
+			       JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
+			       JDIMENSION out_rows_avail));
+};
+
+/* Coefficient buffer control */
+struct jpeg_d_coef_controller {
+  JMETHOD(void, start_input_pass, (j_decompress_ptr cinfo));
+  JMETHOD(int, consume_data, (j_decompress_ptr cinfo));
+  JMETHOD(void, start_output_pass, (j_decompress_ptr cinfo));
+  JMETHOD(int, decompress_data, (j_decompress_ptr cinfo,
+				 JSAMPIMAGE output_buf));
+  /* Pointer to array of coefficient virtual arrays, or NULL if none */
+  jvirt_barray_ptr *coef_arrays;
+};
+
+/* Decompression postprocessing (color quantization buffer control) */
+struct jpeg_d_post_controller {
+  JMETHOD(void, start_pass, (j_decompress_ptr cinfo, J_BUF_MODE pass_mode));
+  JMETHOD(void, post_process_data, (j_decompress_ptr cinfo,
+				    JSAMPIMAGE input_buf,
+				    JDIMENSION *in_row_group_ctr,
+				    JDIMENSION in_row_groups_avail,
+				    JSAMPARRAY output_buf,
+				    JDIMENSION *out_row_ctr,
+				    JDIMENSION out_rows_avail));
+};
+
+/* Marker reading & parsing */
+struct jpeg_marker_reader {
+  JMETHOD(void, reset_marker_reader, (j_decompress_ptr cinfo));
+  /* Read markers until SOS or EOI.
+   * Returns same codes as are defined for jpeg_consume_input:
+   * JPEG_SUSPENDED, JPEG_REACHED_SOS, or JPEG_REACHED_EOI.
+   */
+  JMETHOD(int, read_markers, (j_decompress_ptr cinfo));
+  /* Read a restart marker --- exported for use by entropy decoder only */
+  jpeg_marker_parser_method read_restart_marker;
+
+  /* State of marker reader --- nominally internal, but applications
+   * supplying COM or APPn handlers might like to know the state.
+   */
+  boolean saw_SOI;		/* found SOI? */
+  boolean saw_SOF;		/* found SOF? */
+  int next_restart_num;		/* next restart number expected (0-7) */
+  unsigned int discarded_bytes;	/* # of bytes skipped looking for a marker */
+};
+
+/* Entropy decoding */
+struct jpeg_entropy_decoder {
+  JMETHOD(void, start_pass, (j_decompress_ptr cinfo));
+  JMETHOD(boolean, decode_mcu, (j_decompress_ptr cinfo,
+				JBLOCKROW *MCU_data));
+};
+
+/* Inverse DCT (also performs dequantization) */
+typedef JMETHOD(void, inverse_DCT_method_ptr,
+		(j_decompress_ptr cinfo, jpeg_component_info * compptr,
+		 JCOEFPTR coef_block,
+		 JSAMPARRAY output_buf, JDIMENSION output_col));
+
+struct jpeg_inverse_dct {
+  JMETHOD(void, start_pass, (j_decompress_ptr cinfo));
+  /* It is useful to allow each component to have a separate IDCT method. */
+  inverse_DCT_method_ptr inverse_DCT[MAX_COMPONENTS];
+};
+
+/* Upsampling (note that upsampler must also call color converter) */
+struct jpeg_upsampler {
+  JMETHOD(void, start_pass, (j_decompress_ptr cinfo));
+  JMETHOD(void, upsample, (j_decompress_ptr cinfo,
+			   JSAMPIMAGE input_buf,
+			   JDIMENSION *in_row_group_ctr,
+			   JDIMENSION in_row_groups_avail,
+			   JSAMPARRAY output_buf,
+			   JDIMENSION *out_row_ctr,
+			   JDIMENSION out_rows_avail));
+
+  boolean need_context_rows;	/* TRUE if need rows above & below */
+};
+
+/* Colorspace conversion */
+struct jpeg_color_deconverter {
+  JMETHOD(void, start_pass, (j_decompress_ptr cinfo));
+  JMETHOD(void, color_convert, (j_decompress_ptr cinfo,
+				JSAMPIMAGE input_buf, JDIMENSION input_row,
+				JSAMPARRAY output_buf, int num_rows));
+};
+
+/* Color quantization or color precision reduction */
+struct jpeg_color_quantizer {
+  JMETHOD(void, start_pass, (j_decompress_ptr cinfo, boolean is_pre_scan));
+  JMETHOD(void, color_quantize, (j_decompress_ptr cinfo,
+				 JSAMPARRAY input_buf, JSAMPARRAY output_buf,
+				 int num_rows));
+  JMETHOD(void, finish_pass, (j_decompress_ptr cinfo));
+  JMETHOD(void, new_color_map, (j_decompress_ptr cinfo));
+};
+
+
+/* Miscellaneous useful macros */
+
+#undef MAX
+#define MAX(a,b)	((a) > (b) ? (a) : (b))
+#undef MIN
+#define MIN(a,b)	((a) < (b) ? (a) : (b))
+
+
+/* We assume that right shift corresponds to signed division by 2 with
+ * rounding towards minus infinity.  This is correct for typical "arithmetic
+ * shift" instructions that shift in copies of the sign bit.  But some
+ * C compilers implement >> with an unsigned shift.  For these machines you
+ * must define RIGHT_SHIFT_IS_UNSIGNED.
+ * RIGHT_SHIFT provides a proper signed right shift of an INT32 quantity.
+ * It is only applied with constant shift counts.  SHIFT_TEMPS must be
+ * included in the variables of any routine using RIGHT_SHIFT.
+ */
+
+#ifdef RIGHT_SHIFT_IS_UNSIGNED
+#define SHIFT_TEMPS	INT32 shift_temp;
+#define RIGHT_SHIFT(x,shft)  \
+	((shift_temp = (x)) < 0 ? \
+	 (shift_temp >> (shft)) | ((~((INT32) 0)) << (32-(shft))) : \
+	 (shift_temp >> (shft)))
+#else
+#define SHIFT_TEMPS
+#define RIGHT_SHIFT(x,shft)	((x) >> (shft))
+#endif
+
+
+/* Short forms of external names for systems with brain-damaged linkers. */
+
+#ifdef NEED_SHORT_EXTERNAL_NAMES
+#define jinit_compress_master	jICompress
+#define jinit_c_master_control	jICMaster
+#define jinit_c_main_controller	jICMainC
+#define jinit_c_prep_controller	jICPrepC
+#define jinit_c_coef_controller	jICCoefC
+#define jinit_color_converter	jICColor
+#define jinit_downsampler	jIDownsampler
+#define jinit_forward_dct	jIFDCT
+#define jinit_huff_encoder	jIHEncoder
+#define jinit_arith_encoder	jIAEncoder
+#define jinit_marker_writer	jIMWriter
+#define jinit_master_decompress	jIDMaster
+#define jinit_d_main_controller	jIDMainC
+#define jinit_d_coef_controller	jIDCoefC
+#define jinit_d_post_controller	jIDPostC
+#define jinit_input_controller	jIInCtlr
+#define jinit_marker_reader	jIMReader
+#define jinit_huff_decoder	jIHDecoder
+#define jinit_arith_decoder	jIADecoder
+#define jinit_inverse_dct	jIIDCT
+#define jinit_upsampler		jIUpsampler
+#define jinit_color_deconverter	jIDColor
+#define jinit_1pass_quantizer	jI1Quant
+#define jinit_2pass_quantizer	jI2Quant
+#define jinit_merged_upsampler	jIMUpsampler
+#define jinit_memory_mgr	jIMemMgr
+#define jdiv_round_up		jDivRound
+#define jround_up		jRound
+#define jcopy_sample_rows	jCopySamples
+#define jcopy_block_row		jCopyBlocks
+#define jzero_far		jZeroFar
+#define jpeg_zigzag_order	jZIGTable
+#define jpeg_natural_order	jZAGTable
+#define jpeg_natural_order7	jZAGTable7
+#define jpeg_natural_order6	jZAGTable6
+#define jpeg_natural_order5	jZAGTable5
+#define jpeg_natural_order4	jZAGTable4
+#define jpeg_natural_order3	jZAGTable3
+#define jpeg_natural_order2	jZAGTable2
+#define jpeg_aritab		jAriTab
+#endif /* NEED_SHORT_EXTERNAL_NAMES */
+
+
+/* Compression module initialization routines */
+EXTERN(void) jinit_compress_master JPP((j_compress_ptr cinfo));
+EXTERN(void) jinit_c_master_control JPP((j_compress_ptr cinfo,
+					 boolean transcode_only));
+EXTERN(void) jinit_c_main_controller JPP((j_compress_ptr cinfo,
+					  boolean need_full_buffer));
+EXTERN(void) jinit_c_prep_controller JPP((j_compress_ptr cinfo,
+					  boolean need_full_buffer));
+EXTERN(void) jinit_c_coef_controller JPP((j_compress_ptr cinfo,
+					  boolean need_full_buffer));
+EXTERN(void) jinit_color_converter JPP((j_compress_ptr cinfo));
+EXTERN(void) jinit_downsampler JPP((j_compress_ptr cinfo));
+EXTERN(void) jinit_forward_dct JPP((j_compress_ptr cinfo));
+EXTERN(void) jinit_huff_encoder JPP((j_compress_ptr cinfo));
+EXTERN(void) jinit_arith_encoder JPP((j_compress_ptr cinfo));
+EXTERN(void) jinit_marker_writer JPP((j_compress_ptr cinfo));
+/* Decompression module initialization routines */
+EXTERN(void) jinit_master_decompress JPP((j_decompress_ptr cinfo));
+EXTERN(void) jinit_d_main_controller JPP((j_decompress_ptr cinfo,
+					  boolean need_full_buffer));
+EXTERN(void) jinit_d_coef_controller JPP((j_decompress_ptr cinfo,
+					  boolean need_full_buffer));
+EXTERN(void) jinit_d_post_controller JPP((j_decompress_ptr cinfo,
+					  boolean need_full_buffer));
+EXTERN(void) jinit_input_controller JPP((j_decompress_ptr cinfo));
+EXTERN(void) jinit_marker_reader JPP((j_decompress_ptr cinfo));
+EXTERN(void) jinit_huff_decoder JPP((j_decompress_ptr cinfo));
+EXTERN(void) jinit_arith_decoder JPP((j_decompress_ptr cinfo));
+EXTERN(void) jinit_inverse_dct JPP((j_decompress_ptr cinfo));
+EXTERN(void) jinit_upsampler JPP((j_decompress_ptr cinfo));
+EXTERN(void) jinit_color_deconverter JPP((j_decompress_ptr cinfo));
+EXTERN(void) jinit_1pass_quantizer JPP((j_decompress_ptr cinfo));
+EXTERN(void) jinit_2pass_quantizer JPP((j_decompress_ptr cinfo));
+EXTERN(void) jinit_merged_upsampler JPP((j_decompress_ptr cinfo));
+/* Memory manager initialization */
+EXTERN(void) jinit_memory_mgr JPP((j_common_ptr cinfo));
+
+/* Utility routines in jutils.c */
+EXTERN(long) jdiv_round_up JPP((long a, long b));
+EXTERN(long) jround_up JPP((long a, long b));
+EXTERN(void) jcopy_sample_rows JPP((JSAMPARRAY input_array, int source_row,
+				    JSAMPARRAY output_array, int dest_row,
+				    int num_rows, JDIMENSION num_cols));
+EXTERN(void) jcopy_block_row JPP((JBLOCKROW input_row, JBLOCKROW output_row,
+				  JDIMENSION num_blocks));
+EXTERN(void) jzero_far JPP((void FAR * target, size_t bytestozero));
+/* Constant tables in jutils.c */
+#if 0				/* This table is not actually needed in v6a */
+extern const int jpeg_zigzag_order[]; /* natural coef order to zigzag order */
+#endif
+extern const int jpeg_natural_order[]; /* zigzag coef order to natural order */
+extern const int jpeg_natural_order7[]; /* zz to natural order for 7x7 block */
+extern const int jpeg_natural_order6[]; /* zz to natural order for 6x6 block */
+extern const int jpeg_natural_order5[]; /* zz to natural order for 5x5 block */
+extern const int jpeg_natural_order4[]; /* zz to natural order for 4x4 block */
+extern const int jpeg_natural_order3[]; /* zz to natural order for 3x3 block */
+extern const int jpeg_natural_order2[]; /* zz to natural order for 2x2 block */
+
+/* Arithmetic coding probability estimation tables in jaricom.c */
+extern const INT32 jpeg_aritab[];
+
+/* Suppress undefined-structure complaints if necessary. */
+
+#ifdef INCOMPLETE_TYPES_BROKEN
+#ifndef AM_MEMORY_MANAGER	/* only jmemmgr.c defines these */
+struct jvirt_sarray_control { long dummy; };
+struct jvirt_barray_control { long dummy; };
+#endif
+#endif /* INCOMPLETE_TYPES_BROKEN */
diff --git a/lib/a2jpeg/jpeglib.h b/lib/a2jpeg/jpeglib.h
new file mode 100644
index 0000000..5039d4b
--- /dev/null
+++ b/lib/a2jpeg/jpeglib.h
@@ -0,0 +1,1158 @@
+/*
+ * jpeglib.h
+ *
+ * Copyright (C) 1991-1998, Thomas G. Lane.
+ * Modified 2002-2009 by Guido Vollbeding.
+ * This file is part of the Independent JPEG Group's software.
+ * For conditions of distribution and use, see the accompanying README file.
+ *
+ * This file defines the application interface for the JPEG library.
+ * Most applications using the library need only include this file,
+ * and perhaps jerror.h if they want to know the exact error codes.
+ */
+
+#ifndef JPEGLIB_H
+#define JPEGLIB_H
+
+/*
+ * First we include the configuration files that record how this
+ * installation of the JPEG library is set up.  jconfig.h can be
+ * generated automatically for many systems.  jmorecfg.h contains
+ * manual configuration options that most people need not worry about.
+ */
+
+#ifndef JCONFIG_INCLUDED	/* in case jinclude.h already did */
+#include "jconfig.h"		/* widely used configuration options */
+#endif
+#include "jmorecfg.h"		/* seldom changed options */
+
+
+#ifdef __cplusplus
+#ifndef DONT_USE_EXTERN_C
+extern "C" {
+#endif
+#endif
+
+/* Version ID for the JPEG library.
+ * Might be useful for tests like "#if JPEG_LIB_VERSION >= 80".
+ */
+
+#define JPEG_LIB_VERSION  80	/* Version 8.0 */
+
+
+/* Various constants determining the sizes of things.
+ * All of these are specified by the JPEG standard, so don't change them
+ * if you want to be compatible.
+ */
+
+#define DCTSIZE		    8	/* The basic DCT block is 8x8 samples */
+#define DCTSIZE2	    64	/* DCTSIZE squared; # of elements in a block */
+#define NUM_QUANT_TBLS      4	/* Quantization tables are numbered 0..3 */
+#define NUM_HUFF_TBLS       4	/* Huffman tables are numbered 0..3 */
+#define NUM_ARITH_TBLS      16	/* Arith-coding tables are numbered 0..15 */
+#define MAX_COMPS_IN_SCAN   4	/* JPEG limit on # of components in one scan */
+#define MAX_SAMP_FACTOR     4	/* JPEG limit on sampling factors */
+/* Unfortunately, some bozo at Adobe saw no reason to be bound by the standard;
+ * the PostScript DCT filter can emit files with many more than 10 blocks/MCU.
+ * If you happen to run across such a file, you can up D_MAX_BLOCKS_IN_MCU
+ * to handle it.  We even let you do this from the jconfig.h file.  However,
+ * we strongly discourage changing C_MAX_BLOCKS_IN_MCU; just because Adobe
+ * sometimes emits noncompliant files doesn't mean you should too.
+ */
+#define C_MAX_BLOCKS_IN_MCU   10 /* compressor's limit on blocks per MCU */
+#ifndef D_MAX_BLOCKS_IN_MCU
+#define D_MAX_BLOCKS_IN_MCU   10 /* decompressor's limit on blocks per MCU */
+#endif
+
+
+/* Data structures for images (arrays of samples and of DCT coefficients).
+ * On 80x86 machines, the image arrays are too big for near pointers,
+ * but the pointer arrays can fit in near memory.
+ */
+
+typedef JSAMPLE FAR *JSAMPROW;	/* ptr to one image row of pixel samples. */
+typedef JSAMPROW *JSAMPARRAY;	/* ptr to some rows (a 2-D sample array) */
+typedef JSAMPARRAY *JSAMPIMAGE;	/* a 3-D sample array: top index is color */
+
+typedef JCOEF JBLOCK[DCTSIZE2];	/* one block of coefficients */
+typedef JBLOCK FAR *JBLOCKROW;	/* pointer to one row of coefficient blocks */
+typedef JBLOCKROW *JBLOCKARRAY;		/* a 2-D array of coefficient blocks */
+typedef JBLOCKARRAY *JBLOCKIMAGE;	/* a 3-D array of coefficient blocks */
+
+typedef JCOEF FAR *JCOEFPTR;	/* useful in a couple of places */
+
+
+/* Types for JPEG compression parameters and working tables. */
+
+
+/* DCT coefficient quantization tables. */
+
+typedef struct {
+  /* This array gives the coefficient quantizers in natural array order
+   * (not the zigzag order in which they are stored in a JPEG DQT marker).
+   * CAUTION: IJG versions prior to v6a kept this array in zigzag order.
+   */
+  UINT16 quantval[DCTSIZE2];	/* quantization step for each coefficient */
+  /* This field is used only during compression.  It's initialized FALSE when
+   * the table is created, and set TRUE when it's been output to the file.
+   * You could suppress output of a table by setting this to TRUE.
+   * (See jpeg_suppress_tables for an example.)
+   */
+  boolean sent_table;		/* TRUE when table has been output */
+} JQUANT_TBL;
+
+
+/* Huffman coding tables. */
+
+typedef struct {
+  /* These two fields directly represent the contents of a JPEG DHT marker */
+  UINT8 bits[17];		/* bits[k] = # of symbols with codes of */
+				/* length k bits; bits[0] is unused */
+  UINT8 huffval[256];		/* The symbols, in order of incr code length */
+  /* This field is used only during compression.  It's initialized FALSE when
+   * the table is created, and set TRUE when it's been output to the file.
+   * You could suppress output of a table by setting this to TRUE.
+   * (See jpeg_suppress_tables for an example.)
+   */
+  boolean sent_table;		/* TRUE when table has been output */
+} JHUFF_TBL;
+
+
+/* Basic info about one component (color channel). */
+
+typedef struct {
+  /* These values are fixed over the whole image. */
+  /* For compression, they must be supplied by parameter setup; */
+  /* for decompression, they are read from the SOF marker. */
+  int component_id;		/* identifier for this component (0..255) */
+  int component_index;		/* its index in SOF or cinfo->comp_info[] */
+  int h_samp_factor;		/* horizontal sampling factor (1..4) */
+  int v_samp_factor;		/* vertical sampling factor (1..4) */
+  int quant_tbl_no;		/* quantization table selector (0..3) */
+  /* These values may vary between scans. */
+  /* For compression, they must be supplied by parameter setup; */
+  /* for decompression, they are read from the SOS marker. */
+  /* The decompressor output side may not use these variables. */
+  int dc_tbl_no;		/* DC entropy table selector (0..3) */
+  int ac_tbl_no;		/* AC entropy table selector (0..3) */
+  
+  /* Remaining fields should be treated as private by applications. */
+  
+  /* These values are computed during compression or decompression startup: */
+  /* Component's size in DCT blocks.
+   * Any dummy blocks added to complete an MCU are not counted; therefore
+   * these values do not depend on whether a scan is interleaved or not.
+   */
+  JDIMENSION width_in_blocks;
+  JDIMENSION height_in_blocks;
+  /* Size of a DCT block in samples,
+   * reflecting any scaling we choose to apply during the DCT step.
+   * Values from 1 to 16 are supported.
+   * Note that different components may receive different DCT scalings.
+   */
+  int DCT_h_scaled_size;
+  int DCT_v_scaled_size;
+  /* The downsampled dimensions are the component's actual, unpadded number
+   * of samples at the main buffer (preprocessing/compression interface);
+   * DCT scaling is included, so
+   * downsampled_width = ceil(image_width * Hi/Hmax * DCT_h_scaled_size/DCTSIZE)
+   * and similarly for height.
+   */
+  JDIMENSION downsampled_width;	 /* actual width in samples */
+  JDIMENSION downsampled_height; /* actual height in samples */
+  /* This flag is used only for decompression.  In cases where some of the
+   * components will be ignored (eg grayscale output from YCbCr image),
+   * we can skip most computations for the unused components.
+   */
+  boolean component_needed;	/* do we need the value of this component? */
+
+  /* These values are computed before starting a scan of the component. */
+  /* The decompressor output side may not use these variables. */
+  int MCU_width;		/* number of blocks per MCU, horizontally */
+  int MCU_height;		/* number of blocks per MCU, vertically */
+  int MCU_blocks;		/* MCU_width * MCU_height */
+  int MCU_sample_width;	/* MCU width in samples: MCU_width * DCT_h_scaled_size */
+  int last_col_width;		/* # of non-dummy blocks across in last MCU */
+  int last_row_height;		/* # of non-dummy blocks down in last MCU */
+
+  /* Saved quantization table for component; NULL if none yet saved.
+   * See jdinput.c comments about the need for this information.
+   * This field is currently used only for decompression.
+   */
+  JQUANT_TBL * quant_table;
+
+  /* Private per-component storage for DCT or IDCT subsystem. */
+  void * dct_table;
+} jpeg_component_info;
+
+
+/* The script for encoding a multiple-scan file is an array of these: */
+
+typedef struct {
+  int comps_in_scan;		/* number of components encoded in this scan */
+  int component_index[MAX_COMPS_IN_SCAN]; /* their SOF/comp_info[] indexes */
+  int Ss, Se;			/* progressive JPEG spectral selection parms */
+  int Ah, Al;			/* progressive JPEG successive approx. parms */
+} jpeg_scan_info;
+
+/* The decompressor can save APPn and COM markers in a list of these: */
+
+typedef struct jpeg_marker_struct FAR * jpeg_saved_marker_ptr;
+
+struct jpeg_marker_struct {
+  jpeg_saved_marker_ptr next;	/* next in list, or NULL */
+  UINT8 marker;			/* marker code: JPEG_COM, or JPEG_APP0+n */
+  unsigned int original_length;	/* # bytes of data in the file */
+  unsigned int data_length;	/* # bytes of data saved at data[] */
+  JOCTET FAR * data;		/* the data contained in the marker */
+  /* the marker length word is not counted in data_length or original_length */
+};
+
+/* Known color spaces. */
+
+typedef enum {
+	JCS_UNKNOWN,		/* error/unspecified */
+	JCS_GRAYSCALE,		/* monochrome */
+	JCS_RGB,		/* red/green/blue */
+	JCS_YCbCr,		/* Y/Cb/Cr (also known as YUV) */
+	JCS_CMYK,		/* C/M/Y/K */
+	JCS_YCCK		/* Y/Cb/Cr/K */
+} J_COLOR_SPACE;
+
+/* DCT/IDCT algorithm options. */
+
+typedef enum {
+	JDCT_ISLOW,		/* slow but accurate integer algorithm */
+	JDCT_IFAST,		/* faster, less accurate integer method */
+	JDCT_FLOAT		/* floating-point: accurate, fast on fast HW */
+} J_DCT_METHOD;
+
+#ifndef JDCT_DEFAULT		/* may be overridden in jconfig.h */
+#define JDCT_DEFAULT  JDCT_ISLOW
+#endif
+#ifndef JDCT_FASTEST		/* may be overridden in jconfig.h */
+#define JDCT_FASTEST  JDCT_IFAST
+#endif
+
+/* Dithering options for decompression. */
+
+typedef enum {
+	JDITHER_NONE,		/* no dithering */
+	JDITHER_ORDERED,	/* simple ordered dither */
+	JDITHER_FS		/* Floyd-Steinberg error diffusion dither */
+} J_DITHER_MODE;
+
+
+/* Common fields between JPEG compression and decompression master structs. */
+
+#define jpeg_common_fields \
+  struct jpeg_error_mgr * err;	/* Error handler module */\
+  struct jpeg_memory_mgr * mem;	/* Memory manager module */\
+  struct jpeg_progress_mgr * progress; /* Progress monitor, or NULL if none */\
+  void * client_data;		/* Available for use by application */\
+  boolean is_decompressor;	/* So common code can tell which is which */\
+  int global_state		/* For checking call sequence validity */
+
+/* Routines that are to be used by both halves of the library are declared
+ * to receive a pointer to this structure.  There are no actual instances of
+ * jpeg_common_struct, only of jpeg_compress_struct and jpeg_decompress_struct.
+ */
+struct jpeg_common_struct {
+  jpeg_common_fields;		/* Fields common to both master struct types */
+  /* Additional fields follow in an actual jpeg_compress_struct or
+   * jpeg_decompress_struct.  All three structs must agree on these
+   * initial fields!  (This would be a lot cleaner in C++.)
+   */
+};
+
+typedef struct jpeg_common_struct * j_common_ptr;
+typedef struct jpeg_compress_struct * j_compress_ptr;
+typedef struct jpeg_decompress_struct * j_decompress_ptr;
+
+
+/* Master record for a compression instance */
+
+struct jpeg_compress_struct {
+  jpeg_common_fields;		/* Fields shared with jpeg_decompress_struct */
+
+  /* Destination for compressed data */
+  struct jpeg_destination_mgr * dest;
+
+  /* Description of source image --- these fields must be filled in by
+   * outer application before starting compression.  in_color_space must
+   * be correct before you can even call jpeg_set_defaults().
+   */
+
+  JDIMENSION image_width;	/* input image width */
+  JDIMENSION image_height;	/* input image height */
+  int input_components;		/* # of color components in input image */
+  J_COLOR_SPACE in_color_space;	/* colorspace of input image */
+
+  double input_gamma;		/* image gamma of input image */
+
+  /* Compression parameters --- these fields must be set before calling
+   * jpeg_start_compress().  We recommend calling jpeg_set_defaults() to
+   * initialize everything to reasonable defaults, then changing anything
+   * the application specifically wants to change.  That way you won't get
+   * burnt when new parameters are added.  Also note that there are several
+   * helper routines to simplify changing parameters.
+   */
+
+  unsigned int scale_num, scale_denom; /* fraction by which to scale image */
+
+  JDIMENSION jpeg_width;	/* scaled JPEG image width */
+  JDIMENSION jpeg_height;	/* scaled JPEG image height */
+  /* Dimensions of actual JPEG image that will be written to file,
+   * derived from input dimensions by scaling factors above.
+   * These fields are computed by jpeg_start_compress().
+   * You can also use jpeg_calc_jpeg_dimensions() to determine these values
+   * in advance of calling jpeg_start_compress().
+   */
+
+  int data_precision;		/* bits of precision in image data */
+
+  int num_components;		/* # of color components in JPEG image */
+  J_COLOR_SPACE jpeg_color_space; /* colorspace of JPEG image */
+
+  jpeg_component_info * comp_info;
+  /* comp_info[i] describes component that appears i'th in SOF */
+
+  JQUANT_TBL * quant_tbl_ptrs[NUM_QUANT_TBLS];
+  int q_scale_factor[NUM_QUANT_TBLS];
+  /* ptrs to coefficient quantization tables, or NULL if not defined,
+   * and corresponding scale factors (percentage, initialized 100).
+   */
+
+  JHUFF_TBL * dc_huff_tbl_ptrs[NUM_HUFF_TBLS];
+  JHUFF_TBL * ac_huff_tbl_ptrs[NUM_HUFF_TBLS];
+  /* ptrs to Huffman coding tables, or NULL if not defined */
+
+  UINT8 arith_dc_L[NUM_ARITH_TBLS]; /* L values for DC arith-coding tables */
+  UINT8 arith_dc_U[NUM_ARITH_TBLS]; /* U values for DC arith-coding tables */
+  UINT8 arith_ac_K[NUM_ARITH_TBLS]; /* Kx values for AC arith-coding tables */
+
+  int num_scans;		/* # of entries in scan_info array */
+  const jpeg_scan_info * scan_info; /* script for multi-scan file, or NULL */
+  /* The default value of scan_info is NULL, which causes a single-scan
+   * sequential JPEG file to be emitted.  To create a multi-scan file,
+   * set num_scans and scan_info to point to an array of scan definitions.
+   */
+
+  boolean raw_data_in;		/* TRUE=caller supplies downsampled data */
+  boolean arith_code;		/* TRUE=arithmetic coding, FALSE=Huffman */
+  boolean optimize_coding;	/* TRUE=optimize entropy encoding parms */
+  boolean CCIR601_sampling;	/* TRUE=first samples are cosited */
+  boolean do_fancy_downsampling; /* TRUE=apply fancy downsampling */
+  int smoothing_factor;		/* 1..100, or 0 for no input smoothing */
+  J_DCT_METHOD dct_method;	/* DCT algorithm selector */
+
+  /* The restart interval can be specified in absolute MCUs by setting
+   * restart_interval, or in MCU rows by setting restart_in_rows
+   * (in which case the correct restart_interval will be figured
+   * for each scan).
+   */
+  unsigned int restart_interval; /* MCUs per restart, or 0 for no restart */
+  int restart_in_rows;		/* if > 0, MCU rows per restart interval */
+
+  /* Parameters controlling emission of special markers. */
+
+  boolean write_JFIF_header;	/* should a JFIF marker be written? */
+  UINT8 JFIF_major_version;	/* What to write for the JFIF version number */
+  UINT8 JFIF_minor_version;
+  /* These three values are not used by the JPEG code, merely copied */
+  /* into the JFIF APP0 marker.  density_unit can be 0 for unknown, */
+  /* 1 for dots/inch, or 2 for dots/cm.  Note that the pixel aspect */
+  /* ratio is defined by X_density/Y_density even when density_unit=0. */
+  UINT8 density_unit;		/* JFIF code for pixel size units */
+  UINT16 X_density;		/* Horizontal pixel density */
+  UINT16 Y_density;		/* Vertical pixel density */
+  boolean write_Adobe_marker;	/* should an Adobe marker be written? */
+  
+  /* State variable: index of next scanline to be written to
+   * jpeg_write_scanlines().  Application may use this to control its
+   * processing loop, e.g., "while (next_scanline < image_height)".
+   */
+
+  JDIMENSION next_scanline;	/* 0 .. image_height-1  */
+
+  /* Remaining fields are known throughout compressor, but generally
+   * should not be touched by a surrounding application.
+   */
+
+  /*
+   * These fields are computed during compression startup
+   */
+  boolean progressive_mode;	/* TRUE if scan script uses progressive mode */
+  int max_h_samp_factor;	/* largest h_samp_factor */
+  int max_v_samp_factor;	/* largest v_samp_factor */
+
+  int min_DCT_h_scaled_size;	/* smallest DCT_h_scaled_size of any component */
+  int min_DCT_v_scaled_size;	/* smallest DCT_v_scaled_size of any component */
+
+  JDIMENSION total_iMCU_rows;	/* # of iMCU rows to be input to coef ctlr */
+  /* The coefficient controller receives data in units of MCU rows as defined
+   * for fully interleaved scans (whether the JPEG file is interleaved or not).
+   * There are v_samp_factor * DCTSIZE sample rows of each component in an
+   * "iMCU" (interleaved MCU) row.
+   */
+  
+  /*
+   * These fields are valid during any one scan.
+   * They describe the components and MCUs actually appearing in the scan.
+   */
+  int comps_in_scan;		/* # of JPEG components in this scan */
+  jpeg_component_info * cur_comp_info[MAX_COMPS_IN_SCAN];
+  /* *cur_comp_info[i] describes component that appears i'th in SOS */
+  
+  JDIMENSION MCUs_per_row;	/* # of MCUs across the image */
+  JDIMENSION MCU_rows_in_scan;	/* # of MCU rows in the image */
+  
+  int blocks_in_MCU;		/* # of DCT blocks per MCU */
+  int MCU_membership[C_MAX_BLOCKS_IN_MCU];
+  /* MCU_membership[i] is index in cur_comp_info of component owning */
+  /* i'th block in an MCU */
+
+  int Ss, Se, Ah, Al;		/* progressive JPEG parameters for scan */
+
+  int block_size;		/* the basic DCT block size: 1..16 */
+  const int * natural_order;	/* natural-order position array */
+  int lim_Se;			/* min( Se, DCTSIZE2-1 ) */
+
+  /*
+   * Links to compression subobjects (methods and private variables of modules)
+   */
+  struct jpeg_comp_master * master;
+  struct jpeg_c_main_controller * main;
+  struct jpeg_c_prep_controller * prep;
+  struct jpeg_c_coef_controller * coef;
+  struct jpeg_marker_writer * marker;
+  struct jpeg_color_converter * cconvert;
+  struct jpeg_downsampler * downsample;
+  struct jpeg_forward_dct * fdct;
+  struct jpeg_entropy_encoder * entropy;
+  jpeg_scan_info * script_space; /* workspace for jpeg_simple_progression */
+  int script_space_size;
+};
+
+
+/* Master record for a decompression instance */
+
+struct jpeg_decompress_struct {
+  jpeg_common_fields;		/* Fields shared with jpeg_compress_struct */
+
+  /* Source of compressed data */
+  struct jpeg_source_mgr * src;
+
+  /* Basic description of image --- filled in by jpeg_read_header(). */
+  /* Application may inspect these values to decide how to process image. */
+
+  JDIMENSION image_width;	/* nominal image width (from SOF marker) */
+  JDIMENSION image_height;	/* nominal image height */
+  int num_components;		/* # of color components in JPEG image */
+  J_COLOR_SPACE jpeg_color_space; /* colorspace of JPEG image */
+
+  /* Decompression processing parameters --- these fields must be set before
+   * calling jpeg_start_decompress().  Note that jpeg_read_header() initializes
+   * them to default values.
+   */
+
+  J_COLOR_SPACE out_color_space; /* colorspace for output */
+
+  unsigned int scale_num, scale_denom; /* fraction by which to scale image */
+
+  double output_gamma;		/* image gamma wanted in output */
+
+  boolean buffered_image;	/* TRUE=multiple output passes */
+  boolean raw_data_out;		/* TRUE=downsampled data wanted */
+
+  J_DCT_METHOD dct_method;	/* IDCT algorithm selector */
+  boolean do_fancy_upsampling;	/* TRUE=apply fancy upsampling */
+  boolean do_block_smoothing;	/* TRUE=apply interblock smoothing */
+
+  boolean quantize_colors;	/* TRUE=colormapped output wanted */
+  /* the following are ignored if not quantize_colors: */
+  J_DITHER_MODE dither_mode;	/* type of color dithering to use */
+  boolean two_pass_quantize;	/* TRUE=use two-pass color quantization */
+  int desired_number_of_colors;	/* max # colors to use in created colormap */
+  /* these are significant only in buffered-image mode: */
+  boolean enable_1pass_quant;	/* enable future use of 1-pass quantizer */
+  boolean enable_external_quant;/* enable future use of external colormap */
+  boolean enable_2pass_quant;	/* enable future use of 2-pass quantizer */
+
+  /* Description of actual output image that will be returned to application.
+   * These fields are computed by jpeg_start_decompress().
+   * You can also use jpeg_calc_output_dimensions() to determine these values
+   * in advance of calling jpeg_start_decompress().
+   */
+
+  JDIMENSION output_width;	/* scaled image width */
+  JDIMENSION output_height;	/* scaled image height */
+  int out_color_components;	/* # of color components in out_color_space */
+  int output_components;	/* # of color components returned */
+  /* output_components is 1 (a colormap index) when quantizing colors;
+   * otherwise it equals out_color_components.
+   */
+  int rec_outbuf_height;	/* min recommended height of scanline buffer */
+  /* If the buffer passed to jpeg_read_scanlines() is less than this many rows
+   * high, space and time will be wasted due to unnecessary data copying.
+   * Usually rec_outbuf_height will be 1 or 2, at most 4.
+   */
+
+  /* When quantizing colors, the output colormap is described by these fields.
+   * The application can supply a colormap by setting colormap non-NULL before
+   * calling jpeg_start_decompress; otherwise a colormap is created during
+   * jpeg_start_decompress or jpeg_start_output.
+   * The map has out_color_components rows and actual_number_of_colors columns.
+   */
+  int actual_number_of_colors;	/* number of entries in use */
+  JSAMPARRAY colormap;		/* The color map as a 2-D pixel array */
+
+  /* State variables: these variables indicate the progress of decompression.
+   * The application may examine these but must not modify them.
+   */
+
+  /* Row index of next scanline to be read from jpeg_read_scanlines().
+   * Application may use this to control its processing loop, e.g.,
+   * "while (output_scanline < output_height)".
+   */
+  JDIMENSION output_scanline;	/* 0 .. output_height-1  */
+
+  /* Current input scan number and number of iMCU rows completed in scan.
+   * These indicate the progress of the decompressor input side.
+   */
+  int input_scan_number;	/* Number of SOS markers seen so far */
+  JDIMENSION input_iMCU_row;	/* Number of iMCU rows completed */
+
+  /* The "output scan number" is the notional scan being displayed by the
+   * output side.  The decompressor will not allow output scan/row number
+   * to get ahead of input scan/row, but it can fall arbitrarily far behind.
+   */
+  int output_scan_number;	/* Nominal scan number being displayed */
+  JDIMENSION output_iMCU_row;	/* Number of iMCU rows read */
+
+  /* Current progression status.  coef_bits[c][i] indicates the precision
+   * with which component c's DCT coefficient i (in zigzag order) is known.
+   * It is -1 when no data has yet been received, otherwise it is the point
+   * transform (shift) value for the most recent scan of the coefficient
+   * (thus, 0 at completion of the progression).
+   * This pointer is NULL when reading a non-progressive file.
+   */
+  int (*coef_bits)[DCTSIZE2];	/* -1 or current Al value for each coef */
+
+  /* Internal JPEG parameters --- the application usually need not look at
+   * these fields.  Note that the decompressor output side may not use
+   * any parameters that can change between scans.
+   */
+
+  /* Quantization and Huffman tables are carried forward across input
+   * datastreams when processing abbreviated JPEG datastreams.
+   */
+
+  JQUANT_TBL * quant_tbl_ptrs[NUM_QUANT_TBLS];
+  /* ptrs to coefficient quantization tables, or NULL if not defined */
+
+  JHUFF_TBL * dc_huff_tbl_ptrs[NUM_HUFF_TBLS];
+  JHUFF_TBL * ac_huff_tbl_ptrs[NUM_HUFF_TBLS];
+  /* ptrs to Huffman coding tables, or NULL if not defined */
+
+  /* These parameters are never carried across datastreams, since they
+   * are given in SOF/SOS markers or defined to be reset by SOI.
+   */
+
+  int data_precision;		/* bits of precision in image data */
+
+  jpeg_component_info * comp_info;
+  /* comp_info[i] describes component that appears i'th in SOF */
+
+  boolean is_baseline;		/* TRUE if Baseline SOF0 encountered */
+  boolean progressive_mode;	/* TRUE if SOFn specifies progressive mode */
+  boolean arith_code;		/* TRUE=arithmetic coding, FALSE=Huffman */
+
+  UINT8 arith_dc_L[NUM_ARITH_TBLS]; /* L values for DC arith-coding tables */
+  UINT8 arith_dc_U[NUM_ARITH_TBLS]; /* U values for DC arith-coding tables */
+  UINT8 arith_ac_K[NUM_ARITH_TBLS]; /* Kx values for AC arith-coding tables */
+
+  unsigned int restart_interval; /* MCUs per restart interval, or 0 for no restart */
+
+  /* These fields record data obtained from optional markers recognized by
+   * the JPEG library.
+   */
+  boolean saw_JFIF_marker;	/* TRUE iff a JFIF APP0 marker was found */
+  /* Data copied from JFIF marker; only valid if saw_JFIF_marker is TRUE: */
+  UINT8 JFIF_major_version;	/* JFIF version number */
+  UINT8 JFIF_minor_version;
+  UINT8 density_unit;		/* JFIF code for pixel size units */
+  UINT16 X_density;		/* Horizontal pixel density */
+  UINT16 Y_density;		/* Vertical pixel density */
+  boolean saw_Adobe_marker;	/* TRUE iff an Adobe APP14 marker was found */
+  UINT8 Adobe_transform;	/* Color transform code from Adobe marker */
+
+  boolean CCIR601_sampling;	/* TRUE=first samples are cosited */
+
+  /* Aside from the specific data retained from APPn markers known to the
+   * library, the uninterpreted contents of any or all APPn and COM markers
+   * can be saved in a list for examination by the application.
+   */
+  jpeg_saved_marker_ptr marker_list; /* Head of list of saved markers */
+
+  /* Remaining fields are known throughout decompressor, but generally
+   * should not be touched by a surrounding application.
+   */
+
+  /*
+   * These fields are computed during decompression startup
+   */
+  int max_h_samp_factor;	/* largest h_samp_factor */
+  int max_v_samp_factor;	/* largest v_samp_factor */
+
+  int min_DCT_h_scaled_size;	/* smallest DCT_h_scaled_size of any component */
+  int min_DCT_v_scaled_size;	/* smallest DCT_v_scaled_size of any component */
+
+  JDIMENSION total_iMCU_rows;	/* # of iMCU rows in image */
+  /* The coefficient controller's input and output progress is measured in
+   * units of "iMCU" (interleaved MCU) rows.  These are the same as MCU rows
+   * in fully interleaved JPEG scans, but are used whether the scan is
+   * interleaved or not.  We define an iMCU row as v_samp_factor DCT block
+   * rows of each component.  Therefore, the IDCT output contains
+   * v_samp_factor*DCT_v_scaled_size sample rows of a component per iMCU row.
+   */
+
+  JSAMPLE * sample_range_limit; /* table for fast range-limiting */
+
+  /*
+   * These fields are valid during any one scan.
+   * They describe the components and MCUs actually appearing in the scan.
+   * Note that the decompressor output side must not use these fields.
+   */
+  int comps_in_scan;		/* # of JPEG components in this scan */
+  jpeg_component_info * cur_comp_info[MAX_COMPS_IN_SCAN];
+  /* *cur_comp_info[i] describes component that appears i'th in SOS */
+
+  JDIMENSION MCUs_per_row;	/* # of MCUs across the image */
+  JDIMENSION MCU_rows_in_scan;	/* # of MCU rows in the image */
+
+  int blocks_in_MCU;		/* # of DCT blocks per MCU */
+  int MCU_membership[D_MAX_BLOCKS_IN_MCU];
+  /* MCU_membership[i] is index in cur_comp_info of component owning */
+  /* i'th block in an MCU */
+
+  int Ss, Se, Ah, Al;		/* progressive JPEG parameters for scan */
+
+  /* These fields are derived from Se of first SOS marker.
+   */
+  int block_size;		/* the basic DCT block size: 1..16 */
+  const int * natural_order; /* natural-order position array for entropy decode */
+  int lim_Se;			/* min( Se, DCTSIZE2-1 ) for entropy decode */
+
+  /* This field is shared between entropy decoder and marker parser.
+   * It is either zero or the code of a JPEG marker that has been
+   * read from the data source, but has not yet been processed.
+   */
+  int unread_marker;
+
+  /*
+   * Links to decompression subobjects (methods, private variables of modules)
+   */
+  struct jpeg_decomp_master * master;
+  struct jpeg_d_main_controller * main;
+  struct jpeg_d_coef_controller * coef;
+  struct jpeg_d_post_controller * post;
+  struct jpeg_input_controller * inputctl;
+  struct jpeg_marker_reader * marker;
+  struct jpeg_entropy_decoder * entropy;
+  struct jpeg_inverse_dct * idct;
+  struct jpeg_upsampler * upsample;
+  struct jpeg_color_deconverter * cconvert;
+  struct jpeg_color_quantizer * cquantize;
+};
+
+
+/* "Object" declarations for JPEG modules that may be supplied or called
+ * directly by the surrounding application.
+ * As with all objects in the JPEG library, these structs only define the
+ * publicly visible methods and state variables of a module.  Additional
+ * private fields may exist after the public ones.
+ */
+
+
+/* Error handler object */
+
+struct jpeg_error_mgr {
+  /* Error exit handler: does not return to caller */
+  JMETHOD(void, error_exit, (j_common_ptr cinfo));
+  /* Conditionally emit a trace or warning message */
+  JMETHOD(void, emit_message, (j_common_ptr cinfo, int msg_level));
+  /* Routine that actually outputs a trace or error message */
+  JMETHOD(void, output_message, (j_common_ptr cinfo));
+  /* Format a message string for the most recent JPEG error or message */
+  JMETHOD(void, format_message, (j_common_ptr cinfo, char * buffer));
+#define JMSG_LENGTH_MAX  200	/* recommended size of format_message buffer */
+  /* Reset error state variables at start of a new image */
+  JMETHOD(void, reset_error_mgr, (j_common_ptr cinfo));
+  
+  /* The message ID code and any parameters are saved here.
+   * A message can have one string parameter or up to 8 int parameters.
+   */
+  int msg_code;
+#define JMSG_STR_PARM_MAX  80
+  union {
+    int i[8];
+    char s[JMSG_STR_PARM_MAX];
+  } msg_parm;
+  
+  /* Standard state variables for error facility */
+  
+  int trace_level;		/* max msg_level that will be displayed */
+  
+  /* For recoverable corrupt-data errors, we emit a warning message,
+   * but keep going unless emit_message chooses to abort.  emit_message
+   * should count warnings in num_warnings.  The surrounding application
+   * can check for bad data by seeing if num_warnings is nonzero at the
+   * end of processing.
+   */
+  long num_warnings;		/* number of corrupt-data warnings */
+
+  /* These fields point to the table(s) of error message strings.
+   * An application can change the table pointer to switch to a different
+   * message list (typically, to change the language in which errors are
+   * reported).  Some applications may wish to add additional error codes
+   * that will be handled by the JPEG library error mechanism; the second
+   * table pointer is used for this purpose.
+   *
+   * First table includes all errors generated by JPEG library itself.
+   * Error code 0 is reserved for a "no such error string" message.
+   */
+  const char * const * jpeg_message_table; /* Library errors */
+  int last_jpeg_message;    /* Table contains strings 0..last_jpeg_message */
+  /* Second table can be added by application (see cjpeg/djpeg for example).
+   * It contains strings numbered first_addon_message..last_addon_message.
+   */
+  const char * const * addon_message_table; /* Non-library errors */
+  int first_addon_message;	/* code for first string in addon table */
+  int last_addon_message;	/* code for last string in addon table */
+};
+
+
+/* Progress monitor object */
+
+struct jpeg_progress_mgr {
+  JMETHOD(void, progress_monitor, (j_common_ptr cinfo));
+
+  long pass_counter;		/* work units completed in this pass */
+  long pass_limit;		/* total number of work units in this pass */
+  int completed_passes;		/* passes completed so far */
+  int total_passes;		/* total number of passes expected */
+};
+
+
+/* Data destination object for compression */
+
+struct jpeg_destination_mgr {
+  JOCTET * next_output_byte;	/* => next byte to write in buffer */
+  size_t free_in_buffer;	/* # of byte spaces remaining in buffer */
+
+  JMETHOD(void, init_destination, (j_compress_ptr cinfo));
+  JMETHOD(boolean, empty_output_buffer, (j_compress_ptr cinfo));
+  JMETHOD(void, term_destination, (j_compress_ptr cinfo));
+};
+
+
+/* Data source object for decompression */
+
+struct jpeg_source_mgr {
+  const JOCTET * next_input_byte; /* => next byte to read from buffer */
+  size_t bytes_in_buffer;	/* # of bytes remaining in buffer */
+
+  JMETHOD(void, init_source, (j_decompress_ptr cinfo));
+  JMETHOD(boolean, fill_input_buffer, (j_decompress_ptr cinfo));
+  JMETHOD(void, skip_input_data, (j_decompress_ptr cinfo, long num_bytes));
+  JMETHOD(boolean, resync_to_restart, (j_decompress_ptr cinfo, int desired));
+  JMETHOD(void, term_source, (j_decompress_ptr cinfo));
+};
+
+
+/* Memory manager object.
+ * Allocates "small" objects (a few K total), "large" objects (tens of K),
+ * and "really big" objects (virtual arrays with backing store if needed).
+ * The memory manager does not allow individual objects to be freed; rather,
+ * each created object is assigned to a pool, and whole pools can be freed
+ * at once.  This is faster and more convenient than remembering exactly what
+ * to free, especially where malloc()/free() are not too speedy.
+ * NB: alloc routines never return NULL.  They exit to error_exit if not
+ * successful.
+ */
+
+#define JPOOL_PERMANENT	0	/* lasts until master record is destroyed */
+#define JPOOL_IMAGE	1	/* lasts until done with image/datastream */
+#define JPOOL_NUMPOOLS	2
+
+typedef struct jvirt_sarray_control * jvirt_sarray_ptr;
+typedef struct jvirt_barray_control * jvirt_barray_ptr;
+
+
+struct jpeg_memory_mgr {
+  /* Method pointers */
+  JMETHOD(void *, alloc_small, (j_common_ptr cinfo, int pool_id,
+				size_t sizeofobject));
+  JMETHOD(void FAR *, alloc_large, (j_common_ptr cinfo, int pool_id,
+				     size_t sizeofobject));
+  JMETHOD(JSAMPARRAY, alloc_sarray, (j_common_ptr cinfo, int pool_id,
+				     JDIMENSION samplesperrow,
+				     JDIMENSION numrows));
+  JMETHOD(JBLOCKARRAY, alloc_barray, (j_common_ptr cinfo, int pool_id,
+				      JDIMENSION blocksperrow,
+				      JDIMENSION numrows));
+  JMETHOD(jvirt_sarray_ptr, request_virt_sarray, (j_common_ptr cinfo,
+						  int pool_id,
+						  boolean pre_zero,
+						  JDIMENSION samplesperrow,
+						  JDIMENSION numrows,
+						  JDIMENSION maxaccess));
+  JMETHOD(jvirt_barray_ptr, request_virt_barray, (j_common_ptr cinfo,
+						  int pool_id,
+						  boolean pre_zero,
+						  JDIMENSION blocksperrow,
+						  JDIMENSION numrows,
+						  JDIMENSION maxaccess));
+  JMETHOD(void, realize_virt_arrays, (j_common_ptr cinfo));
+  JMETHOD(JSAMPARRAY, access_virt_sarray, (j_common_ptr cinfo,
+					   jvirt_sarray_ptr ptr,
+					   JDIMENSION start_row,
+					   JDIMENSION num_rows,
+					   boolean writable));
+  JMETHOD(JBLOCKARRAY, access_virt_barray, (j_common_ptr cinfo,
+					    jvirt_barray_ptr ptr,
+					    JDIMENSION start_row,
+					    JDIMENSION num_rows,
+					    boolean writable));
+  JMETHOD(void, free_pool, (j_common_ptr cinfo, int pool_id));
+  JMETHOD(void, self_destruct, (j_common_ptr cinfo));
+
+  /* Limit on memory allocation for this JPEG object.  (Note that this is
+   * merely advisory, not a guaranteed maximum; it only affects the space
+   * used for virtual-array buffers.)  May be changed by outer application
+   * after creating the JPEG object.
+   */
+  long max_memory_to_use;
+
+  /* Maximum allocation request accepted by alloc_large. */
+  long max_alloc_chunk;
+};
+
+
+/* Routine signature for application-supplied marker processing methods.
+ * Need not pass marker code since it is stored in cinfo->unread_marker.
+ */
+typedef JMETHOD(boolean, jpeg_marker_parser_method, (j_decompress_ptr cinfo));
+
+
+/* Declarations for routines called by application.
+ * The JPP macro hides prototype parameters from compilers that can't cope.
+ * Note JPP requires double parentheses.
+ */
+
+#ifdef HAVE_PROTOTYPES
+#define JPP(arglist)	arglist
+#else
+#define JPP(arglist)	()
+#endif
+
+
+/* Short forms of external names for systems with brain-damaged linkers.
+ * We shorten external names to be unique in the first six letters, which
+ * is good enough for all known systems.
+ * (If your compiler itself needs names to be unique in less than 15 
+ * characters, you are out of luck.  Get a better compiler.)
+ */
+
+#ifdef NEED_SHORT_EXTERNAL_NAMES
+#define jpeg_std_error		jStdError
+#define jpeg_CreateCompress	jCreaCompress
+#define jpeg_CreateDecompress	jCreaDecompress
+#define jpeg_destroy_compress	jDestCompress
+#define jpeg_destroy_decompress	jDestDecompress
+#define jpeg_stdio_dest		jStdDest
+#define jpeg_stdio_src		jStdSrc
+#define jpeg_mem_dest		jMemDest
+#define jpeg_mem_src		jMemSrc
+#define jpeg_set_defaults	jSetDefaults
+#define jpeg_set_colorspace	jSetColorspace
+#define jpeg_default_colorspace	jDefColorspace
+#define jpeg_set_quality	jSetQuality
+#define jpeg_set_linear_quality	jSetLQuality
+#define jpeg_default_qtables	jDefQTables
+#define jpeg_add_quant_table	jAddQuantTable
+#define jpeg_quality_scaling	jQualityScaling
+#define jpeg_simple_progression	jSimProgress
+#define jpeg_suppress_tables	jSuppressTables
+#define jpeg_alloc_quant_table	jAlcQTable
+#define jpeg_alloc_huff_table	jAlcHTable
+#define jpeg_start_compress	jStrtCompress
+#define jpeg_write_scanlines	jWrtScanlines
+#define jpeg_finish_compress	jFinCompress
+#define jpeg_calc_jpeg_dimensions	jCjpegDimensions
+#define jpeg_write_raw_data	jWrtRawData
+#define jpeg_write_marker	jWrtMarker
+#define jpeg_write_m_header	jWrtMHeader
+#define jpeg_write_m_byte	jWrtMByte
+#define jpeg_write_tables	jWrtTables
+#define jpeg_read_header	jReadHeader
+#define jpeg_start_decompress	jStrtDecompress
+#define jpeg_read_scanlines	jReadScanlines
+#define jpeg_finish_decompress	jFinDecompress
+#define jpeg_read_raw_data	jReadRawData
+#define jpeg_has_multiple_scans	jHasMultScn
+#define jpeg_start_output	jStrtOutput
+#define jpeg_finish_output	jFinOutput
+#define jpeg_input_complete	jInComplete
+#define jpeg_new_colormap	jNewCMap
+#define jpeg_consume_input	jConsumeInput
+#define jpeg_core_output_dimensions	jCoreDimensions
+#define jpeg_calc_output_dimensions	jCalcDimensions
+#define jpeg_save_markers	jSaveMarkers
+#define jpeg_set_marker_processor	jSetMarker
+#define jpeg_read_coefficients	jReadCoefs
+#define jpeg_write_coefficients	jWrtCoefs
+#define jpeg_copy_critical_parameters	jCopyCrit
+#define jpeg_abort_compress	jAbrtCompress
+#define jpeg_abort_decompress	jAbrtDecompress
+#define jpeg_abort		jAbort
+#define jpeg_destroy		jDestroy
+#define jpeg_resync_to_restart	jResyncRestart
+#endif /* NEED_SHORT_EXTERNAL_NAMES */
+
+
+/* Default error-management setup */
+EXTERN(struct jpeg_error_mgr *) jpeg_std_error
+	JPP((struct jpeg_error_mgr * err));
+
+/* Initialization of JPEG compression objects.
+ * jpeg_create_compress() and jpeg_create_decompress() are the exported
+ * names that applications should call.  These expand to calls on
+ * jpeg_CreateCompress and jpeg_CreateDecompress with additional information
+ * passed for version mismatch checking.
+ * NB: you must set up the error-manager BEFORE calling jpeg_create_xxx.
+ */
+#define jpeg_create_compress(cinfo) \
+    jpeg_CreateCompress((cinfo), JPEG_LIB_VERSION, \
+			(size_t) sizeof(struct jpeg_compress_struct))
+#define jpeg_create_decompress(cinfo) \
+    jpeg_CreateDecompress((cinfo), JPEG_LIB_VERSION, \
+			  (size_t) sizeof(struct jpeg_decompress_struct))
+EXTERN(void) jpeg_CreateCompress JPP((j_compress_ptr cinfo,
+				      int version, size_t structsize));
+EXTERN(void) jpeg_CreateDecompress JPP((j_decompress_ptr cinfo,
+					int version, size_t structsize));
+/* Destruction of JPEG compression objects */
+EXTERN(void) jpeg_destroy_compress JPP((j_compress_ptr cinfo));
+EXTERN(void) jpeg_destroy_decompress JPP((j_decompress_ptr cinfo));
+
+/* Standard data source and destination managers: stdio streams. */
+/* Caller is responsible for opening the file before and closing after. */
+EXTERN(void) jpeg_stdio_dest JPP((j_compress_ptr cinfo, FILE * outfile));
+EXTERN(void) jpeg_stdio_src JPP((j_decompress_ptr cinfo, FILE * infile));
+
+/* Data source and destination managers: memory buffers. */
+EXTERN(void) jpeg_mem_dest JPP((j_compress_ptr cinfo,
+			       unsigned char ** outbuffer,
+			       unsigned long * outsize));
+EXTERN(void) jpeg_mem_src JPP((j_decompress_ptr cinfo,
+			      unsigned char * inbuffer,
+			      unsigned long insize));
+
+/* Default parameter setup for compression */
+EXTERN(void) jpeg_set_defaults JPP((j_compress_ptr cinfo));
+/* Compression parameter setup aids */
+EXTERN(void) jpeg_set_colorspace JPP((j_compress_ptr cinfo,
+				      J_COLOR_SPACE colorspace));
+EXTERN(void) jpeg_default_colorspace JPP((j_compress_ptr cinfo));
+EXTERN(void) jpeg_set_quality JPP((j_compress_ptr cinfo, int quality,
+				   boolean force_baseline));
+EXTERN(void) jpeg_set_linear_quality JPP((j_compress_ptr cinfo,
+					  int scale_factor,
+					  boolean force_baseline));
+EXTERN(void) jpeg_default_qtables JPP((j_compress_ptr cinfo,
+				       boolean force_baseline));
+EXTERN(void) jpeg_add_quant_table JPP((j_compress_ptr cinfo, int which_tbl,
+				       const unsigned int *basic_table,
+				       int scale_factor,
+				       boolean force_baseline));
+EXTERN(int) jpeg_quality_scaling JPP((int quality));
+EXTERN(void) jpeg_simple_progression JPP((j_compress_ptr cinfo));
+EXTERN(void) jpeg_suppress_tables JPP((j_compress_ptr cinfo,
+				       boolean suppress));
+EXTERN(JQUANT_TBL *) jpeg_alloc_quant_table JPP((j_common_ptr cinfo));
+EXTERN(JHUFF_TBL *) jpeg_alloc_huff_table JPP((j_common_ptr cinfo));
+
+/* Main entry points for compression */
+EXTERN(void) jpeg_start_compress JPP((j_compress_ptr cinfo,
+				      boolean write_all_tables));
+EXTERN(JDIMENSION) jpeg_write_scanlines JPP((j_compress_ptr cinfo,
+					     JSAMPARRAY scanlines,
+					     JDIMENSION num_lines));
+EXTERN(void) jpeg_finish_compress JPP((j_compress_ptr cinfo));
+
+/* Precalculate JPEG dimensions for current compression parameters. */
+EXTERN(void) jpeg_calc_jpeg_dimensions JPP((j_compress_ptr cinfo));
+
+/* Replaces jpeg_write_scanlines when writing raw downsampled data. */
+EXTERN(JDIMENSION) jpeg_write_raw_data JPP((j_compress_ptr cinfo,
+					    JSAMPIMAGE data,
+					    JDIMENSION num_lines));
+
+/* Write a special marker.  See libjpeg.txt concerning safe usage. */
+EXTERN(void) jpeg_write_marker
+	JPP((j_compress_ptr cinfo, int marker,
+	     const JOCTET * dataptr, unsigned int datalen));
+/* Same, but piecemeal. */
+EXTERN(void) jpeg_write_m_header
+	JPP((j_compress_ptr cinfo, int marker, unsigned int datalen));
+EXTERN(void) jpeg_write_m_byte
+	JPP((j_compress_ptr cinfo, int val));
+
+/* Alternate compression function: just write an abbreviated table file */
+EXTERN(void) jpeg_write_tables JPP((j_compress_ptr cinfo));
+
+/* Decompression startup: read start of JPEG datastream to see what's there */
+EXTERN(int) jpeg_read_header JPP((j_decompress_ptr cinfo,
+				  boolean require_image));
+/* Return value is one of: */
+#define JPEG_SUSPENDED		0 /* Suspended due to lack of input data */
+#define JPEG_HEADER_OK		1 /* Found valid image datastream */
+#define JPEG_HEADER_TABLES_ONLY	2 /* Found valid table-specs-only datastream */
+/* If you pass require_image = TRUE (normal case), you need not check for
+ * a TABLES_ONLY return code; an abbreviated file will cause an error exit.
+ * JPEG_SUSPENDED is only possible if you use a data source module that can
+ * give a suspension return (the stdio source module doesn't).
+ */
+
+/* Main entry points for decompression */
+EXTERN(boolean) jpeg_start_decompress JPP((j_decompress_ptr cinfo));
+EXTERN(JDIMENSION) jpeg_read_scanlines JPP((j_decompress_ptr cinfo,
+					    JSAMPARRAY scanlines,
+					    JDIMENSION max_lines));
+EXTERN(boolean) jpeg_finish_decompress JPP((j_decompress_ptr cinfo));
+
+/* Replaces jpeg_read_scanlines when reading raw downsampled data. */
+EXTERN(JDIMENSION) jpeg_read_raw_data JPP((j_decompress_ptr cinfo,
+					   JSAMPIMAGE data,
+					   JDIMENSION max_lines));
+
+/* Additional entry points for buffered-image mode. */
+EXTERN(boolean) jpeg_has_multiple_scans JPP((j_decompress_ptr cinfo));
+EXTERN(boolean) jpeg_start_output JPP((j_decompress_ptr cinfo,
+				       int scan_number));
+EXTERN(boolean) jpeg_finish_output JPP((j_decompress_ptr cinfo));
+EXTERN(boolean) jpeg_input_complete JPP((j_decompress_ptr cinfo));
+EXTERN(void) jpeg_new_colormap JPP((j_decompress_ptr cinfo));
+EXTERN(int) jpeg_consume_input JPP((j_decompress_ptr cinfo));
+/* Return value is one of: */
+/* #define JPEG_SUSPENDED	0    Suspended due to lack of input data */
+#define JPEG_REACHED_SOS	1 /* Reached start of new scan */
+#define JPEG_REACHED_EOI	2 /* Reached end of image */
+#define JPEG_ROW_COMPLETED	3 /* Completed one iMCU row */
+#define JPEG_SCAN_COMPLETED	4 /* Completed last iMCU row of a scan */
+
+/* Precalculate output dimensions for current decompression parameters. */
+EXTERN(void) jpeg_core_output_dimensions JPP((j_decompress_ptr cinfo));
+EXTERN(void) jpeg_calc_output_dimensions JPP((j_decompress_ptr cinfo));
+
+/* Control saving of COM and APPn markers into marker_list. */
+EXTERN(void) jpeg_save_markers
+	JPP((j_decompress_ptr cinfo, int marker_code,
+	     unsigned int length_limit));
+
+/* Install a special processing method for COM or APPn markers. */
+EXTERN(void) jpeg_set_marker_processor
+	JPP((j_decompress_ptr cinfo, int marker_code,
+	     jpeg_marker_parser_method routine));
+
+/* Read or write raw DCT coefficients --- useful for lossless transcoding. */
+EXTERN(jvirt_barray_ptr *) jpeg_read_coefficients JPP((j_decompress_ptr cinfo));
+EXTERN(void) jpeg_write_coefficients JPP((j_compress_ptr cinfo,
+					  jvirt_barray_ptr * coef_arrays));
+EXTERN(void) jpeg_copy_critical_parameters JPP((j_decompress_ptr srcinfo,
+						j_compress_ptr dstinfo));
+
+/* If you choose to abort compression or decompression before completing
+ * jpeg_finish_(de)compress, then you need to clean up to release memory,
+ * temporary files, etc.  You can just call jpeg_destroy_(de)compress
+ * if you're done with the JPEG object, but if you want to clean it up and
+ * reuse it, call this:
+ */
+EXTERN(void) jpeg_abort_compress JPP((j_compress_ptr cinfo));
+EXTERN(void) jpeg_abort_decompress JPP((j_decompress_ptr cinfo));
+
+/* Generic versions of jpeg_abort and jpeg_destroy that work on either
+ * flavor of JPEG object.  These may be more convenient in some places.
+ */
+EXTERN(void) jpeg_abort JPP((j_common_ptr cinfo));
+EXTERN(void) jpeg_destroy JPP((j_common_ptr cinfo));
+
+/* Default restart-marker-resync procedure for use by data source modules */
+EXTERN(boolean) jpeg_resync_to_restart JPP((j_decompress_ptr cinfo,
+					    int desired));
+
+
+/* These marker codes are exported since applications and data source modules
+ * are likely to want to use them.
+ */
+
+#define JPEG_RST0	0xD0	/* RST0 marker code */
+#define JPEG_EOI	0xD9	/* EOI marker code */
+#define JPEG_APP0	0xE0	/* APP0 marker code */
+#define JPEG_COM	0xFE	/* COM marker code */
+
+
+/* If we have a brain-damaged compiler that emits warnings (or worse, errors)
+ * for structure definitions that are never filled in, keep it quiet by
+ * supplying dummy definitions for the various substructures.
+ */
+
+#ifdef INCOMPLETE_TYPES_BROKEN
+#ifndef JPEG_INTERNALS		/* will be defined in jpegint.h */
+struct jvirt_sarray_control { long dummy; };
+struct jvirt_barray_control { long dummy; };
+struct jpeg_comp_master { long dummy; };
+struct jpeg_c_main_controller { long dummy; };
+struct jpeg_c_prep_controller { long dummy; };
+struct jpeg_c_coef_controller { long dummy; };
+struct jpeg_marker_writer { long dummy; };
+struct jpeg_color_converter { long dummy; };
+struct jpeg_downsampler { long dummy; };
+struct jpeg_forward_dct { long dummy; };
+struct jpeg_entropy_encoder { long dummy; };
+struct jpeg_decomp_master { long dummy; };
+struct jpeg_d_main_controller { long dummy; };
+struct jpeg_d_coef_controller { long dummy; };
+struct jpeg_d_post_controller { long dummy; };
+struct jpeg_input_controller { long dummy; };
+struct jpeg_marker_reader { long dummy; };
+struct jpeg_entropy_decoder { long dummy; };
+struct jpeg_inverse_dct { long dummy; };
+struct jpeg_upsampler { long dummy; };
+struct jpeg_color_deconverter { long dummy; };
+struct jpeg_color_quantizer { long dummy; };
+#endif /* JPEG_INTERNALS */
+#endif /* INCOMPLETE_TYPES_BROKEN */
+
+
+/*
+ * The JPEG library modules define JPEG_INTERNALS before including this file.
+ * The internal structure declarations are read only when that is true.
+ * Applications using the library should not include jpegint.h, but may wish
+ * to include jerror.h.
+ */
+
+#ifdef JPEG_INTERNALS
+#include "jpegint.h"		/* fetch private declarations */
+#include "jerror.h"		/* fetch error codes too */
+#endif
+
+#ifdef __cplusplus
+#ifndef DONT_USE_EXTERN_C
+}
+#endif
+#endif
+
+#endif /* JPEGLIB_H */
diff --git a/lib/a2jpeg/jpegtools.c b/lib/a2jpeg/jpegtools.c
new file mode 100644
index 0000000..91854d8
--- /dev/null
+++ b/lib/a2jpeg/jpegtools.c
@@ -0,0 +1,621 @@
+/*
+ * jpegtran.c
+ *
+ * Copyright (C) 1995-1997, Thomas G. Lane.
+ * This file is part of the Independent JPEG Group's software.
+ * For conditions of distribution and use, see the accompanying README file.
+ * 
+ * plenty of changes by Gerd Hoffmann <kraxel@bytesex.org>, with focus on
+ * digital image processing and sane exif handling:
+ *
+ *   - does transformations only (flip/rotate/transpose/transverse).
+ *   - also transforms the exif thumbnail if present.
+ *   - can automatically figure transformation from the
+ *     exif orientation tag.
+ *   - updates the exif orientation tag.
+ *   - updates the exif pixel dimension tags.
+ *
+ * This file contains a command-line user interface for JPEG transcoding.
+ * It is very similar to cjpeg.c, but provides lossless transcoding between
+ * different JPEG file formats.  It also provides some lossless and sort-of-
+ * lossless transformations of JPEG data.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stddef.h>
+#include <unistd.h>
+#include <errno.h>
+#include <string.h>
+#include <utime.h>
+#include <setjmp.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+
+#include <jpeglib.h>
+//#include "a2jpeg/transupp.h"		/* Support routines for jpegtran */
+#include "jpegtools.h"
+
+#include "misc.h"
+
+#include <libexif/exif-data.h>
+#include <libexif/exif-utils.h>
+#include <libexif/exif-ifd.h>
+#include <libexif/exif-tag.h>
+
+static int do_transform(struct jpeg_decompress_struct *src,
+			struct jpeg_compress_struct   *dst,
+			JXFORM_CODE transform,
+			unsigned char *comment,
+			char *thumbnail, int tsize,
+			unsigned int flags);
+
+static JXFORM_CODE transmagic[] = {
+    [ 1 ] = JXFORM_NONE,
+    [ 2 ] = JXFORM_FLIP_H,
+    [ 3 ] = JXFORM_ROT_180,
+    [ 4 ] = JXFORM_FLIP_V,
+    [ 5 ] = JXFORM_TRANSPOSE,
+    [ 6 ] = JXFORM_ROT_90,
+    [ 7 ] = JXFORM_TRANSVERSE,
+    [ 8 ] = JXFORM_ROT_270,
+};
+
+#if 0
+static char *transname[] = {
+    [ JXFORM_NONE ]       = "none",
+    [ JXFORM_FLIP_H ]     = "flip h",
+    [ JXFORM_FLIP_V ]     = "flip v",
+    [ JXFORM_TRANSPOSE ]  = "transpose",
+    [ JXFORM_TRANSVERSE ] = "transverse",
+    [ JXFORM_ROT_90 ]     = "rot 90",
+    [ JXFORM_ROT_180 ]    = "rot 190",
+    [ JXFORM_ROT_270 ]    = "rot 270",
+};
+#endif
+
+/* ---------------------------------------------------------------------- */
+
+/* libjpeg error handler -- exit via longjump */
+struct longjmp_error_mgr {
+    struct jpeg_error_mgr jpeg;
+    jmp_buf setjmp_buffer;
+};
+
+static void longjmp_error_exit(j_common_ptr cinfo)
+{
+    struct longjmp_error_mgr *h = (struct longjmp_error_mgr*)cinfo->err;
+    (*cinfo->err->output_message)(cinfo);
+    longjmp(h->setjmp_buffer, 1);
+}
+
+/* ---------------------------------------------------------------------- */
+
+static long get_int(ExifData *ed, ExifEntry *ee)
+{
+    ExifByteOrder o = exif_data_get_byte_order(ed);
+    long value;
+    
+    switch (ee->format) {
+    case EXIF_FORMAT_SHORT:
+	value = exif_get_short (ee->data, o);
+	break;
+    case EXIF_FORMAT_LONG:
+	value = exif_get_long (ee->data, o);
+	break;
+    case EXIF_FORMAT_SLONG:
+	value = exif_get_slong (ee->data, o);
+	break;
+    default:
+	fprintf(stderr,"get_int oops\n");
+	exit(1);
+    }
+    return value;
+}
+
+static void set_int(ExifData *ed, ExifEntry *ee, long value)
+{
+    ExifByteOrder o = exif_data_get_byte_order(ed);
+
+    switch (ee->format) {
+    case EXIF_FORMAT_SHORT:
+	exif_set_short (ee->data, o, value);
+	break;
+    case EXIF_FORMAT_LONG:
+	exif_set_long (ee->data, o, value);
+	break;
+    case EXIF_FORMAT_SLONG:
+	exif_set_slong (ee->data, o, value);
+	break;
+    default:
+	fprintf(stderr,"set_int oops\n");
+	exit(1);
+    }
+}
+
+static void update_orientation(ExifData *ed, int ifd, int orientation)
+{
+    ExifEntry *ee;
+
+    ee = exif_content_get_entry(ed->ifd[ifd], 0x0112);
+    if (NULL == ee)
+	return;
+    set_int(ed,ee,orientation);
+}
+
+static void update_dimension(ExifData *ed, JXFORM_CODE transform,
+			     int src_x, int src_y)
+{
+    static struct {
+	int idf;
+	int tag;
+	int x;
+    } fields[] = {
+	{
+	    .idf = EXIF_IFD_EXIF,
+	    .tag = EXIF_TAG_PIXEL_X_DIMENSION,
+	    .x   = 1,
+	},{
+	    .idf = EXIF_IFD_EXIF,
+	    .tag = EXIF_TAG_PIXEL_Y_DIMENSION,
+	    .x   = 0,
+	},{
+	    .idf = EXIF_IFD_INTEROPERABILITY,
+	    .tag = EXIF_TAG_RELATED_IMAGE_WIDTH,
+	    .x   = 1,
+	},{
+	    .idf = EXIF_IFD_INTEROPERABILITY,
+	    .tag = EXIF_TAG_RELATED_IMAGE_LENGTH,
+	    .x   = 0,
+	}
+    };
+    ExifEntry *ee;
+    int i;
+
+    for (i = 0; i < sizeof(fields)/sizeof(fields[0]); i++) {
+	ee = exif_content_get_entry(ed->ifd[fields[i].idf], fields[i].tag);
+	if (!ee)
+	    continue;
+	switch (transform) {
+	case JXFORM_ROT_90:
+	case JXFORM_ROT_270:
+	case JXFORM_TRANSPOSE:
+	case JXFORM_TRANSVERSE:
+	    /* x/y reversed */
+	    set_int(ed, ee, fields[i].x ? src_y : src_x);
+	    break;
+	default:
+	    /* normal */
+	    set_int(ed, ee, fields[i].x ? src_x : src_y);
+	    break;
+	}
+    }
+}
+
+int get_orientation(ExifData *ed)
+{
+    ExifEntry *ee;
+
+    ee = exif_content_get_entry(ed->ifd[EXIF_IFD_0], 0x0112);
+    if (NULL == ee)
+	return 1; /* top - left */
+    return get_int(ed,ee);
+}
+
+/* ---------------------------------------------------------------------- */
+
+struct th {
+    struct jpeg_decompress_struct src;
+    struct jpeg_compress_struct   dst;
+    struct jpeg_error_mgr jsrcerr, jdsterr;
+    unsigned char *in;
+    unsigned char *out;
+    int isize, osize;
+};
+
+static void thumbnail_src_init(struct jpeg_decompress_struct *cinfo)
+{
+    struct th *h  = container_of(cinfo, struct th, src);
+    cinfo->src->next_input_byte = h->in;
+    cinfo->src->bytes_in_buffer = h->isize;
+}
+
+static int thumbnail_src_fill(struct jpeg_decompress_struct *cinfo)
+{
+    fprintf(stderr,"jpeg: panic: no more thumbnail input data\n");
+    exit(1);
+}
+
+static void thumbnail_src_skip(struct jpeg_decompress_struct *cinfo,
+			       long num_bytes)
+{
+    cinfo->src->next_input_byte += num_bytes;
+}
+
+static void thumbnail_src_term(struct jpeg_decompress_struct *cinfo)
+{
+    /* nothing */
+}
+
+static void thumbnail_dest_init(struct jpeg_compress_struct *cinfo)
+{
+    struct th *h  = container_of(cinfo, struct th, dst);
+    h->osize = h->isize * 2;
+    h->out   = malloc(h->osize);
+    cinfo->dest->next_output_byte = h->out;
+    cinfo->dest->free_in_buffer   = h->osize;
+}
+
+static boolean thumbnail_dest_flush(struct jpeg_compress_struct *cinfo)
+{
+    fprintf(stderr,"jpeg: panic: output buffer full\n");
+    exit(1);
+}
+
+static void thumbnail_dest_term(struct jpeg_compress_struct *cinfo)
+{
+    struct th *h  = container_of(cinfo, struct th, dst);
+    h->osize -= cinfo->dest->free_in_buffer;
+}
+
+static struct jpeg_source_mgr thumbnail_src = {
+    .init_source         = thumbnail_src_init,
+    .fill_input_buffer   = thumbnail_src_fill,
+    .skip_input_data     = thumbnail_src_skip,
+    .resync_to_restart   = jpeg_resync_to_restart,
+    .term_source         = thumbnail_src_term,
+};
+
+static struct jpeg_destination_mgr thumbnail_dst = {
+    .init_destination    = thumbnail_dest_init,
+    .empty_output_buffer = thumbnail_dest_flush,
+    .term_destination    = thumbnail_dest_term,
+};
+
+static void do_thumbnail(ExifData *ed, JXFORM_CODE transform)
+{
+    struct th th;
+
+    if (JXFORM_NONE == transform)
+	return;
+    
+    memset(&th,0,sizeof(th));
+    th.in    = ed->data;
+    th.isize = ed->size;
+    
+    /* setup src */
+    th.src.err = jpeg_std_error(&th.jsrcerr);
+    jpeg_create_decompress(&th.src);
+    th.src.src = &thumbnail_src;
+    
+    /* setup dst */
+    th.dst.err = jpeg_std_error(&th.jdsterr);
+    jpeg_create_compress(&th.dst);
+    th.dst.dest = &thumbnail_dst;
+
+    /* transform image */
+    do_transform(&th.src,&th.dst,transform,NULL,NULL,0,JFLAG_TRANSFORM_IMAGE);
+
+    /* cleanup */
+    jpeg_destroy_decompress(&th.src);
+    jpeg_destroy_compress(&th.dst);
+
+    /* replace thumbnail */
+    free(ed->data);
+    ed->data = th.out;
+    ed->size = th.osize;
+}
+
+static void do_exif(struct jpeg_decompress_struct *src,
+		    JXFORM_CODE *transform,
+		    char *thumbnail, int tsize,
+		    unsigned int flags)
+{
+    jpeg_saved_marker_ptr mark;
+    ExifData *ed = NULL;
+    unsigned char *data;
+    unsigned int  size;
+    
+    for (mark = src->marker_list; NULL != mark; mark = mark->next) {
+	if (mark->marker != JPEG_APP0 +1)
+	    continue;
+	ed = exif_data_new_from_data(mark->data,mark->data_length);
+	break;
+    }
+    if (flags & JFLAG_UPDATE_THUMBNAIL) {
+	if (NULL == ed)
+	    ed = exif_data_new();
+	if (NULL == mark) {
+	    mark = src->mem->alloc_large((j_common_ptr)src,JPOOL_IMAGE,sizeof(*mark));
+	    memset(mark,0,sizeof(*mark));
+	    mark->marker = JPEG_APP0 +1;
+	    mark->next = src->marker_list;
+	    src->marker_list = mark;
+	}
+	if (ed->data)
+	    free(ed->data);
+	ed->data = thumbnail;
+	ed->size = tsize;
+    }
+    if (NULL == ed)
+	return;
+
+    if (-1 == *transform) {
+	/* automagic image transformation */
+	int orientation = get_orientation(ed);
+	*transform = JXFORM_NONE;
+	if (orientation >= 1 && orientation <= 8)
+	    *transform = transmagic[orientation];
+#if 0
+	if (debug)
+	    fprintf(stderr,"autotrans: %s\n",transname[*transform]);
+#endif
+    }
+
+    /* update exif data */
+    if (flags & JFLAG_UPDATE_ORIENTATION) {
+	update_orientation(ed,EXIF_IFD_0,1);
+	update_orientation(ed,EXIF_IFD_1,1);
+    }
+    if (ed->data && ed->data[0] == 0xff && ed->data[1] == 0xd8 &&
+	(flags & JFLAG_TRANSFORM_THUMBNAIL))
+	do_thumbnail(ed,*transform);
+    update_dimension(ed, (flags & JFLAG_TRANSFORM_IMAGE) ? *transform : JXFORM_NONE,
+		     src->image_width, src->image_height);
+
+    /* build new exif data block */
+    exif_data_save_data(ed,&data,&size);
+    exif_data_unref(ed);
+
+    /* update jpeg APP1 (EXIF) marker */
+    mark->data = src->mem->alloc_large((j_common_ptr)src,JPOOL_IMAGE,size);
+    mark->original_length = size;
+    mark->data_length = size;
+    memcpy(mark->data,data,size);
+    free(data);
+}
+
+/* ---------------------------------------------------------------------- */
+
+static void do_comment(struct jpeg_decompress_struct *src,
+		       unsigned char *comment)
+{
+    jpeg_saved_marker_ptr mark;
+    int size;
+
+    /* find or create comment marker */
+    for (mark = src->marker_list;; mark = mark->next) {
+	if (mark->marker == JPEG_COM)
+	    break;
+	if (NULL == mark->next) {
+	    mark->next = src->mem->alloc_large((j_common_ptr)src,JPOOL_IMAGE,
+					       sizeof(*mark));
+	    mark = mark->next;
+	    memset(mark,0,sizeof(*mark));
+	    mark->marker = JPEG_COM;
+	    break;
+	}
+    }
+
+    /* update comment marker */
+    size = strlen(comment) +1;
+    mark->data = src->mem->alloc_large((j_common_ptr)src,JPOOL_IMAGE,size);
+    mark->original_length = size;
+    mark->data_length = size;
+    memcpy(mark->data,comment,size);
+}
+
+static int do_transform(struct jpeg_decompress_struct *src,
+			struct jpeg_compress_struct *dst,
+			JXFORM_CODE transform,
+			unsigned char *comment,
+			char *thumbnail, int tsize,
+			unsigned int flags)
+{
+    jvirt_barray_ptr * src_coef_arrays;
+    jvirt_barray_ptr * dst_coef_arrays;
+    jpeg_transform_info transformoption;
+
+    jcopy_markers_setup(src, JCOPYOPT_ALL);
+    if (JPEG_HEADER_OK != jpeg_read_header(src, TRUE))
+	return -1;
+
+    do_exif(src,&transform,thumbnail,tsize,flags);
+    if (-1 == transform)
+	transform = JXFORM_NONE;
+    if (!(flags & JFLAG_TRANSFORM_IMAGE))
+	transform = JXFORM_NONE;
+    if ((flags & JFLAG_UPDATE_COMMENT) && NULL != comment)
+	do_comment(src,comment);
+
+    memset(&transformoption,0,sizeof(transformoption));
+    transformoption.transform = transform;
+    transformoption.trim      = FALSE;
+    transformoption.force_grayscale = FALSE;
+
+    /* Any space needed by a transform option must be requested before
+     * jpeg_read_coefficients so that memory allocation will be done right.
+     */
+    jtransform_request_workspace(src, &transformoption);
+    src_coef_arrays = jpeg_read_coefficients(src);
+    jpeg_copy_critical_parameters(src, dst);
+    dst_coef_arrays = jtransform_adjust_parameters
+	(src, dst, src_coef_arrays, &transformoption);
+    
+    /* Start compressor (note no image data is actually written here) */
+    jpeg_write_coefficients(dst, dst_coef_arrays);
+    
+    /* Copy to the output file any extra markers that we want to preserve */
+    jcopy_markers_execute(src, dst, JCOPYOPT_ALL);
+    
+    /* Execute image transformation, if any */
+    jtransform_execute_transformation(src, dst,
+				      src_coef_arrays,
+				      &transformoption);
+    
+    /* Finish compression and release memory */
+    jpeg_finish_compress(dst);
+    jpeg_finish_decompress(src);
+
+    return 0;
+}
+
+/* ---------------------------------------------------------------------- */
+
+int jpeg_transform_fp(FILE *in, FILE *out,
+		      JXFORM_CODE transform,
+		      unsigned char *comment,
+		      char *thumbnail, int tsize,
+		      unsigned int flags)
+{
+    struct jpeg_decompress_struct src;
+    struct jpeg_compress_struct   dst;
+    struct jpeg_error_mgr jdsterr;
+    struct longjmp_error_mgr jsrcerr;
+    
+    /* setup src */
+    src.err = jpeg_std_error(&jsrcerr.jpeg);
+    jsrcerr.jpeg.error_exit = longjmp_error_exit;
+    if (setjmp(jsrcerr.setjmp_buffer))
+	/* something went wrong within the jpeg library ... */
+	goto oops;
+    jpeg_create_decompress(&src);
+    jpeg_stdio_src(&src, in);
+    
+    /* setup dst */
+    dst.err = jpeg_std_error(&jdsterr);
+    jpeg_create_compress(&dst);
+    jpeg_stdio_dest(&dst, out);
+
+    /* transform image */
+    do_transform(&src,&dst,transform,comment,thumbnail,tsize,flags);
+
+    /* cleanup */
+    jpeg_destroy_decompress(&src);
+    jpeg_destroy_compress(&dst);
+    return 0;
+
+ oops:
+    jpeg_destroy_decompress(&src);
+    jpeg_destroy_compress(&dst);
+    return -1;
+}
+
+int jpeg_transform_files(char *infile, char *outfile,
+			 JXFORM_CODE transform,
+			 unsigned char *comment,
+			 char *thumbnail, int tsize,
+			 unsigned int flags)
+{
+    int rc;
+    FILE *in;
+    FILE *out;
+    
+    /* open infile */
+    in = fopen(infile,"r");
+    if (NULL == in) {
+	fprintf(stderr,"open %s: %s\n",infile,strerror(errno));
+	return -1;
+    }
+    
+    /* open outfile */
+    out = fopen(outfile,"w");
+    if (NULL == out) {
+	fprintf(stderr,"open %s: %s\n",outfile,strerror(errno));
+	fclose(in);
+	return -1;
+    }
+
+    /* go! */
+    rc = jpeg_transform_fp(in,out,transform,comment,thumbnail,tsize,flags);
+    fclose(in);
+    fclose(out);
+
+    return rc;
+}
+
+int jpeg_transform_inplace(char *file,
+			   JXFORM_CODE transform,
+			   unsigned char *comment,
+			   char *thumbnail, int tsize,
+			   unsigned int flags)
+{
+    char *tmpfile;
+    char *bakfile;
+    struct stat st;
+    int fd;
+    FILE *in  = NULL;
+    FILE *out = NULL;
+
+    /* are we allowed to write to the file? */
+    if (0 != access(file,W_OK)) {
+	fprintf(stderr,"access %s: %s\n",file,strerror(errno));
+	return -1;
+    }
+
+    /* open infile */
+    in = fopen(file,"r");
+    if (NULL == in) {
+	fprintf(stderr,"open %s: %s\n",file,strerror(errno));
+	return -1;
+    }
+    
+    /* open tmpfile */
+    tmpfile = malloc(strlen(file)+10);
+    sprintf(tmpfile,"%s.XXXXXX",file);
+    fd = mkstemp(tmpfile);
+    if (-1 == fd) {
+	fprintf(stderr,"mkstemp(%s): %s\n",tmpfile,strerror(errno));
+	goto oops;
+    }
+    out = fdopen(fd,"w");
+
+    /* copy owner and permissions */
+    if (-1 == fstat(fileno(in),&st)) {
+	fprintf(stderr,"fstat(%s): %s\n",file,strerror(errno));
+	goto oops;
+    }
+    if (-1 == fchown(fileno(out),st.st_uid,st.st_gid)) {
+	fprintf(stderr,"fchown(%s): %s\n",tmpfile,strerror(errno));
+	goto oops;
+    }
+    if (-1 == fchmod(fileno(out),st.st_mode)) {
+	fprintf(stderr,"fchmod(%s): %s\n",tmpfile,strerror(errno));
+	goto oops;
+    }
+
+    /* transform */
+    if (0 != jpeg_transform_fp(in,out,transform,comment,thumbnail,tsize,flags))
+	goto oops;
+
+    /* worked ok -- commit */
+    fclose(in);
+    fclose(out);
+    if (flags & JFLAG_FILE_BACKUP) {
+	bakfile = malloc(strlen(file)+2);
+	sprintf(bakfile,"%s~",file);
+	rename(file,bakfile);
+	free(bakfile);
+    }
+    rename(tmpfile,file);
+    if (flags & JFLAG_FILE_KEEP_TIME) {
+	struct utimbuf u;
+	u.actime = st.st_atime;
+	u.modtime = st.st_mtime;
+	utime(file,&u);
+    }
+        
+    /* cleanup & return */
+    free(tmpfile);
+    return 0;
+
+ oops:
+    /* something went wrong -- rollback */
+    if (in)
+	fclose(in);
+    if (out) {
+	fclose(out);
+	unlink(tmpfile);
+    }
+    return -1;
+}
diff --git a/lib/a2jpeg/jpegtools.h b/lib/a2jpeg/jpegtools.h
new file mode 100644
index 0000000..875b66b
--- /dev/null
+++ b/lib/a2jpeg/jpegtools.h
@@ -0,0 +1,33 @@
+
+/* various flags */
+#define JFLAG_TRANSFORM_IMAGE      0x0001
+#define JFLAG_TRANSFORM_THUMBNAIL  0x0002
+
+#define JFLAG_UPDATE_COMMENT       0x0010
+#define JFLAG_UPDATE_ORIENTATION   0x0020
+#define JFLAG_UPDATE_THUMBNAIL     0x0040
+
+#define JFLAG_FILE_BACKUP          0x0100
+#define JFLAG_FILE_KEEP_TIME       0x0200
+
+#include "transupp.h"
+#include "exif-data.h"
+
+/* functions */
+int jpeg_transform_fp(FILE *in, FILE *out,
+		      JXFORM_CODE transform,
+		      unsigned char *comment,
+		      char *thumbnail, int tsize,
+		      unsigned int flags);
+int jpeg_transform_files(char *infile, char *outfile,
+			 JXFORM_CODE transform,
+			 unsigned char *comment,
+			 char *thumbnail, int tsize,
+			 unsigned int flags);
+int jpeg_transform_inplace(char *file,
+			   JXFORM_CODE transform,
+			   unsigned char *comment,
+			   char *thumbnail, int tsize,
+			   unsigned int flags);
+
+int get_orientation(ExifData *ed);
diff --git a/lib/a2jpeg/list.h b/lib/a2jpeg/list.h
new file mode 100644
index 0000000..614d34b
--- /dev/null
+++ b/lib/a2jpeg/list.h
@@ -0,0 +1,168 @@
+#ifndef _LIST_H_
+#define _LIST_H_
+/*
+ * Simple doubly linked list implementation.
+ *	-- shameless stolen from the linux kernel sources
+ *
+ * Some of the internal functions ("__xxx") are useful when
+ * manipulating whole lists rather than single entries, as
+ * sometimes we already know the next/prev entries and we can
+ * generate better code by using them directly rather than
+ * using the generic single-entry routines.
+ */
+
+struct list_head {
+	struct list_head *next, *prev;
+};
+
+#define LIST_HEAD_INIT(name) { &(name), &(name) }
+
+#define LIST_HEAD(name) \
+	struct list_head name = LIST_HEAD_INIT(name)
+
+#define INIT_LIST_HEAD(ptr) do { \
+	(ptr)->next = (ptr); (ptr)->prev = (ptr); \
+} while (0)
+
+/*
+ * Insert a new entry between two known consecutive entries. 
+ *
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ */
+static __inline__ void __list_add(struct list_head * new,
+	struct list_head * prev,
+	struct list_head * next)
+{
+	next->prev = new;
+	new->next = next;
+	new->prev = prev;
+	prev->next = new;
+}
+
+/**
+ * list_add - add a new entry
+ * @new: new entry to be added
+ * @head: list head to add it after
+ *
+ * Insert a new entry after the specified head.
+ * This is good for implementing stacks.
+ */
+static __inline__ void list_add(struct list_head *new, struct list_head *head)
+{
+	__list_add(new, head, head->next);
+}
+
+/**
+ * list_add_tail - add a new entry
+ * @new: new entry to be added
+ * @head: list head to add it before
+ *
+ * Insert a new entry before the specified head.
+ * This is useful for implementing queues.
+ */
+static __inline__ void list_add_tail(struct list_head *new, struct list_head *head)
+{
+	__list_add(new, head->prev, head);
+}
+
+/*
+ * Delete a list entry by making the prev/next entries
+ * point to each other.
+ *
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ */
+static __inline__ void __list_del(struct list_head * prev,
+				  struct list_head * next)
+{
+	next->prev = prev;
+	prev->next = next;
+}
+
+/**
+ * list_del - deletes entry from list.
+ * @entry: the element to delete from the list.
+ * Note: list_empty on entry does not return true after this, the entry is in an undefined state.
+ */
+static __inline__ void list_del(struct list_head *entry)
+{
+	__list_del(entry->prev, entry->next);
+}
+
+/**
+ * list_del_init - deletes entry from list and reinitialize it.
+ * @entry: the element to delete from the list.
+ */
+static __inline__ void list_del_init(struct list_head *entry)
+{
+	__list_del(entry->prev, entry->next);
+	INIT_LIST_HEAD(entry); 
+}
+
+/**
+ * list_empty - tests whether a list is empty
+ * @head: the list to test.
+ */
+static __inline__ int list_empty(struct list_head *head)
+{
+	return head->next == head;
+}
+
+/**
+ * list_splice - join two lists
+ * @list: the new list to add.
+ * @head: the place to add it in the first list.
+ */
+static __inline__ void list_splice(struct list_head *list, struct list_head *head)
+{
+	struct list_head *first = list->next;
+
+	if (first != list) {
+		struct list_head *last = list->prev;
+		struct list_head *at = head->next;
+
+		first->prev = head;
+		head->next = first;
+
+		last->next = at;
+		at->prev = last;
+	}
+}
+
+/**
+ * list_entry - get the struct for this entry
+ * @ptr:	the &struct list_head pointer.
+ * @type:	the type of the struct this is embedded in.
+ * @member:	the name of the list_struct within the struct.
+ */
+#define list_entry(ptr, type, member) \
+	((type *)((char *)(ptr)-(unsigned long)(&((type *)0)->member)))
+
+/**
+ * list_for_each	-	iterate over a list
+ * @pos:	the &struct list_head to use as a loop counter.
+ * @head:	the head for your list.
+ */
+#define list_for_each(pos, head) \
+	for (pos = (head)->next; pos != (head); pos = pos->next)
+        	
+/**
+ * list_for_each_safe	-	iterate over a list safe against removal of list entry
+ * @pos:	the &struct list_head to use as a loop counter.
+ * @n:		another &struct list_head to use as temporary storage
+ * @head:	the head for your list.
+ */
+#define list_for_each_safe(pos, n, head) \
+	for (pos = (head)->next, n = pos->next; pos != (head); \
+		pos = n, n = pos->next)
+
+/**
+ * list_for_each_prev	-	iterate over a list in reverse order
+ * @pos:	the &struct list_head to use as a loop counter.
+ * @head:	the head for your list.
+ */
+#define list_for_each_prev(pos, head) \
+	for (pos = (head)->prev; pos != (head); pos = pos->prev)
+
+#endif /* _LIST_H_ */
diff --git a/lib/a2jpeg/misc.h b/lib/a2jpeg/misc.h
new file mode 100644
index 0000000..92a66bc
--- /dev/null
+++ b/lib/a2jpeg/misc.h
@@ -0,0 +1,9 @@
+/*
+ * misc useful #defines ...
+ */
+
+#define container_of(ptr, type, member) ({			\
+        const typeof( ((type *)0)->member ) *__mptr = (ptr);	\
+        (type *)( (char *)__mptr - offsetof(type,member) );})
+
+#define array_size(x) (sizeof(x)/sizeof(x[0]))
diff --git a/lib/a2jpeg/op.c b/lib/a2jpeg/op.c
new file mode 100644
index 0000000..b4e95fe
--- /dev/null
+++ b/lib/a2jpeg/op.c
@@ -0,0 +1,289 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "readers.h"
+#include "op.h"
+#include "filter.h"
+
+/* ----------------------------------------------------------------------- */
+/* functions                                                               */
+
+static char op_none_data;
+
+static void
+op_flip_vert(struct ida_image *src, struct ida_rect *rect,
+	     unsigned char *dst, int line, void *data)
+{
+    char *scanline;
+
+    scanline = src->data + (src->i.height - line - 1) * src->i.width * 3;
+    memcpy(dst,scanline,src->i.width*3);
+}
+
+static void
+op_flip_horz(struct ida_image *src, struct ida_rect *rect,
+	     unsigned char *dst, int line, void *data)
+{
+    char *scanline;
+    unsigned int i;
+
+    scanline = src->data + (line+1) * src->i.width * 3;
+    for (i = 0; i < src->i.width; i++) {
+	scanline -= 3;
+	dst[0] = scanline[0];
+	dst[1] = scanline[1];
+	dst[2] = scanline[2];
+	dst += 3;
+    }
+}
+
+static void*
+op_rotate_init(struct ida_image *src, struct ida_rect *rect,
+	       struct ida_image_info *i, void *parm)
+{
+    *i = src->i;
+    i->height = src->i.width;
+    i->width  = src->i.height;
+    i->dpi    = src->i.dpi;
+    return &op_none_data;
+}
+
+static void
+op_rotate_cw(struct ida_image *src, struct ida_rect *rect,
+	     unsigned char *dst, int line, void *data)
+{
+    char *pix;
+    unsigned int i;
+
+    pix = src->data + src->i.width * src->i.height * 3 + line * 3;
+    for (i = 0; i < src->i.height; i++) {
+	pix -= src->i.width * 3;
+	dst[0] = pix[0];
+	dst[1] = pix[1];
+	dst[2] = pix[2];
+	dst += 3;
+    }
+}
+
+static void
+op_rotate_ccw(struct ida_image *src, struct ida_rect *rect,
+	      unsigned char *dst, int line, void *data)
+{
+    char *pix;
+    unsigned int i;
+
+    pix = src->data + (src->i.width-line-1) * 3;
+    for (i = 0; i < src->i.height; i++) {
+	dst[0] = pix[0];
+	dst[1] = pix[1];
+	dst[2] = pix[2];
+	pix += src->i.width * 3;
+	dst += 3;
+    }
+}
+
+static void
+op_invert(struct ida_image *src, struct ida_rect *rect,
+	  unsigned char *dst, int line, void *data)
+{
+    unsigned char *scanline;
+    int i;
+
+    scanline = src->data + line * src->i.width * 3;
+    memcpy(dst,scanline,src->i.width * 3);
+    if (line < rect->y1 || line >= rect->y2)
+	return;
+    dst      += 3*rect->x1;
+    scanline += 3*rect->x1;
+    for (i = rect->x1; i < rect->x2; i++) {
+	dst[0] = 255-scanline[0];
+	dst[1] = 255-scanline[1];
+	dst[2] = 255-scanline[2];
+	scanline += 3;
+	dst += 3;
+    }
+}
+
+static void*
+op_crop_init(struct ida_image *src, struct ida_rect *rect,
+	     struct ida_image_info *i, void *parm)
+{
+    if (rect->x2 - rect->x1 == src->i.width &&
+	rect->y2 - rect->y1 == src->i.height)
+	return NULL;
+    *i = src->i;
+    i->width  = rect->x2 - rect->x1;
+    i->height = rect->y2 - rect->y1;
+    return &op_none_data;
+}
+
+static void
+op_crop_work(struct ida_image *src, struct ida_rect *rect,
+	     unsigned char *dst, int line, void *data)
+{
+    unsigned char *scanline;
+    int i;
+
+    scanline = src->data + (line+rect->y1) * src->i.width * 3 + rect->x1 * 3;
+    for (i = rect->x1; i < rect->x2; i++) {
+	dst[0] = scanline[0];
+	dst[1] = scanline[1];
+	dst[2] = scanline[2];
+	scanline += 3;
+	dst += 3;
+    }
+}
+
+static void*
+op_autocrop_init(struct ida_image *src, struct ida_rect *unused,
+		 struct ida_image_info *i, void *parm)
+{
+    static struct op_3x3_parm filter = {
+	f1: { -1, -1, -1 },
+	f2: { -1,  8, -1 },
+	f3: { -1, -1, -1 },
+    };
+    struct ida_rect rect;
+    struct ida_image img;
+    int x,y,limit;
+    unsigned char *line;
+    void *data;
+    
+    /* detect edges */
+    rect.x1 = 0;
+    rect.x2 = src->i.width;
+    rect.y1 = 0;
+    rect.y2 = src->i.height;
+    data = desc_3x3.init(src, &rect, &img.i, &filter);
+
+    img.data   = malloc(img.i.width * img.i.height * 3);
+    for (y = 0; y < (int)img.i.height; y++)
+	desc_3x3.work(src, &rect, img.data+3*img.i.width*y, y, data);
+    desc_3x3.done(data);
+    limit = 64;
+
+    /* y border */
+    for (y = 0; y < (int)img.i.height; y++) {
+	line = img.data + img.i.width*y*3;
+	for (x = 0; x < (int)img.i.width; x++)
+	    if (line[3*x+0] > limit ||
+		line[3*x+1] > limit ||
+		line[3*x+2] > limit)
+		break;
+	if (x != (int)img.i.width)
+	    break;
+    }
+    rect.y1 = y;
+    for (y = (int)img.i.height-1; y > rect.y1; y--) {
+	line = img.data + img.i.width*y*3;
+	for (x = 0; x < (int)img.i.width; x++)
+	    if (line[3*x+0] > limit ||
+		line[3*x+1] > limit ||
+		line[3*x+2] > limit)
+		break;
+	if (x != (int)img.i.width)
+	    break;
+    }
+    rect.y2 = y+1;
+
+    /* x border */
+    for (x = 0; x < (int)img.i.width; x++) {
+	for (y = 0; y < (int)img.i.height; y++) {
+	    line = img.data + (img.i.width*y+x) * 3;
+	    if (line[0] > limit ||
+		line[1] > limit ||
+		line[2] > limit)
+		break;
+	}
+	if (y != (int)img.i.height)
+	    break;
+    }
+    rect.x1 = x;
+    for (x = (int)img.i.width-1; x > rect.x1; x--) {
+	for (y = 0; y < (int)img.i.height; y++) {
+	    line = img.data + (img.i.width*y+x) * 3;
+	    if (line[0] > limit ||
+		line[1] > limit ||
+		line[2] > limit)
+		break;
+	}
+	if (y != (int)img.i.height)
+	    break;
+    }
+    rect.x2 = x+1;
+
+    free(img.data);
+    if (debug)
+	fprintf(stderr,"y: %d-%d/%d  --  x: %d-%d/%d\n",
+		rect.y1, rect.y2, img.i.height,
+		rect.x1, rect.x2, img.i.width);
+
+    if (0 == rect.x2 - rect.x1  ||  0 == rect.y2 - rect.y1)
+	return NULL;
+    
+    *unused = rect;
+    *i = src->i;
+    i->width  = rect.x2 - rect.x1;
+    i->height = rect.y2 - rect.y1;
+    return &op_none_data;
+}
+
+/* ----------------------------------------------------------------------- */
+
+static char op_none_data;
+
+void* op_none_init(struct ida_image *src,  struct ida_rect *sel,
+		   struct ida_image_info *i, void *parm)
+{
+    *i = src->i;
+    return &op_none_data;
+}
+
+void  op_none_done(void *data) {}
+void  op_free_done(void *data) { free(data); }
+
+/* ----------------------------------------------------------------------- */
+
+struct ida_op desc_flip_vert = {
+    name:  "flip-vert",
+    init:  op_none_init,
+    work:  op_flip_vert,
+    done:  op_none_done,
+};
+struct ida_op desc_flip_horz = {
+    name:  "flip-horz",
+    init:  op_none_init,
+    work:  op_flip_horz,
+    done:  op_none_done,
+};
+struct ida_op desc_rotate_cw = {
+    name:  "rotate-cw",
+    init:  op_rotate_init,
+    work:  op_rotate_cw,
+    done:  op_none_done,
+};
+struct ida_op desc_rotate_ccw = {
+    name:  "rotate-ccw",
+    init:  op_rotate_init,
+    work:  op_rotate_ccw,
+    done:  op_none_done,
+};
+struct ida_op desc_invert = {
+    name:  "invert",
+    init:  op_none_init,
+    work:  op_invert,
+    done:  op_none_done,
+};
+struct ida_op desc_crop = {
+    name:  "crop",
+    init:  op_crop_init,
+    work:  op_crop_work,
+    done:  op_none_done,
+};
+struct ida_op desc_autocrop = {
+    name:  "autocrop",
+    init:  op_autocrop_init,
+    work:  op_crop_work,
+    done:  op_none_done,
+};
diff --git a/lib/a2jpeg/op.h b/lib/a2jpeg/op.h
new file mode 100644
index 0000000..4d882f5
--- /dev/null
+++ b/lib/a2jpeg/op.h
@@ -0,0 +1,7 @@
+extern struct ida_op desc_flip_vert;
+extern struct ida_op desc_flip_horz;
+extern struct ida_op desc_rotate_cw;
+extern struct ida_op desc_rotate_ccw;
+extern struct ida_op desc_invert;
+extern struct ida_op desc_crop;
+extern struct ida_op desc_autocrop;
diff --git a/lib/a2jpeg/read-jpeg.c b/lib/a2jpeg/read-jpeg.c
new file mode 100644
index 0000000..b6b13f6
--- /dev/null
+++ b/lib/a2jpeg/read-jpeg.c
@@ -0,0 +1,209 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <stddef.h>
+#include <string.h>
+#include <errno.h>
+#include <jpeglib.h>
+#include <setjmp.h>
+
+#include <libexif/exif-data.h>
+
+#include "readers.h"
+#include "misc.h"
+
+/* ---------------------------------------------------------------------- */
+/* load                                                                   */
+
+struct jpeg_state {
+    FILE * infile;                /* source file */
+    
+    struct jpeg_decompress_struct cinfo;
+    struct jpeg_error_mgr jerr;
+    jmp_buf errjump;
+    JSAMPARRAY buffer;            /* Output row buffer */
+    int row_stride,linelength;    /* physical row width in output buffer */
+    unsigned char *image,*ptr;
+
+    /* thumbnail */
+    unsigned char  *thumbnail;
+    unsigned int   tpos, tsize;
+};
+
+/* ---------------------------------------------------------------------- */
+/* data source manager for thumbnail images                               */
+
+static void thumbnail_src_init(struct jpeg_decompress_struct *cinfo)
+{
+    struct jpeg_state *h  = container_of(cinfo, struct jpeg_state, cinfo);
+    cinfo->src->next_input_byte = h->thumbnail;
+    cinfo->src->bytes_in_buffer = h->tsize;
+}
+
+static int thumbnail_src_fill(struct jpeg_decompress_struct *cinfo)
+{
+    fprintf(stderr,"jpeg: panic: no more thumbnail input data\n");
+    exit(1);
+}
+
+static void thumbnail_src_skip(struct jpeg_decompress_struct *cinfo,
+			       long num_bytes)
+{
+    cinfo->src->next_input_byte += num_bytes;
+}
+
+static void thumbnail_src_term(struct jpeg_decompress_struct *cinfo)
+{
+    /* nothing */
+}
+
+static struct jpeg_source_mgr thumbnail_mgr = {
+    .init_source         = thumbnail_src_init,
+    .fill_input_buffer   = thumbnail_src_fill,
+    .skip_input_data     = thumbnail_src_skip,
+    .resync_to_restart   = jpeg_resync_to_restart,
+    .term_source         = thumbnail_src_term,
+};
+
+/* ---------------------------------------------------------------------- */
+/* jpeg loader                                                            */
+
+static void jerror_exit(j_common_ptr info)
+{
+    struct jpeg_decompress_struct *cinfo = (struct jpeg_decompress_struct *)info;
+    struct jpeg_state *h  = container_of(cinfo, struct jpeg_state, cinfo);
+    cinfo->err->output_message(info);
+    longjmp(h->errjump, 1);
+    jpeg_destroy_decompress(cinfo);
+    exit(1);
+}
+
+static void*
+jpeg_init(FILE *fp, char *filename, unsigned int page,
+	  struct ida_image_info *i, int thumbnail)
+{
+    struct jpeg_state *h;
+    jpeg_saved_marker_ptr mark;
+    
+    h = malloc(sizeof(*h));
+    memset(h,0,sizeof(*h));
+    h->infile = fp;
+
+    h->cinfo.err = jpeg_std_error(&h->jerr);
+    h->cinfo.err->error_exit = jerror_exit;
+    if(setjmp(h->errjump))
+	return 0;
+
+    jpeg_create_decompress(&h->cinfo);
+    jpeg_save_markers(&h->cinfo, JPEG_COM,    0xffff); /* comment */
+    jpeg_save_markers(&h->cinfo, JPEG_APP0+1, 0xffff); /* EXIF */
+    jpeg_stdio_src(&h->cinfo, h->infile);
+    jpeg_read_header(&h->cinfo, TRUE);
+
+    for (mark = h->cinfo.marker_list; NULL != mark; mark = mark->next) {
+	switch (mark->marker) {
+	case JPEG_COM:
+	    if (debug)
+		fprintf(stderr,"jpeg: comment found (COM marker) [%.*s]\n",
+			(int)mark->data_length, mark->data);
+	    load_add_extra(i,EXTRA_COMMENT,mark->data,mark->data_length);
+	    break;
+	case JPEG_APP0 +1:
+	    if (debug)
+		fprintf(stderr,"jpeg: exif data found (APP1 marker)\n");
+	    load_add_extra(i,EXTRA_COMMENT,mark->data,mark->data_length);
+
+	    if (thumbnail) {
+		ExifData *ed;
+		
+		ed = exif_data_new_from_data(mark->data,mark->data_length);
+		if (ed->data &&
+		    ed->data[0] == 0xff &&
+		    ed->data[1] == 0xd8) {
+		    if (debug)
+			fprintf(stderr,"jpeg: exif thumbnail found\n");
+
+		    /* save away thumbnail data */
+		    h->thumbnail = malloc(ed->size);
+		    h->tsize = ed->size;
+		    memcpy(h->thumbnail,ed->data,ed->size);
+		}
+		exif_data_unref(ed);
+	    }
+	    break;
+	}
+    }
+
+    if (h->thumbnail) {
+	/* save image size */
+	i->thumbnail   = 1;
+	i->real_width  = h->cinfo.image_width;
+	i->real_height = h->cinfo.image_height;
+
+	/* re-setup jpeg */
+	jpeg_destroy_decompress(&h->cinfo);
+	fclose(h->infile);
+	h->infile = NULL;
+	jpeg_create_decompress(&h->cinfo);
+	h->cinfo.src = &thumbnail_mgr;
+	jpeg_read_header(&h->cinfo, TRUE);
+    }
+
+    h->cinfo.out_color_space = JCS_RGB;
+    jpeg_start_decompress(&h->cinfo);
+    i->width  = h->cinfo.image_width;
+    i->height = h->cinfo.image_height;
+    i->npages = 1;
+    switch (h->cinfo.density_unit) {
+    case 0: /* unknown */
+	break;
+    case 1: /* dot per inch */
+	i->dpi = h->cinfo.X_density;
+	break;
+    case 2: /* dot per cm */
+	i->dpi = res_cm_to_inch(h->cinfo.X_density);
+	break;
+    }
+
+    return h;
+}
+
+static void
+jpeg_read(unsigned char *dst, unsigned int line, void *data)
+{
+    struct jpeg_state *h = data;
+    JSAMPROW row = dst;
+
+    if(setjmp(h->errjump))
+	return;
+    jpeg_read_scanlines(&h->cinfo, &row, 1);
+}
+
+static void
+jpeg_done(void *data)
+{
+    struct jpeg_state *h = data;
+
+    if (setjmp(h->errjump))
+	return;
+    jpeg_destroy_decompress(&h->cinfo);
+    if (h->infile)
+	fclose(h->infile);
+    if (h->thumbnail)
+	free(h->thumbnail);
+    free(h);
+}
+
+struct ida_loader jpeg_loader = {
+    magic: "\xff\xd8",
+    moff:  0,
+    mlen:  2,
+    name:  "libjpeg",
+    init:  jpeg_init,
+    read:  jpeg_read,
+    done:  jpeg_done,
+};
+
+static void __init init_rd(void)
+{
+    load_register(&jpeg_loader);
+}
diff --git a/lib/a2jpeg/readers.c b/lib/a2jpeg/readers.c
new file mode 100644
index 0000000..065be06
--- /dev/null
+++ b/lib/a2jpeg/readers.c
@@ -0,0 +1,133 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "readers.h"
+
+/* ----------------------------------------------------------------------- */
+
+void load_bits_lsb(unsigned char *dst, unsigned char *src, int width,
+		   int on, int off)
+{
+    int i,mask,bit;
+    
+    for (i = 0; i < width; i++) {
+	mask = 1 << (i & 0x07);
+	bit  = src[i>>3] & mask;
+	dst[0] = bit ? on : off;
+	dst[1] = bit ? on : off;
+	dst[2] = bit ? on : off;
+	dst += 3;
+    }
+}
+
+void load_bits_msb(unsigned char *dst, unsigned char *src, int width,
+		   int on, int off)
+{
+    int i,mask,bit;
+    
+    for (i = 0; i < width; i++) {
+	mask = 1 << (7 - (i & 0x07));
+	bit  = src[i>>3] & mask;
+	dst[0] = bit ? on : off;
+	dst[1] = bit ? on : off;
+	dst[2] = bit ? on : off;
+	dst += 3;
+    }
+}
+
+void load_gray(unsigned char *dst, unsigned char *src, int width)
+{
+    int i;
+
+    for (i = 0; i < width; i++) {
+	dst[0] = src[0];
+	dst[1] = src[0];
+	dst[2] = src[0];
+	dst += 3;
+	src += 1;
+    }
+}
+
+void load_graya(unsigned char *dst, unsigned char *src, int width)
+{
+    int i;
+
+    for (i = 0; i < width; i++) {
+	dst[0] = src[0];
+	dst[1] = src[0];
+	dst[2] = src[0];
+	dst += 3;
+	src += 2;
+    }
+}
+
+void load_rgba(unsigned char *dst, unsigned char *src, int width)
+{
+    int i;
+
+    for (i = 0; i < width; i++) {
+	dst[0] = src[0];
+	dst[1] = src[1];
+	dst[2] = src[2];
+	dst += 3;
+	src += 4;
+    }
+}
+
+/* ----------------------------------------------------------------------- */
+
+int load_add_extra(struct ida_image_info *info, enum ida_extype type,
+		   unsigned char *data, unsigned int size)
+{
+    struct ida_extra *extra;
+
+    extra = malloc(sizeof(*extra));
+    if (NULL == extra)
+	return -1;
+    memset(extra,0,sizeof(*extra));
+    extra->data = malloc(size);
+    if (NULL == extra->data) {
+	free(extra);
+	return -1;
+    }
+    extra->type = type;
+    extra->size = size;
+    memcpy(extra->data,data,size);
+    extra->next = info->extra;
+    info->extra = extra;
+    return 0;
+};
+
+struct ida_extra* load_find_extra(struct ida_image_info *info,
+				  enum ida_extype type)
+{
+    struct ida_extra *extra;
+
+    for (extra = info->extra; NULL != extra; extra = extra->next)
+	if (type == extra->type)
+	    return extra;
+    return NULL;
+}
+
+int load_free_extras(struct ida_image_info *info)
+{
+    struct ida_extra *next;
+
+    while (NULL != info->extra) {
+	next = info->extra->next;
+	free(info->extra->data);
+	free(info->extra);
+	info->extra = next;
+    }
+    return 0;
+}
+
+/* ----------------------------------------------------------------------- */
+
+LIST_HEAD(loaders);
+
+void load_register(struct ida_loader *loader)
+{
+    list_add_tail(&loader->list, &loaders);
+}
diff --git a/lib/a2jpeg/readers.h b/lib/a2jpeg/readers.h
new file mode 100644
index 0000000..b54e5b6
--- /dev/null
+++ b/lib/a2jpeg/readers.h
@@ -0,0 +1,104 @@
+#include "list.h"
+
+enum ida_extype {
+    EXTRA_COMMENT = 1,
+    EXTRA_EXIF    = 2,
+};
+
+struct ida_extra {
+    enum ida_extype   type;
+    unsigned char     *data;
+    unsigned int      size;
+    struct ida_extra  *next;
+};
+
+/* image data and metadata */
+struct ida_image_info {
+    unsigned int      width;
+    unsigned int      height;
+    unsigned int      dpi;
+    unsigned int      npages;
+    struct ida_extra  *extra;
+
+    int               thumbnail;
+    unsigned int      real_width;
+    unsigned int      real_height;
+};
+
+struct ida_image {
+    struct ida_image_info  i;
+    unsigned char          *data;
+};
+struct ida_rect {
+    int x1,y1,x2,y2;
+};
+
+/* load image files */
+struct ida_loader {
+    char  *magic;
+    int   moff;
+    int   mlen;
+    char  *name;
+    void* (*init)(FILE *fp, char *filename, unsigned int page,
+		  struct ida_image_info *i, int thumbnail);
+    void  (*read)(unsigned char *dst, unsigned int line, void *data);
+    void  (*done)(void *data);
+    struct list_head list;
+};
+
+/* filter + operations */
+struct ida_op {
+    char  *name;
+    void* (*init)(struct ida_image *src, struct ida_rect *rect,
+		  struct ida_image_info *i, void *parm);
+    void  (*work)(struct ida_image *src, struct ida_rect *rect,
+		  unsigned char *dst, int line,
+		  void *data);
+    void  (*done)(void *data);
+};
+
+void* op_none_init(struct ida_image *src, struct ida_rect *rect,
+		   struct ida_image_info *i, void *parm);
+void  op_none_done(void *data);
+void  op_free_done(void *data);
+
+/* ----------------------------------------------------------------------- */
+/* resolution                                                              */
+
+#define res_cm_to_inch(x) ((x * 2540 + 5) / 1000)
+#define res_m_to_inch(x)  ((x * 2540 + 5) / 100000)
+#define res_inch_to_m(x)  ((x * 100000 + 5) / 2540)
+
+/* ----------------------------------------------------------------------- */
+
+/* helpers */
+void load_bits_lsb(unsigned char *dst, unsigned char *src, int width,
+		   int on, int off);
+void load_bits_msb(unsigned char *dst, unsigned char *src, int width,
+		   int on, int off);
+void load_gray(unsigned char *dst, unsigned char *src, int width);
+void load_graya(unsigned char *dst, unsigned char *src, int width);
+void load_rgba(unsigned char *dst, unsigned char *src, int width);
+
+int load_add_extra(struct ida_image_info *info, enum ida_extype type,
+		   unsigned char *data, unsigned int size);
+struct ida_extra* load_find_extra(struct ida_image_info *info,
+				  enum ida_extype type);
+int load_free_extras(struct ida_image_info *info);
+
+/* ----------------------------------------------------------------------- */
+
+/* other */
+extern int debug;
+extern struct ida_loader ppm_loader;
+extern struct ida_loader jpeg_loader;
+extern struct ida_loader sane_loader;
+extern struct ida_writer ps_writer;
+extern struct ida_writer jpeg_writer;
+
+/* lists */
+#define __init __attribute__ ((constructor))
+#define __fini __attribute__ ((destructor))
+
+extern struct list_head loaders;
+void load_register(struct ida_loader *loader);
diff --git a/lib/a2jpeg/transupp.c b/lib/a2jpeg/transupp.c
new file mode 100644
index 0000000..4060544
--- /dev/null
+++ b/lib/a2jpeg/transupp.c
@@ -0,0 +1,1583 @@
+/*
+ * transupp.c
+ *
+ * Copyright (C) 1997-2009, Thomas G. Lane, Guido Vollbeding.
+ * This file is part of the Independent JPEG Group's software.
+ * For conditions of distribution and use, see the accompanying README file.
+ *
+ * This file contains image transformation routines and other utility code
+ * used by the jpegtran sample application.  These are NOT part of the core
+ * JPEG library.  But we keep these routines separate from jpegtran.c to
+ * ease the task of maintaining jpegtran-like programs that have other user
+ * interfaces.
+ */
+
+/* Although this file really shouldn't have access to the library internals,
+ * it's helpful to let it call jround_up() and jcopy_block_row().
+ */
+#define JPEG_INTERNALS
+
+#include "jinclude.h"
+#include "jpeglib.h"
+#include "transupp.h"		/* My own external interface */
+#include <ctype.h>		/* to declare isdigit() */
+
+
+#if TRANSFORMS_SUPPORTED
+
+/*
+ * Lossless image transformation routines.  These routines work on DCT
+ * coefficient arrays and thus do not require any lossy decompression
+ * or recompression of the image.
+ * Thanks to Guido Vollbeding for the initial design and code of this feature,
+ * and to Ben Jackson for introducing the cropping feature.
+ *
+ * Horizontal flipping is done in-place, using a single top-to-bottom
+ * pass through the virtual source array.  It will thus be much the
+ * fastest option for images larger than main memory.
+ *
+ * The other routines require a set of destination virtual arrays, so they
+ * need twice as much memory as jpegtran normally does.  The destination
+ * arrays are always written in normal scan order (top to bottom) because
+ * the virtual array manager expects this.  The source arrays will be scanned
+ * in the corresponding order, which means multiple passes through the source
+ * arrays for most of the transforms.  That could result in much thrashing
+ * if the image is larger than main memory.
+ *
+ * If cropping or trimming is involved, the destination arrays may be smaller
+ * than the source arrays.  Note it is not possible to do horizontal flip
+ * in-place when a nonzero Y crop offset is specified, since we'd have to move
+ * data from one block row to another but the virtual array manager doesn't
+ * guarantee we can touch more than one row at a time.  So in that case,
+ * we have to use a separate destination array.
+ *
+ * Some notes about the operating environment of the individual transform
+ * routines:
+ * 1. Both the source and destination virtual arrays are allocated from the
+ *    source JPEG object, and therefore should be manipulated by calling the
+ *    source's memory manager.
+ * 2. The destination's component count should be used.  It may be smaller
+ *    than the source's when forcing to grayscale.
+ * 3. Likewise the destination's sampling factors should be used.  When
+ *    forcing to grayscale the destination's sampling factors will be all 1,
+ *    and we may as well take that as the effective iMCU size.
+ * 4. When "trim" is in effect, the destination's dimensions will be the
+ *    trimmed values but the source's will be untrimmed.
+ * 5. When "crop" is in effect, the destination's dimensions will be the
+ *    cropped values but the source's will be uncropped.  Each transform
+ *    routine is responsible for picking up source data starting at the
+ *    correct X and Y offset for the crop region.  (The X and Y offsets
+ *    passed to the transform routines are measured in iMCU blocks of the
+ *    destination.)
+ * 6. All the routines assume that the source and destination buffers are
+ *    padded out to a full iMCU boundary.  This is true, although for the
+ *    source buffer it is an undocumented property of jdcoefct.c.
+ */
+
+
+LOCAL(void)
+do_crop (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
+	 JDIMENSION x_crop_offset, JDIMENSION y_crop_offset,
+	 jvirt_barray_ptr *src_coef_arrays,
+	 jvirt_barray_ptr *dst_coef_arrays)
+/* Crop.  This is only used when no rotate/flip is requested with the crop. */
+{
+  JDIMENSION dst_blk_y, x_crop_blocks, y_crop_blocks;
+  int ci, offset_y;
+  JBLOCKARRAY src_buffer, dst_buffer;
+  jpeg_component_info *compptr;
+
+  /* We simply have to copy the right amount of data (the destination's
+   * image size) starting at the given X and Y offsets in the source.
+   */
+  for (ci = 0; ci < dstinfo->num_components; ci++) {
+    compptr = dstinfo->comp_info + ci;
+    x_crop_blocks = x_crop_offset * compptr->h_samp_factor;
+    y_crop_blocks = y_crop_offset * compptr->v_samp_factor;
+    for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;
+	 dst_blk_y += compptr->v_samp_factor) {
+      dst_buffer = (*srcinfo->mem->access_virt_barray)
+	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
+	 (JDIMENSION) compptr->v_samp_factor, TRUE);
+      src_buffer = (*srcinfo->mem->access_virt_barray)
+	((j_common_ptr) srcinfo, src_coef_arrays[ci],
+	 dst_blk_y + y_crop_blocks,
+	 (JDIMENSION) compptr->v_samp_factor, FALSE);
+      for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
+	jcopy_block_row(src_buffer[offset_y] + x_crop_blocks,
+			dst_buffer[offset_y],
+			compptr->width_in_blocks);
+      }
+    }
+  }
+}
+
+
+LOCAL(void)
+do_flip_h_no_crop (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
+		   JDIMENSION x_crop_offset,
+		   jvirt_barray_ptr *src_coef_arrays)
+/* Horizontal flip; done in-place, so no separate dest array is required.
+ * NB: this only works when y_crop_offset is zero.
+ */
+{
+  JDIMENSION MCU_cols, comp_width, blk_x, blk_y, x_crop_blocks;
+  int ci, k, offset_y;
+  JBLOCKARRAY buffer;
+  JCOEFPTR ptr1, ptr2;
+  JCOEF temp1, temp2;
+  jpeg_component_info *compptr;
+
+  /* Horizontal mirroring of DCT blocks is accomplished by swapping
+   * pairs of blocks in-place.  Within a DCT block, we perform horizontal
+   * mirroring by changing the signs of odd-numbered columns.
+   * Partial iMCUs at the right edge are left untouched.
+   */
+  MCU_cols = srcinfo->output_width /
+    (dstinfo->max_h_samp_factor * dstinfo->min_DCT_h_scaled_size);
+
+  for (ci = 0; ci < dstinfo->num_components; ci++) {
+    compptr = dstinfo->comp_info + ci;
+    comp_width = MCU_cols * compptr->h_samp_factor;
+    x_crop_blocks = x_crop_offset * compptr->h_samp_factor;
+    for (blk_y = 0; blk_y < compptr->height_in_blocks;
+	 blk_y += compptr->v_samp_factor) {
+      buffer = (*srcinfo->mem->access_virt_barray)
+	((j_common_ptr) srcinfo, src_coef_arrays[ci], blk_y,
+	 (JDIMENSION) compptr->v_samp_factor, TRUE);
+      for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
+	/* Do the mirroring */
+	for (blk_x = 0; blk_x * 2 < comp_width; blk_x++) {
+	  ptr1 = buffer[offset_y][blk_x];
+	  ptr2 = buffer[offset_y][comp_width - blk_x - 1];
+	  /* this unrolled loop doesn't need to know which row it's on... */
+	  for (k = 0; k < DCTSIZE2; k += 2) {
+	    temp1 = *ptr1;	/* swap even column */
+	    temp2 = *ptr2;
+	    *ptr1++ = temp2;
+	    *ptr2++ = temp1;
+	    temp1 = *ptr1;	/* swap odd column with sign change */
+	    temp2 = *ptr2;
+	    *ptr1++ = -temp2;
+	    *ptr2++ = -temp1;
+	  }
+	}
+	if (x_crop_blocks > 0) {
+	  /* Now left-justify the portion of the data to be kept.
+	   * We can't use a single jcopy_block_row() call because that routine
+	   * depends on memcpy(), whose behavior is unspecified for overlapping
+	   * source and destination areas.  Sigh.
+	   */
+	  for (blk_x = 0; blk_x < compptr->width_in_blocks; blk_x++) {
+	    jcopy_block_row(buffer[offset_y] + blk_x + x_crop_blocks,
+			    buffer[offset_y] + blk_x,
+			    (JDIMENSION) 1);
+	  }
+	}
+      }
+    }
+  }
+}
+
+
+LOCAL(void)
+do_flip_h (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
+	   JDIMENSION x_crop_offset, JDIMENSION y_crop_offset,
+	   jvirt_barray_ptr *src_coef_arrays,
+	   jvirt_barray_ptr *dst_coef_arrays)
+/* Horizontal flip in general cropping case */
+{
+  JDIMENSION MCU_cols, comp_width, dst_blk_x, dst_blk_y;
+  JDIMENSION x_crop_blocks, y_crop_blocks;
+  int ci, k, offset_y;
+  JBLOCKARRAY src_buffer, dst_buffer;
+  JBLOCKROW src_row_ptr, dst_row_ptr;
+  JCOEFPTR src_ptr, dst_ptr;
+  jpeg_component_info *compptr;
+
+  /* Here we must output into a separate array because we can't touch
+   * different rows of a single virtual array simultaneously.  Otherwise,
+   * this is essentially the same as the routine above.
+   */
+  MCU_cols = srcinfo->output_width /
+    (dstinfo->max_h_samp_factor * dstinfo->min_DCT_h_scaled_size);
+
+  for (ci = 0; ci < dstinfo->num_components; ci++) {
+    compptr = dstinfo->comp_info + ci;
+    comp_width = MCU_cols * compptr->h_samp_factor;
+    x_crop_blocks = x_crop_offset * compptr->h_samp_factor;
+    y_crop_blocks = y_crop_offset * compptr->v_samp_factor;
+    for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;
+	 dst_blk_y += compptr->v_samp_factor) {
+      dst_buffer = (*srcinfo->mem->access_virt_barray)
+	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
+	 (JDIMENSION) compptr->v_samp_factor, TRUE);
+      src_buffer = (*srcinfo->mem->access_virt_barray)
+	((j_common_ptr) srcinfo, src_coef_arrays[ci],
+	 dst_blk_y + y_crop_blocks,
+	 (JDIMENSION) compptr->v_samp_factor, FALSE);
+      for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
+	dst_row_ptr = dst_buffer[offset_y];
+	src_row_ptr = src_buffer[offset_y];
+	for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks; dst_blk_x++) {
+	  if (x_crop_blocks + dst_blk_x < comp_width) {
+	    /* Do the mirrorable blocks */
+	    dst_ptr = dst_row_ptr[dst_blk_x];
+	    src_ptr = src_row_ptr[comp_width - x_crop_blocks - dst_blk_x - 1];
+	    /* this unrolled loop doesn't need to know which row it's on... */
+	    for (k = 0; k < DCTSIZE2; k += 2) {
+	      *dst_ptr++ = *src_ptr++;	 /* copy even column */
+	      *dst_ptr++ = - *src_ptr++; /* copy odd column with sign change */
+	    }
+	  } else {
+	    /* Copy last partial block(s) verbatim */
+	    jcopy_block_row(src_row_ptr + dst_blk_x + x_crop_blocks,
+			    dst_row_ptr + dst_blk_x,
+			    (JDIMENSION) 1);
+	  }
+	}
+      }
+    }
+  }
+}
+
+
+LOCAL(void)
+do_flip_v (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
+	   JDIMENSION x_crop_offset, JDIMENSION y_crop_offset,
+	   jvirt_barray_ptr *src_coef_arrays,
+	   jvirt_barray_ptr *dst_coef_arrays)
+/* Vertical flip */
+{
+  JDIMENSION MCU_rows, comp_height, dst_blk_x, dst_blk_y;
+  JDIMENSION x_crop_blocks, y_crop_blocks;
+  int ci, i, j, offset_y;
+  JBLOCKARRAY src_buffer, dst_buffer;
+  JBLOCKROW src_row_ptr, dst_row_ptr;
+  JCOEFPTR src_ptr, dst_ptr;
+  jpeg_component_info *compptr;
+
+  /* We output into a separate array because we can't touch different
+   * rows of the source virtual array simultaneously.  Otherwise, this
+   * is a pretty straightforward analog of horizontal flip.
+   * Within a DCT block, vertical mirroring is done by changing the signs
+   * of odd-numbered rows.
+   * Partial iMCUs at the bottom edge are copied verbatim.
+   */
+  MCU_rows = srcinfo->output_height /
+    (dstinfo->max_v_samp_factor * dstinfo->min_DCT_v_scaled_size);
+
+  for (ci = 0; ci < dstinfo->num_components; ci++) {
+    compptr = dstinfo->comp_info + ci;
+    comp_height = MCU_rows * compptr->v_samp_factor;
+    x_crop_blocks = x_crop_offset * compptr->h_samp_factor;
+    y_crop_blocks = y_crop_offset * compptr->v_samp_factor;
+    for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;
+	 dst_blk_y += compptr->v_samp_factor) {
+      dst_buffer = (*srcinfo->mem->access_virt_barray)
+	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
+	 (JDIMENSION) compptr->v_samp_factor, TRUE);
+      if (y_crop_blocks + dst_blk_y < comp_height) {
+	/* Row is within the mirrorable area. */
+	src_buffer = (*srcinfo->mem->access_virt_barray)
+	  ((j_common_ptr) srcinfo, src_coef_arrays[ci],
+	   comp_height - y_crop_blocks - dst_blk_y -
+	   (JDIMENSION) compptr->v_samp_factor,
+	   (JDIMENSION) compptr->v_samp_factor, FALSE);
+      } else {
+	/* Bottom-edge blocks will be copied verbatim. */
+	src_buffer = (*srcinfo->mem->access_virt_barray)
+	  ((j_common_ptr) srcinfo, src_coef_arrays[ci],
+	   dst_blk_y + y_crop_blocks,
+	   (JDIMENSION) compptr->v_samp_factor, FALSE);
+      }
+      for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
+	if (y_crop_blocks + dst_blk_y < comp_height) {
+	  /* Row is within the mirrorable area. */
+	  dst_row_ptr = dst_buffer[offset_y];
+	  src_row_ptr = src_buffer[compptr->v_samp_factor - offset_y - 1];
+	  src_row_ptr += x_crop_blocks;
+	  for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks;
+	       dst_blk_x++) {
+	    dst_ptr = dst_row_ptr[dst_blk_x];
+	    src_ptr = src_row_ptr[dst_blk_x];
+	    for (i = 0; i < DCTSIZE; i += 2) {
+	      /* copy even row */
+	      for (j = 0; j < DCTSIZE; j++)
+		*dst_ptr++ = *src_ptr++;
+	      /* copy odd row with sign change */
+	      for (j = 0; j < DCTSIZE; j++)
+		*dst_ptr++ = - *src_ptr++;
+	    }
+	  }
+	} else {
+	  /* Just copy row verbatim. */
+	  jcopy_block_row(src_buffer[offset_y] + x_crop_blocks,
+			  dst_buffer[offset_y],
+			  compptr->width_in_blocks);
+	}
+      }
+    }
+  }
+}
+
+
+LOCAL(void)
+do_transpose (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
+	      JDIMENSION x_crop_offset, JDIMENSION y_crop_offset,
+	      jvirt_barray_ptr *src_coef_arrays,
+	      jvirt_barray_ptr *dst_coef_arrays)
+/* Transpose source into destination */
+{
+  JDIMENSION dst_blk_x, dst_blk_y, x_crop_blocks, y_crop_blocks;
+  int ci, i, j, offset_x, offset_y;
+  JBLOCKARRAY src_buffer, dst_buffer;
+  JCOEFPTR src_ptr, dst_ptr;
+  jpeg_component_info *compptr;
+
+  /* Transposing pixels within a block just requires transposing the
+   * DCT coefficients.
+   * Partial iMCUs at the edges require no special treatment; we simply
+   * process all the available DCT blocks for every component.
+   */
+  for (ci = 0; ci < dstinfo->num_components; ci++) {
+    compptr = dstinfo->comp_info + ci;
+    x_crop_blocks = x_crop_offset * compptr->h_samp_factor;
+    y_crop_blocks = y_crop_offset * compptr->v_samp_factor;
+    for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;
+	 dst_blk_y += compptr->v_samp_factor) {
+      dst_buffer = (*srcinfo->mem->access_virt_barray)
+	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
+	 (JDIMENSION) compptr->v_samp_factor, TRUE);
+      for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
+	for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks;
+	     dst_blk_x += compptr->h_samp_factor) {
+	  src_buffer = (*srcinfo->mem->access_virt_barray)
+	    ((j_common_ptr) srcinfo, src_coef_arrays[ci],
+	     dst_blk_x + x_crop_blocks,
+	     (JDIMENSION) compptr->h_samp_factor, FALSE);
+	  for (offset_x = 0; offset_x < compptr->h_samp_factor; offset_x++) {
+	    dst_ptr = dst_buffer[offset_y][dst_blk_x + offset_x];
+	    src_ptr = src_buffer[offset_x][dst_blk_y + offset_y + y_crop_blocks];
+	    for (i = 0; i < DCTSIZE; i++)
+	      for (j = 0; j < DCTSIZE; j++)
+		dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
+	  }
+	}
+      }
+    }
+  }
+}
+
+
+LOCAL(void)
+do_rot_90 (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
+	   JDIMENSION x_crop_offset, JDIMENSION y_crop_offset,
+	   jvirt_barray_ptr *src_coef_arrays,
+	   jvirt_barray_ptr *dst_coef_arrays)
+/* 90 degree rotation is equivalent to
+ *   1. Transposing the image;
+ *   2. Horizontal mirroring.
+ * These two steps are merged into a single processing routine.
+ */
+{
+  JDIMENSION MCU_cols, comp_width, dst_blk_x, dst_blk_y;
+  JDIMENSION x_crop_blocks, y_crop_blocks;
+  int ci, i, j, offset_x, offset_y;
+  JBLOCKARRAY src_buffer, dst_buffer;
+  JCOEFPTR src_ptr, dst_ptr;
+  jpeg_component_info *compptr;
+
+  /* Because of the horizontal mirror step, we can't process partial iMCUs
+   * at the (output) right edge properly.  They just get transposed and
+   * not mirrored.
+   */
+  MCU_cols = srcinfo->output_height /
+    (dstinfo->max_h_samp_factor * dstinfo->min_DCT_h_scaled_size);
+
+  for (ci = 0; ci < dstinfo->num_components; ci++) {
+    compptr = dstinfo->comp_info + ci;
+    comp_width = MCU_cols * compptr->h_samp_factor;
+    x_crop_blocks = x_crop_offset * compptr->h_samp_factor;
+    y_crop_blocks = y_crop_offset * compptr->v_samp_factor;
+    for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;
+	 dst_blk_y += compptr->v_samp_factor) {
+      dst_buffer = (*srcinfo->mem->access_virt_barray)
+	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
+	 (JDIMENSION) compptr->v_samp_factor, TRUE);
+      for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
+	for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks;
+	     dst_blk_x += compptr->h_samp_factor) {
+	  if (x_crop_blocks + dst_blk_x < comp_width) {
+	    /* Block is within the mirrorable area. */
+	    src_buffer = (*srcinfo->mem->access_virt_barray)
+	      ((j_common_ptr) srcinfo, src_coef_arrays[ci],
+	       comp_width - x_crop_blocks - dst_blk_x -
+	       (JDIMENSION) compptr->h_samp_factor,
+	       (JDIMENSION) compptr->h_samp_factor, FALSE);
+	  } else {
+	    /* Edge blocks are transposed but not mirrored. */
+	    src_buffer = (*srcinfo->mem->access_virt_barray)
+	      ((j_common_ptr) srcinfo, src_coef_arrays[ci],
+	       dst_blk_x + x_crop_blocks,
+	       (JDIMENSION) compptr->h_samp_factor, FALSE);
+	  }
+	  for (offset_x = 0; offset_x < compptr->h_samp_factor; offset_x++) {
+	    dst_ptr = dst_buffer[offset_y][dst_blk_x + offset_x];
+	    if (x_crop_blocks + dst_blk_x < comp_width) {
+	      /* Block is within the mirrorable area. */
+	      src_ptr = src_buffer[compptr->h_samp_factor - offset_x - 1]
+		[dst_blk_y + offset_y + y_crop_blocks];
+	      for (i = 0; i < DCTSIZE; i++) {
+		for (j = 0; j < DCTSIZE; j++)
+		  dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
+		i++;
+		for (j = 0; j < DCTSIZE; j++)
+		  dst_ptr[j*DCTSIZE+i] = -src_ptr[i*DCTSIZE+j];
+	      }
+	    } else {
+	      /* Edge blocks are transposed but not mirrored. */
+	      src_ptr = src_buffer[offset_x]
+		[dst_blk_y + offset_y + y_crop_blocks];
+	      for (i = 0; i < DCTSIZE; i++)
+		for (j = 0; j < DCTSIZE; j++)
+		  dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
+	    }
+	  }
+	}
+      }
+    }
+  }
+}
+
+
+LOCAL(void)
+do_rot_270 (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
+	    JDIMENSION x_crop_offset, JDIMENSION y_crop_offset,
+	    jvirt_barray_ptr *src_coef_arrays,
+	    jvirt_barray_ptr *dst_coef_arrays)
+/* 270 degree rotation is equivalent to
+ *   1. Horizontal mirroring;
+ *   2. Transposing the image.
+ * These two steps are merged into a single processing routine.
+ */
+{
+  JDIMENSION MCU_rows, comp_height, dst_blk_x, dst_blk_y;
+  JDIMENSION x_crop_blocks, y_crop_blocks;
+  int ci, i, j, offset_x, offset_y;
+  JBLOCKARRAY src_buffer, dst_buffer;
+  JCOEFPTR src_ptr, dst_ptr;
+  jpeg_component_info *compptr;
+
+  /* Because of the horizontal mirror step, we can't process partial iMCUs
+   * at the (output) bottom edge properly.  They just get transposed and
+   * not mirrored.
+   */
+  MCU_rows = srcinfo->output_width /
+    (dstinfo->max_v_samp_factor * dstinfo->min_DCT_v_scaled_size);
+
+  for (ci = 0; ci < dstinfo->num_components; ci++) {
+    compptr = dstinfo->comp_info + ci;
+    comp_height = MCU_rows * compptr->v_samp_factor;
+    x_crop_blocks = x_crop_offset * compptr->h_samp_factor;
+    y_crop_blocks = y_crop_offset * compptr->v_samp_factor;
+    for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;
+	 dst_blk_y += compptr->v_samp_factor) {
+      dst_buffer = (*srcinfo->mem->access_virt_barray)
+	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
+	 (JDIMENSION) compptr->v_samp_factor, TRUE);
+      for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
+	for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks;
+	     dst_blk_x += compptr->h_samp_factor) {
+	  src_buffer = (*srcinfo->mem->access_virt_barray)
+	    ((j_common_ptr) srcinfo, src_coef_arrays[ci],
+	     dst_blk_x + x_crop_blocks,
+	     (JDIMENSION) compptr->h_samp_factor, FALSE);
+	  for (offset_x = 0; offset_x < compptr->h_samp_factor; offset_x++) {
+	    dst_ptr = dst_buffer[offset_y][dst_blk_x + offset_x];
+	    if (y_crop_blocks + dst_blk_y < comp_height) {
+	      /* Block is within the mirrorable area. */
+	      src_ptr = src_buffer[offset_x]
+		[comp_height - y_crop_blocks - dst_blk_y - offset_y - 1];
+	      for (i = 0; i < DCTSIZE; i++) {
+		for (j = 0; j < DCTSIZE; j++) {
+		  dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
+		  j++;
+		  dst_ptr[j*DCTSIZE+i] = -src_ptr[i*DCTSIZE+j];
+		}
+	      }
+	    } else {
+	      /* Edge blocks are transposed but not mirrored. */
+	      src_ptr = src_buffer[offset_x]
+		[dst_blk_y + offset_y + y_crop_blocks];
+	      for (i = 0; i < DCTSIZE; i++)
+		for (j = 0; j < DCTSIZE; j++)
+		  dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
+	    }
+	  }
+	}
+      }
+    }
+  }
+}
+
+
+LOCAL(void)
+do_rot_180 (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
+	    JDIMENSION x_crop_offset, JDIMENSION y_crop_offset,
+	    jvirt_barray_ptr *src_coef_arrays,
+	    jvirt_barray_ptr *dst_coef_arrays)
+/* 180 degree rotation is equivalent to
+ *   1. Vertical mirroring;
+ *   2. Horizontal mirroring.
+ * These two steps are merged into a single processing routine.
+ */
+{
+  JDIMENSION MCU_cols, MCU_rows, comp_width, comp_height, dst_blk_x, dst_blk_y;
+  JDIMENSION x_crop_blocks, y_crop_blocks;
+  int ci, i, j, offset_y;
+  JBLOCKARRAY src_buffer, dst_buffer;
+  JBLOCKROW src_row_ptr, dst_row_ptr;
+  JCOEFPTR src_ptr, dst_ptr;
+  jpeg_component_info *compptr;
+
+  MCU_cols = srcinfo->output_width /
+    (dstinfo->max_h_samp_factor * dstinfo->min_DCT_h_scaled_size);
+  MCU_rows = srcinfo->output_height /
+    (dstinfo->max_v_samp_factor * dstinfo->min_DCT_v_scaled_size);
+
+  for (ci = 0; ci < dstinfo->num_components; ci++) {
+    compptr = dstinfo->comp_info + ci;
+    comp_width = MCU_cols * compptr->h_samp_factor;
+    comp_height = MCU_rows * compptr->v_samp_factor;
+    x_crop_blocks = x_crop_offset * compptr->h_samp_factor;
+    y_crop_blocks = y_crop_offset * compptr->v_samp_factor;
+    for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;
+	 dst_blk_y += compptr->v_samp_factor) {
+      dst_buffer = (*srcinfo->mem->access_virt_barray)
+	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
+	 (JDIMENSION) compptr->v_samp_factor, TRUE);
+      if (y_crop_blocks + dst_blk_y < comp_height) {
+	/* Row is within the vertically mirrorable area. */
+	src_buffer = (*srcinfo->mem->access_virt_barray)
+	  ((j_common_ptr) srcinfo, src_coef_arrays[ci],
+	   comp_height - y_crop_blocks - dst_blk_y -
+	   (JDIMENSION) compptr->v_samp_factor,
+	   (JDIMENSION) compptr->v_samp_factor, FALSE);
+      } else {
+	/* Bottom-edge rows are only mirrored horizontally. */
+	src_buffer = (*srcinfo->mem->access_virt_barray)
+	  ((j_common_ptr) srcinfo, src_coef_arrays[ci],
+	   dst_blk_y + y_crop_blocks,
+	   (JDIMENSION) compptr->v_samp_factor, FALSE);
+      }
+      for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
+	dst_row_ptr = dst_buffer[offset_y];
+	if (y_crop_blocks + dst_blk_y < comp_height) {
+	  /* Row is within the mirrorable area. */
+	  src_row_ptr = src_buffer[compptr->v_samp_factor - offset_y - 1];
+	  for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks; dst_blk_x++) {
+	    dst_ptr = dst_row_ptr[dst_blk_x];
+	    if (x_crop_blocks + dst_blk_x < comp_width) {
+	      /* Process the blocks that can be mirrored both ways. */
+	      src_ptr = src_row_ptr[comp_width - x_crop_blocks - dst_blk_x - 1];
+	      for (i = 0; i < DCTSIZE; i += 2) {
+		/* For even row, negate every odd column. */
+		for (j = 0; j < DCTSIZE; j += 2) {
+		  *dst_ptr++ = *src_ptr++;
+		  *dst_ptr++ = - *src_ptr++;
+		}
+		/* For odd row, negate every even column. */
+		for (j = 0; j < DCTSIZE; j += 2) {
+		  *dst_ptr++ = - *src_ptr++;
+		  *dst_ptr++ = *src_ptr++;
+		}
+	      }
+	    } else {
+	      /* Any remaining right-edge blocks are only mirrored vertically. */
+	      src_ptr = src_row_ptr[x_crop_blocks + dst_blk_x];
+	      for (i = 0; i < DCTSIZE; i += 2) {
+		for (j = 0; j < DCTSIZE; j++)
+		  *dst_ptr++ = *src_ptr++;
+		for (j = 0; j < DCTSIZE; j++)
+		  *dst_ptr++ = - *src_ptr++;
+	      }
+	    }
+	  }
+	} else {
+	  /* Remaining rows are just mirrored horizontally. */
+	  src_row_ptr = src_buffer[offset_y];
+	  for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks; dst_blk_x++) {
+	    if (x_crop_blocks + dst_blk_x < comp_width) {
+	      /* Process the blocks that can be mirrored. */
+	      dst_ptr = dst_row_ptr[dst_blk_x];
+	      src_ptr = src_row_ptr[comp_width - x_crop_blocks - dst_blk_x - 1];
+	      for (i = 0; i < DCTSIZE2; i += 2) {
+		*dst_ptr++ = *src_ptr++;
+		*dst_ptr++ = - *src_ptr++;
+	      }
+	    } else {
+	      /* Any remaining right-edge blocks are only copied. */
+	      jcopy_block_row(src_row_ptr + dst_blk_x + x_crop_blocks,
+			      dst_row_ptr + dst_blk_x,
+			      (JDIMENSION) 1);
+	    }
+	  }
+	}
+      }
+    }
+  }
+}
+
+
+LOCAL(void)
+do_transverse (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
+	       JDIMENSION x_crop_offset, JDIMENSION y_crop_offset,
+	       jvirt_barray_ptr *src_coef_arrays,
+	       jvirt_barray_ptr *dst_coef_arrays)
+/* Transverse transpose is equivalent to
+ *   1. 180 degree rotation;
+ *   2. Transposition;
+ * or
+ *   1. Horizontal mirroring;
+ *   2. Transposition;
+ *   3. Horizontal mirroring.
+ * These steps are merged into a single processing routine.
+ */
+{
+  JDIMENSION MCU_cols, MCU_rows, comp_width, comp_height, dst_blk_x, dst_blk_y;
+  JDIMENSION x_crop_blocks, y_crop_blocks;
+  int ci, i, j, offset_x, offset_y;
+  JBLOCKARRAY src_buffer, dst_buffer;
+  JCOEFPTR src_ptr, dst_ptr;
+  jpeg_component_info *compptr;
+
+  MCU_cols = srcinfo->output_height /
+    (dstinfo->max_h_samp_factor * dstinfo->min_DCT_h_scaled_size);
+  MCU_rows = srcinfo->output_width /
+    (dstinfo->max_v_samp_factor * dstinfo->min_DCT_v_scaled_size);
+
+  for (ci = 0; ci < dstinfo->num_components; ci++) {
+    compptr = dstinfo->comp_info + ci;
+    comp_width = MCU_cols * compptr->h_samp_factor;
+    comp_height = MCU_rows * compptr->v_samp_factor;
+    x_crop_blocks = x_crop_offset * compptr->h_samp_factor;
+    y_crop_blocks = y_crop_offset * compptr->v_samp_factor;
+    for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;
+	 dst_blk_y += compptr->v_samp_factor) {
+      dst_buffer = (*srcinfo->mem->access_virt_barray)
+	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
+	 (JDIMENSION) compptr->v_samp_factor, TRUE);
+      for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
+	for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks;
+	     dst_blk_x += compptr->h_samp_factor) {
+	  if (x_crop_blocks + dst_blk_x < comp_width) {
+	    /* Block is within the mirrorable area. */
+	    src_buffer = (*srcinfo->mem->access_virt_barray)
+	      ((j_common_ptr) srcinfo, src_coef_arrays[ci],
+	       comp_width - x_crop_blocks - dst_blk_x -
+	       (JDIMENSION) compptr->h_samp_factor,
+	       (JDIMENSION) compptr->h_samp_factor, FALSE);
+	  } else {
+	    src_buffer = (*srcinfo->mem->access_virt_barray)
+	      ((j_common_ptr) srcinfo, src_coef_arrays[ci],
+	       dst_blk_x + x_crop_blocks,
+	       (JDIMENSION) compptr->h_samp_factor, FALSE);
+	  }
+	  for (offset_x = 0; offset_x < compptr->h_samp_factor; offset_x++) {
+	    dst_ptr = dst_buffer[offset_y][dst_blk_x + offset_x];
+	    if (y_crop_blocks + dst_blk_y < comp_height) {
+	      if (x_crop_blocks + dst_blk_x < comp_width) {
+		/* Block is within the mirrorable area. */
+		src_ptr = src_buffer[compptr->h_samp_factor - offset_x - 1]
+		  [comp_height - y_crop_blocks - dst_blk_y - offset_y - 1];
+		for (i = 0; i < DCTSIZE; i++) {
+		  for (j = 0; j < DCTSIZE; j++) {
+		    dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
+		    j++;
+		    dst_ptr[j*DCTSIZE+i] = -src_ptr[i*DCTSIZE+j];
+		  }
+		  i++;
+		  for (j = 0; j < DCTSIZE; j++) {
+		    dst_ptr[j*DCTSIZE+i] = -src_ptr[i*DCTSIZE+j];
+		    j++;
+		    dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
+		  }
+		}
+	      } else {
+		/* Right-edge blocks are mirrored in y only */
+		src_ptr = src_buffer[offset_x]
+		  [comp_height - y_crop_blocks - dst_blk_y - offset_y - 1];
+		for (i = 0; i < DCTSIZE; i++) {
+		  for (j = 0; j < DCTSIZE; j++) {
+		    dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
+		    j++;
+		    dst_ptr[j*DCTSIZE+i] = -src_ptr[i*DCTSIZE+j];
+		  }
+		}
+	      }
+	    } else {
+	      if (x_crop_blocks + dst_blk_x < comp_width) {
+		/* Bottom-edge blocks are mirrored in x only */
+		src_ptr = src_buffer[compptr->h_samp_factor - offset_x - 1]
+		  [dst_blk_y + offset_y + y_crop_blocks];
+		for (i = 0; i < DCTSIZE; i++) {
+		  for (j = 0; j < DCTSIZE; j++)
+		    dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
+		  i++;
+		  for (j = 0; j < DCTSIZE; j++)
+		    dst_ptr[j*DCTSIZE+i] = -src_ptr[i*DCTSIZE+j];
+		}
+	      } else {
+		/* At lower right corner, just transpose, no mirroring */
+		src_ptr = src_buffer[offset_x]
+		  [dst_blk_y + offset_y + y_crop_blocks];
+		for (i = 0; i < DCTSIZE; i++)
+		  for (j = 0; j < DCTSIZE; j++)
+		    dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
+	      }
+	    }
+	  }
+	}
+      }
+    }
+  }
+}
+
+
+/* Parse an unsigned integer: subroutine for jtransform_parse_crop_spec.
+ * Returns TRUE if valid integer found, FALSE if not.
+ * *strptr is advanced over the digit string, and *result is set to its value.
+ */
+
+LOCAL(boolean)
+jt_read_integer (const char ** strptr, JDIMENSION * result)
+{
+  const char * ptr = *strptr;
+  JDIMENSION val = 0;
+
+  for (; isdigit(*ptr); ptr++) {
+    val = val * 10 + (JDIMENSION) (*ptr - '0');
+  }
+  *result = val;
+  if (ptr == *strptr)
+    return FALSE;		/* oops, no digits */
+  *strptr = ptr;
+  return TRUE;
+}
+
+
+/* Parse a crop specification (written in X11 geometry style).
+ * The routine returns TRUE if the spec string is valid, FALSE if not.
+ *
+ * The crop spec string should have the format
+ *	<width>x<height>{+-}<xoffset>{+-}<yoffset>
+ * where width, height, xoffset, and yoffset are unsigned integers.
+ * Each of the elements can be omitted to indicate a default value.
+ * (A weakness of this style is that it is not possible to omit xoffset
+ * while specifying yoffset, since they look alike.)
+ *
+ * This code is loosely based on XParseGeometry from the X11 distribution.
+ */
+
+GLOBAL(boolean)
+jtransform_parse_crop_spec (jpeg_transform_info *info, const char *spec)
+{
+  info->crop = FALSE;
+  info->crop_width_set = JCROP_UNSET;
+  info->crop_height_set = JCROP_UNSET;
+  info->crop_xoffset_set = JCROP_UNSET;
+  info->crop_yoffset_set = JCROP_UNSET;
+
+  if (isdigit(*spec)) {
+    /* fetch width */
+    if (! jt_read_integer(&spec, &info->crop_width))
+      return FALSE;
+    info->crop_width_set = JCROP_POS;
+  }
+  if (*spec == 'x' || *spec == 'X') {	
+    /* fetch height */
+    spec++;
+    if (! jt_read_integer(&spec, &info->crop_height))
+      return FALSE;
+    info->crop_height_set = JCROP_POS;
+  }
+  if (*spec == '+' || *spec == '-') {
+    /* fetch xoffset */
+    info->crop_xoffset_set = (*spec == '-') ? JCROP_NEG : JCROP_POS;
+    spec++;
+    if (! jt_read_integer(&spec, &info->crop_xoffset))
+      return FALSE;
+  }
+  if (*spec == '+' || *spec == '-') {
+    /* fetch yoffset */
+    info->crop_yoffset_set = (*spec == '-') ? JCROP_NEG : JCROP_POS;
+    spec++;
+    if (! jt_read_integer(&spec, &info->crop_yoffset))
+      return FALSE;
+  }
+  /* We had better have gotten to the end of the string. */
+  if (*spec != '\0')
+    return FALSE;
+  info->crop = TRUE;
+  return TRUE;
+}
+
+
+/* Trim off any partial iMCUs on the indicated destination edge */
+
+LOCAL(void)
+trim_right_edge (jpeg_transform_info *info, JDIMENSION full_width)
+{
+  JDIMENSION MCU_cols;
+
+  MCU_cols = info->output_width / info->iMCU_sample_width;
+  if (MCU_cols > 0 && info->x_crop_offset + MCU_cols ==
+      full_width / info->iMCU_sample_width)
+    info->output_width = MCU_cols * info->iMCU_sample_width;
+}
+
+LOCAL(void)
+trim_bottom_edge (jpeg_transform_info *info, JDIMENSION full_height)
+{
+  JDIMENSION MCU_rows;
+
+  MCU_rows = info->output_height / info->iMCU_sample_height;
+  if (MCU_rows > 0 && info->y_crop_offset + MCU_rows ==
+      full_height / info->iMCU_sample_height)
+    info->output_height = MCU_rows * info->iMCU_sample_height;
+}
+
+
+/* Request any required workspace.
+ *
+ * This routine figures out the size that the output image will be
+ * (which implies that all the transform parameters must be set before
+ * it is called).
+ *
+ * We allocate the workspace virtual arrays from the source decompression
+ * object, so that all the arrays (both the original data and the workspace)
+ * will be taken into account while making memory management decisions.
+ * Hence, this routine must be called after jpeg_read_header (which reads
+ * the image dimensions) and before jpeg_read_coefficients (which realizes
+ * the source's virtual arrays).
+ *
+ * This function returns FALSE right away if -perfect is given
+ * and transformation is not perfect.  Otherwise returns TRUE.
+ */
+
+GLOBAL(boolean)
+jtransform_request_workspace (j_decompress_ptr srcinfo,
+			      jpeg_transform_info *info)
+{
+  jvirt_barray_ptr *coef_arrays;
+  boolean need_workspace, transpose_it;
+  jpeg_component_info *compptr;
+  JDIMENSION xoffset, yoffset;
+  JDIMENSION width_in_iMCUs, height_in_iMCUs;
+  JDIMENSION width_in_blocks, height_in_blocks;
+  int ci, h_samp_factor, v_samp_factor;
+
+  /* Determine number of components in output image */
+  if (info->force_grayscale &&
+      srcinfo->jpeg_color_space == JCS_YCbCr &&
+      srcinfo->num_components == 3)
+    /* We'll only process the first component */
+    info->num_components = 1;
+  else
+    /* Process all the components */
+    info->num_components = srcinfo->num_components;
+
+  /* Compute output image dimensions and related values. */
+  jpeg_core_output_dimensions(srcinfo);
+
+  /* Return right away if -perfect is given and transformation is not perfect.
+   */
+  if (info->perfect) {
+    if (info->num_components == 1) {
+      if (!jtransform_perfect_transform(srcinfo->output_width,
+	  srcinfo->output_height,
+	  srcinfo->min_DCT_h_scaled_size,
+	  srcinfo->min_DCT_v_scaled_size,
+	  info->transform))
+	return FALSE;
+    } else {
+      if (!jtransform_perfect_transform(srcinfo->output_width,
+	  srcinfo->output_height,
+	  srcinfo->max_h_samp_factor * srcinfo->min_DCT_h_scaled_size,
+	  srcinfo->max_v_samp_factor * srcinfo->min_DCT_v_scaled_size,
+	  info->transform))
+	return FALSE;
+    }
+  }
+
+  /* If there is only one output component, force the iMCU size to be 1;
+   * else use the source iMCU size.  (This allows us to do the right thing
+   * when reducing color to grayscale, and also provides a handy way of
+   * cleaning up "funny" grayscale images whose sampling factors are not 1x1.)
+   */
+  switch (info->transform) {
+  case JXFORM_TRANSPOSE:
+  case JXFORM_TRANSVERSE:
+  case JXFORM_ROT_90:
+  case JXFORM_ROT_270:
+    info->output_width = srcinfo->output_height;
+    info->output_height = srcinfo->output_width;
+    if (info->num_components == 1) {
+      info->iMCU_sample_width = srcinfo->min_DCT_v_scaled_size;
+      info->iMCU_sample_height = srcinfo->min_DCT_h_scaled_size;
+    } else {
+      info->iMCU_sample_width =
+	srcinfo->max_v_samp_factor * srcinfo->min_DCT_v_scaled_size;
+      info->iMCU_sample_height =
+	srcinfo->max_h_samp_factor * srcinfo->min_DCT_h_scaled_size;
+    }
+    break;
+  default:
+    info->output_width = srcinfo->output_width;
+    info->output_height = srcinfo->output_height;
+    if (info->num_components == 1) {
+      info->iMCU_sample_width = srcinfo->min_DCT_h_scaled_size;
+      info->iMCU_sample_height = srcinfo->min_DCT_v_scaled_size;
+    } else {
+      info->iMCU_sample_width =
+	srcinfo->max_h_samp_factor * srcinfo->min_DCT_h_scaled_size;
+      info->iMCU_sample_height =
+	srcinfo->max_v_samp_factor * srcinfo->min_DCT_v_scaled_size;
+    }
+    break;
+  }
+
+  /* If cropping has been requested, compute the crop area's position and
+   * dimensions, ensuring that its upper left corner falls at an iMCU boundary.
+   */
+  if (info->crop) {
+    /* Insert default values for unset crop parameters */
+    if (info->crop_xoffset_set == JCROP_UNSET)
+      info->crop_xoffset = 0;	/* default to +0 */
+    if (info->crop_yoffset_set == JCROP_UNSET)
+      info->crop_yoffset = 0;	/* default to +0 */
+    if (info->crop_xoffset >= info->output_width ||
+	info->crop_yoffset >= info->output_height)
+      ERREXIT(srcinfo, JERR_BAD_CROP_SPEC);
+    if (info->crop_width_set == JCROP_UNSET)
+      info->crop_width = info->output_width - info->crop_xoffset;
+    if (info->crop_height_set == JCROP_UNSET)
+      info->crop_height = info->output_height - info->crop_yoffset;
+    /* Ensure parameters are valid */
+    if (info->crop_width <= 0 || info->crop_width > info->output_width ||
+	info->crop_height <= 0 || info->crop_height > info->output_height ||
+	info->crop_xoffset > info->output_width - info->crop_width ||
+	info->crop_yoffset > info->output_height - info->crop_height)
+      ERREXIT(srcinfo, JERR_BAD_CROP_SPEC);
+    /* Convert negative crop offsets into regular offsets */
+    if (info->crop_xoffset_set == JCROP_NEG)
+      xoffset = info->output_width - info->crop_width - info->crop_xoffset;
+    else
+      xoffset = info->crop_xoffset;
+    if (info->crop_yoffset_set == JCROP_NEG)
+      yoffset = info->output_height - info->crop_height - info->crop_yoffset;
+    else
+      yoffset = info->crop_yoffset;
+    /* Now adjust so that upper left corner falls at an iMCU boundary */
+    info->output_width =
+      info->crop_width + (xoffset % info->iMCU_sample_width);
+    info->output_height =
+      info->crop_height + (yoffset % info->iMCU_sample_height);
+    /* Save x/y offsets measured in iMCUs */
+    info->x_crop_offset = xoffset / info->iMCU_sample_width;
+    info->y_crop_offset = yoffset / info->iMCU_sample_height;
+  } else {
+    info->x_crop_offset = 0;
+    info->y_crop_offset = 0;
+  }
+
+  /* Figure out whether we need workspace arrays,
+   * and if so whether they are transposed relative to the source.
+   */
+  need_workspace = FALSE;
+  transpose_it = FALSE;
+  switch (info->transform) {
+  case JXFORM_NONE:
+    if (info->x_crop_offset != 0 || info->y_crop_offset != 0)
+      need_workspace = TRUE;
+    /* No workspace needed if neither cropping nor transforming */
+    break;
+  case JXFORM_FLIP_H:
+    if (info->trim)
+      trim_right_edge(info, srcinfo->output_width);
+    if (info->y_crop_offset != 0)
+      need_workspace = TRUE;
+    /* do_flip_h_no_crop doesn't need a workspace array */
+    break;
+  case JXFORM_FLIP_V:
+    if (info->trim)
+      trim_bottom_edge(info, srcinfo->output_height);
+    /* Need workspace arrays having same dimensions as source image. */
+    need_workspace = TRUE;
+    break;
+  case JXFORM_TRANSPOSE:
+    /* transpose does NOT have to trim anything */
+    /* Need workspace arrays having transposed dimensions. */
+    need_workspace = TRUE;
+    transpose_it = TRUE;
+    break;
+  case JXFORM_TRANSVERSE:
+    if (info->trim) {
+      trim_right_edge(info, srcinfo->output_height);
+      trim_bottom_edge(info, srcinfo->output_width);
+    }
+    /* Need workspace arrays having transposed dimensions. */
+    need_workspace = TRUE;
+    transpose_it = TRUE;
+    break;
+  case JXFORM_ROT_90:
+    if (info->trim)
+      trim_right_edge(info, srcinfo->output_height);
+    /* Need workspace arrays having transposed dimensions. */
+    need_workspace = TRUE;
+    transpose_it = TRUE;
+    break;
+  case JXFORM_ROT_180:
+    if (info->trim) {
+      trim_right_edge(info, srcinfo->output_width);
+      trim_bottom_edge(info, srcinfo->output_height);
+    }
+    /* Need workspace arrays having same dimensions as source image. */
+    need_workspace = TRUE;
+    break;
+  case JXFORM_ROT_270:
+    if (info->trim)
+      trim_bottom_edge(info, srcinfo->output_width);
+    /* Need workspace arrays having transposed dimensions. */
+    need_workspace = TRUE;
+    transpose_it = TRUE;
+    break;
+  }
+
+  /* Allocate workspace if needed.
+   * Note that we allocate arrays padded out to the next iMCU boundary,
+   * so that transform routines need not worry about missing edge blocks.
+   */
+  if (need_workspace) {
+    coef_arrays = (jvirt_barray_ptr *)
+      (*srcinfo->mem->alloc_small) ((j_common_ptr) srcinfo, JPOOL_IMAGE,
+		SIZEOF(jvirt_barray_ptr) * info->num_components);
+    width_in_iMCUs = (JDIMENSION)
+      jdiv_round_up((long) info->output_width,
+		    (long) info->iMCU_sample_width);
+    height_in_iMCUs = (JDIMENSION)
+      jdiv_round_up((long) info->output_height,
+		    (long) info->iMCU_sample_height);
+    for (ci = 0; ci < info->num_components; ci++) {
+      compptr = srcinfo->comp_info + ci;
+      if (info->num_components == 1) {
+	/* we're going to force samp factors to 1x1 in this case */
+	h_samp_factor = v_samp_factor = 1;
+      } else if (transpose_it) {
+	h_samp_factor = compptr->v_samp_factor;
+	v_samp_factor = compptr->h_samp_factor;
+      } else {
+	h_samp_factor = compptr->h_samp_factor;
+	v_samp_factor = compptr->v_samp_factor;
+      }
+      width_in_blocks = width_in_iMCUs * h_samp_factor;
+      height_in_blocks = height_in_iMCUs * v_samp_factor;
+      coef_arrays[ci] = (*srcinfo->mem->request_virt_barray)
+	((j_common_ptr) srcinfo, JPOOL_IMAGE, FALSE,
+	 width_in_blocks, height_in_blocks, (JDIMENSION) v_samp_factor);
+    }
+    info->workspace_coef_arrays = coef_arrays;
+  } else
+    info->workspace_coef_arrays = NULL;
+
+  return TRUE;
+}
+
+
+/* Transpose destination image parameters */
+
+LOCAL(void)
+transpose_critical_parameters (j_compress_ptr dstinfo)
+{
+  int tblno, i, j, ci, itemp;
+  jpeg_component_info *compptr;
+  JQUANT_TBL *qtblptr;
+  JDIMENSION jtemp;
+  UINT16 qtemp;
+
+  /* Transpose image dimensions */
+  jtemp = dstinfo->image_width;
+  dstinfo->image_width = dstinfo->image_height;
+  dstinfo->image_height = jtemp;
+  itemp = dstinfo->min_DCT_h_scaled_size;
+  dstinfo->min_DCT_h_scaled_size = dstinfo->min_DCT_v_scaled_size;
+  dstinfo->min_DCT_v_scaled_size = itemp;
+
+  /* Transpose sampling factors */
+  for (ci = 0; ci < dstinfo->num_components; ci++) {
+    compptr = dstinfo->comp_info + ci;
+    itemp = compptr->h_samp_factor;
+    compptr->h_samp_factor = compptr->v_samp_factor;
+    compptr->v_samp_factor = itemp;
+  }
+
+  /* Transpose quantization tables */
+  for (tblno = 0; tblno < NUM_QUANT_TBLS; tblno++) {
+    qtblptr = dstinfo->quant_tbl_ptrs[tblno];
+    if (qtblptr != NULL) {
+      for (i = 0; i < DCTSIZE; i++) {
+	for (j = 0; j < i; j++) {
+	  qtemp = qtblptr->quantval[i*DCTSIZE+j];
+	  qtblptr->quantval[i*DCTSIZE+j] = qtblptr->quantval[j*DCTSIZE+i];
+	  qtblptr->quantval[j*DCTSIZE+i] = qtemp;
+	}
+      }
+    }
+  }
+}
+
+
+/* Adjust Exif image parameters.
+ *
+ * We try to adjust the Tags ExifImageWidth and ExifImageHeight if possible.
+ */
+
+LOCAL(void)
+adjust_exif_parameters (JOCTET FAR * data, unsigned int length,
+			JDIMENSION new_width, JDIMENSION new_height)
+{
+  boolean is_motorola; /* Flag for byte order */
+  unsigned int number_of_tags, tagnum;
+  unsigned int firstoffset, offset;
+  JDIMENSION new_value;
+
+  if (length < 12) return; /* Length of an IFD entry */
+
+  /* Discover byte order */
+  if (GETJOCTET(data[0]) == 0x49 && GETJOCTET(data[1]) == 0x49)
+    is_motorola = FALSE;
+  else if (GETJOCTET(data[0]) == 0x4D && GETJOCTET(data[1]) == 0x4D)
+    is_motorola = TRUE;
+  else
+    return;
+
+  /* Check Tag Mark */
+  if (is_motorola) {
+    if (GETJOCTET(data[2]) != 0) return;
+    if (GETJOCTET(data[3]) != 0x2A) return;
+  } else {
+    if (GETJOCTET(data[3]) != 0) return;
+    if (GETJOCTET(data[2]) != 0x2A) return;
+  }
+
+  /* Get first IFD offset (offset to IFD0) */
+  if (is_motorola) {
+    if (GETJOCTET(data[4]) != 0) return;
+    if (GETJOCTET(data[5]) != 0) return;
+    firstoffset = GETJOCTET(data[6]);
+    firstoffset <<= 8;
+    firstoffset += GETJOCTET(data[7]);
+  } else {
+    if (GETJOCTET(data[7]) != 0) return;
+    if (GETJOCTET(data[6]) != 0) return;
+    firstoffset = GETJOCTET(data[5]);
+    firstoffset <<= 8;
+    firstoffset += GETJOCTET(data[4]);
+  }
+  if (firstoffset > length - 2) return; /* check end of data segment */
+
+  /* Get the number of directory entries contained in this IFD */
+  if (is_motorola) {
+    number_of_tags = GETJOCTET(data[firstoffset]);
+    number_of_tags <<= 8;
+    number_of_tags += GETJOCTET(data[firstoffset+1]);
+  } else {
+    number_of_tags = GETJOCTET(data[firstoffset+1]);
+    number_of_tags <<= 8;
+    number_of_tags += GETJOCTET(data[firstoffset]);
+  }
+  if (number_of_tags == 0) return;
+  firstoffset += 2;
+
+  /* Search for ExifSubIFD offset Tag in IFD0 */
+  for (;;) {
+    if (firstoffset > length - 12) return; /* check end of data segment */
+    /* Get Tag number */
+    if (is_motorola) {
+      tagnum = GETJOCTET(data[firstoffset]);
+      tagnum <<= 8;
+      tagnum += GETJOCTET(data[firstoffset+1]);
+    } else {
+      tagnum = GETJOCTET(data[firstoffset+1]);
+      tagnum <<= 8;
+      tagnum += GETJOCTET(data[firstoffset]);
+    }
+    if (tagnum == 0x8769) break; /* found ExifSubIFD offset Tag */
+    if (--number_of_tags == 0) return;
+    firstoffset += 12;
+  }
+
+  /* Get the ExifSubIFD offset */
+  if (is_motorola) {
+    if (GETJOCTET(data[firstoffset+8]) != 0) return;
+    if (GETJOCTET(data[firstoffset+9]) != 0) return;
+    offset = GETJOCTET(data[firstoffset+10]);
+    offset <<= 8;
+    offset += GETJOCTET(data[firstoffset+11]);
+  } else {
+    if (GETJOCTET(data[firstoffset+11]) != 0) return;
+    if (GETJOCTET(data[firstoffset+10]) != 0) return;
+    offset = GETJOCTET(data[firstoffset+9]);
+    offset <<= 8;
+    offset += GETJOCTET(data[firstoffset+8]);
+  }
+  if (offset > length - 2) return; /* check end of data segment */
+
+  /* Get the number of directory entries contained in this SubIFD */
+  if (is_motorola) {
+    number_of_tags = GETJOCTET(data[offset]);
+    number_of_tags <<= 8;
+    number_of_tags += GETJOCTET(data[offset+1]);
+  } else {
+    number_of_tags = GETJOCTET(data[offset+1]);
+    number_of_tags <<= 8;
+    number_of_tags += GETJOCTET(data[offset]);
+  }
+  if (number_of_tags < 2) return;
+  offset += 2;
+
+  /* Search for ExifImageWidth and ExifImageHeight Tags in this SubIFD */
+  do {
+    if (offset > length - 12) return; /* check end of data segment */
+    /* Get Tag number */
+    if (is_motorola) {
+      tagnum = GETJOCTET(data[offset]);
+      tagnum <<= 8;
+      tagnum += GETJOCTET(data[offset+1]);
+    } else {
+      tagnum = GETJOCTET(data[offset+1]);
+      tagnum <<= 8;
+      tagnum += GETJOCTET(data[offset]);
+    }
+    if (tagnum == 0xA002 || tagnum == 0xA003) {
+      if (tagnum == 0xA002)
+	new_value = new_width; /* ExifImageWidth Tag */
+      else
+	new_value = new_height; /* ExifImageHeight Tag */
+      if (is_motorola) {
+	data[offset+2] = 0; /* Format = unsigned long (4 octets) */
+	data[offset+3] = 4;
+	data[offset+4] = 0; /* Number Of Components = 1 */
+	data[offset+5] = 0;
+	data[offset+6] = 0;
+	data[offset+7] = 1;
+	data[offset+8] = 0;
+	data[offset+9] = 0;
+	data[offset+10] = (JOCTET)((new_value >> 8) & 0xFF);
+	data[offset+11] = (JOCTET)(new_value & 0xFF);
+      } else {
+	data[offset+2] = 4; /* Format = unsigned long (4 octets) */
+	data[offset+3] = 0;
+	data[offset+4] = 1; /* Number Of Components = 1 */
+	data[offset+5] = 0;
+	data[offset+6] = 0;
+	data[offset+7] = 0;
+	data[offset+8] = (JOCTET)(new_value & 0xFF);
+	data[offset+9] = (JOCTET)((new_value >> 8) & 0xFF);
+	data[offset+10] = 0;
+	data[offset+11] = 0;
+      }
+    }
+    offset += 12;
+  } while (--number_of_tags);
+}
+
+
+/* Adjust output image parameters as needed.
+ *
+ * This must be called after jpeg_copy_critical_parameters()
+ * and before jpeg_write_coefficients().
+ *
+ * The return value is the set of virtual coefficient arrays to be written
+ * (either the ones allocated by jtransform_request_workspace, or the
+ * original source data arrays).  The caller will need to pass this value
+ * to jpeg_write_coefficients().
+ */
+
+GLOBAL(jvirt_barray_ptr *)
+jtransform_adjust_parameters (j_decompress_ptr srcinfo,
+			      j_compress_ptr dstinfo,
+			      jvirt_barray_ptr *src_coef_arrays,
+			      jpeg_transform_info *info)
+{
+  /* If force-to-grayscale is requested, adjust destination parameters */
+  if (info->force_grayscale) {
+    /* First, ensure we have YCbCr or grayscale data, and that the source's
+     * Y channel is full resolution.  (No reasonable person would make Y
+     * be less than full resolution, so actually coping with that case
+     * isn't worth extra code space.  But we check it to avoid crashing.)
+     */
+    if (((dstinfo->jpeg_color_space == JCS_YCbCr &&
+	  dstinfo->num_components == 3) ||
+	 (dstinfo->jpeg_color_space == JCS_GRAYSCALE &&
+	  dstinfo->num_components == 1)) &&
+	srcinfo->comp_info[0].h_samp_factor == srcinfo->max_h_samp_factor &&
+	srcinfo->comp_info[0].v_samp_factor == srcinfo->max_v_samp_factor) {
+      /* We use jpeg_set_colorspace to make sure subsidiary settings get fixed
+       * properly.  Among other things, it sets the target h_samp_factor &
+       * v_samp_factor to 1, which typically won't match the source.
+       * We have to preserve the source's quantization table number, however.
+       */
+      int sv_quant_tbl_no = dstinfo->comp_info[0].quant_tbl_no;
+      jpeg_set_colorspace(dstinfo, JCS_GRAYSCALE);
+      dstinfo->comp_info[0].quant_tbl_no = sv_quant_tbl_no;
+    } else {
+      /* Sorry, can't do it */
+      ERREXIT(dstinfo, JERR_CONVERSION_NOTIMPL);
+    }
+  } else if (info->num_components == 1) {
+    /* For a single-component source, we force the destination sampling factors
+     * to 1x1, with or without force_grayscale.  This is useful because some
+     * decoders choke on grayscale images with other sampling factors.
+     */
+    dstinfo->comp_info[0].h_samp_factor = 1;
+    dstinfo->comp_info[0].v_samp_factor = 1;
+  }
+
+  /* Correct the destination's image dimensions as necessary
+   * for rotate/flip, resize, and crop operations.
+   */
+  dstinfo->jpeg_width = info->output_width;
+  dstinfo->jpeg_height = info->output_height;
+
+  /* Transpose destination image parameters */
+  switch (info->transform) {
+  case JXFORM_TRANSPOSE:
+  case JXFORM_TRANSVERSE:
+  case JXFORM_ROT_90:
+  case JXFORM_ROT_270:
+    transpose_critical_parameters(dstinfo);
+    break;
+  default:
+    break;
+  }
+
+  /* Adjust Exif properties */
+  if (srcinfo->marker_list != NULL &&
+      srcinfo->marker_list->marker == JPEG_APP0+1 &&
+      srcinfo->marker_list->data_length >= 6 &&
+      GETJOCTET(srcinfo->marker_list->data[0]) == 0x45 &&
+      GETJOCTET(srcinfo->marker_list->data[1]) == 0x78 &&
+      GETJOCTET(srcinfo->marker_list->data[2]) == 0x69 &&
+      GETJOCTET(srcinfo->marker_list->data[3]) == 0x66 &&
+      GETJOCTET(srcinfo->marker_list->data[4]) == 0 &&
+      GETJOCTET(srcinfo->marker_list->data[5]) == 0) {
+    /* Suppress output of JFIF marker */
+    dstinfo->write_JFIF_header = FALSE;
+    /* Adjust Exif image parameters */
+    if (dstinfo->jpeg_width != srcinfo->image_width ||
+	dstinfo->jpeg_height != srcinfo->image_height)
+      /* Align data segment to start of TIFF structure for parsing */
+      adjust_exif_parameters(srcinfo->marker_list->data + 6,
+	srcinfo->marker_list->data_length - 6,
+	dstinfo->jpeg_width, dstinfo->jpeg_height);
+  }
+
+  /* Return the appropriate output data set */
+  if (info->workspace_coef_arrays != NULL)
+    return info->workspace_coef_arrays;
+  return src_coef_arrays;
+}
+
+
+/* Execute the actual transformation, if any.
+ *
+ * This must be called *after* jpeg_write_coefficients, because it depends
+ * on jpeg_write_coefficients to have computed subsidiary values such as
+ * the per-component width and height fields in the destination object.
+ *
+ * Note that some transformations will modify the source data arrays!
+ */
+
+GLOBAL(void)
+jtransform_execute_transform (j_decompress_ptr srcinfo,
+			      j_compress_ptr dstinfo,
+			      jvirt_barray_ptr *src_coef_arrays,
+			      jpeg_transform_info *info)
+{
+  jvirt_barray_ptr *dst_coef_arrays = info->workspace_coef_arrays;
+
+  /* Note: conditions tested here should match those in switch statement
+   * in jtransform_request_workspace()
+   */
+  switch (info->transform) {
+  case JXFORM_NONE:
+    if (info->x_crop_offset != 0 || info->y_crop_offset != 0)
+      do_crop(srcinfo, dstinfo, info->x_crop_offset, info->y_crop_offset,
+	      src_coef_arrays, dst_coef_arrays);
+    break;
+  case JXFORM_FLIP_H:
+    if (info->y_crop_offset != 0)
+      do_flip_h(srcinfo, dstinfo, info->x_crop_offset, info->y_crop_offset,
+		src_coef_arrays, dst_coef_arrays);
+    else
+      do_flip_h_no_crop(srcinfo, dstinfo, info->x_crop_offset,
+			src_coef_arrays);
+    break;
+  case JXFORM_FLIP_V:
+    do_flip_v(srcinfo, dstinfo, info->x_crop_offset, info->y_crop_offset,
+	      src_coef_arrays, dst_coef_arrays);
+    break;
+  case JXFORM_TRANSPOSE:
+    do_transpose(srcinfo, dstinfo, info->x_crop_offset, info->y_crop_offset,
+		 src_coef_arrays, dst_coef_arrays);
+    break;
+  case JXFORM_TRANSVERSE:
+    do_transverse(srcinfo, dstinfo, info->x_crop_offset, info->y_crop_offset,
+		  src_coef_arrays, dst_coef_arrays);
+    break;
+  case JXFORM_ROT_90:
+    do_rot_90(srcinfo, dstinfo, info->x_crop_offset, info->y_crop_offset,
+	      src_coef_arrays, dst_coef_arrays);
+    break;
+  case JXFORM_ROT_180:
+    do_rot_180(srcinfo, dstinfo, info->x_crop_offset, info->y_crop_offset,
+	       src_coef_arrays, dst_coef_arrays);
+    break;
+  case JXFORM_ROT_270:
+    do_rot_270(srcinfo, dstinfo, info->x_crop_offset, info->y_crop_offset,
+	       src_coef_arrays, dst_coef_arrays);
+    break;
+  }
+}
+
+/* jtransform_perfect_transform
+ *
+ * Determine whether lossless transformation is perfectly
+ * possible for a specified image and transformation.
+ *
+ * Inputs:
+ *   image_width, image_height: source image dimensions.
+ *   MCU_width, MCU_height: pixel dimensions of MCU.
+ *   transform: transformation identifier.
+ * Parameter sources from initialized jpeg_struct
+ * (after reading source header):
+ *   image_width = cinfo.image_width
+ *   image_height = cinfo.image_height
+ *   MCU_width = cinfo.max_h_samp_factor * cinfo.block_size
+ *   MCU_height = cinfo.max_v_samp_factor * cinfo.block_size
+ * Result:
+ *   TRUE = perfect transformation possible
+ *   FALSE = perfect transformation not possible
+ *           (may use custom action then)
+ */
+
+GLOBAL(boolean)
+jtransform_perfect_transform(JDIMENSION image_width, JDIMENSION image_height,
+			     int MCU_width, int MCU_height,
+			     JXFORM_CODE transform)
+{
+  boolean result = TRUE; /* initialize TRUE */
+
+  switch (transform) {
+  case JXFORM_FLIP_H:
+  case JXFORM_ROT_270:
+    if (image_width % (JDIMENSION) MCU_width)
+      result = FALSE;
+    break;
+  case JXFORM_FLIP_V:
+  case JXFORM_ROT_90:
+    if (image_height % (JDIMENSION) MCU_height)
+      result = FALSE;
+    break;
+  case JXFORM_TRANSVERSE:
+  case JXFORM_ROT_180:
+    if (image_width % (JDIMENSION) MCU_width)
+      result = FALSE;
+    if (image_height % (JDIMENSION) MCU_height)
+      result = FALSE;
+    break;
+  default:
+    break;
+  }
+
+  return result;
+}
+
+#endif /* TRANSFORMS_SUPPORTED */
+
+
+/* Setup decompression object to save desired markers in memory.
+ * This must be called before jpeg_read_header() to have the desired effect.
+ */
+
+GLOBAL(void)
+jcopy_markers_setup (j_decompress_ptr srcinfo, JCOPY_OPTION option)
+{
+#ifdef SAVE_MARKERS_SUPPORTED
+  int m;
+
+  /* Save comments except under NONE option */
+  if (option != JCOPYOPT_NONE) {
+    jpeg_save_markers(srcinfo, JPEG_COM, 0xFFFF);
+  }
+  /* Save all types of APPn markers iff ALL option */
+  if (option == JCOPYOPT_ALL) {
+    for (m = 0; m < 16; m++)
+      jpeg_save_markers(srcinfo, JPEG_APP0 + m, 0xFFFF);
+  }
+#endif /* SAVE_MARKERS_SUPPORTED */
+}
+
+/* Copy markers saved in the given source object to the destination object.
+ * This should be called just after jpeg_start_compress() or
+ * jpeg_write_coefficients().
+ * Note that those routines will have written the SOI, and also the
+ * JFIF APP0 or Adobe APP14 markers if selected.
+ */
+
+GLOBAL(void)
+jcopy_markers_execute (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
+		       JCOPY_OPTION option)
+{
+  jpeg_saved_marker_ptr marker;
+
+  /* In the current implementation, we don't actually need to examine the
+   * option flag here; we just copy everything that got saved.
+   * But to avoid confusion, we do not output JFIF and Adobe APP14 markers
+   * if the encoder library already wrote one.
+   */
+  for (marker = srcinfo->marker_list; marker != NULL; marker = marker->next) {
+    if (dstinfo->write_JFIF_header &&
+	marker->marker == JPEG_APP0 &&
+	marker->data_length >= 5 &&
+	GETJOCTET(marker->data[0]) == 0x4A &&
+	GETJOCTET(marker->data[1]) == 0x46 &&
+	GETJOCTET(marker->data[2]) == 0x49 &&
+	GETJOCTET(marker->data[3]) == 0x46 &&
+	GETJOCTET(marker->data[4]) == 0)
+      continue;			/* reject duplicate JFIF */
+    if (dstinfo->write_Adobe_marker &&
+	marker->marker == JPEG_APP0+14 &&
+	marker->data_length >= 5 &&
+	GETJOCTET(marker->data[0]) == 0x41 &&
+	GETJOCTET(marker->data[1]) == 0x64 &&
+	GETJOCTET(marker->data[2]) == 0x6F &&
+	GETJOCTET(marker->data[3]) == 0x62 &&
+	GETJOCTET(marker->data[4]) == 0x65)
+      continue;			/* reject duplicate Adobe */
+#ifdef NEED_FAR_POINTERS
+    /* We could use jpeg_write_marker if the data weren't FAR... */
+    {
+      unsigned int i;
+      jpeg_write_m_header(dstinfo, marker->marker, marker->data_length);
+      for (i = 0; i < marker->data_length; i++)
+	jpeg_write_m_byte(dstinfo, marker->data[i]);
+    }
+#else
+    jpeg_write_marker(dstinfo, marker->marker,
+		      marker->data, marker->data_length);
+#endif
+  }
+}
diff --git a/lib/a2jpeg/transupp.h b/lib/a2jpeg/transupp.h
new file mode 100644
index 0000000..7c16c19
--- /dev/null
+++ b/lib/a2jpeg/transupp.h
@@ -0,0 +1,210 @@
+/*
+ * transupp.h
+ *
+ * Copyright (C) 1997-2009, Thomas G. Lane, Guido Vollbeding.
+ * This file is part of the Independent JPEG Group's software.
+ * For conditions of distribution and use, see the accompanying README file.
+ *
+ * This file contains declarations for image transformation routines and
+ * other utility code used by the jpegtran sample application.  These are
+ * NOT part of the core JPEG library.  But we keep these routines separate
+ * from jpegtran.c to ease the task of maintaining jpegtran-like programs
+ * that have other user interfaces.
+ *
+ * NOTE: all the routines declared here have very specific requirements
+ * about when they are to be executed during the reading and writing of the
+ * source and destination files.  See the comments in transupp.c, or see
+ * jpegtran.c for an example of correct usage.
+ */
+
+/* If you happen not to want the image transform support, disable it here */
+#ifndef TRANSFORMS_SUPPORTED
+#define TRANSFORMS_SUPPORTED 1		/* 0 disables transform code */
+#endif
+
+/*
+ * Although rotating and flipping data expressed as DCT coefficients is not
+ * hard, there is an asymmetry in the JPEG format specification for images
+ * whose dimensions aren't multiples of the iMCU size.  The right and bottom
+ * image edges are padded out to the next iMCU boundary with junk data; but
+ * no padding is possible at the top and left edges.  If we were to flip
+ * the whole image including the pad data, then pad garbage would become
+ * visible at the top and/or left, and real pixels would disappear into the
+ * pad margins --- perhaps permanently, since encoders & decoders may not
+ * bother to preserve DCT blocks that appear to be completely outside the
+ * nominal image area.  So, we have to exclude any partial iMCUs from the
+ * basic transformation.
+ *
+ * Transpose is the only transformation that can handle partial iMCUs at the
+ * right and bottom edges completely cleanly.  flip_h can flip partial iMCUs
+ * at the bottom, but leaves any partial iMCUs at the right edge untouched.
+ * Similarly flip_v leaves any partial iMCUs at the bottom edge untouched.
+ * The other transforms are defined as combinations of these basic transforms
+ * and process edge blocks in a way that preserves the equivalence.
+ *
+ * The "trim" option causes untransformable partial iMCUs to be dropped;
+ * this is not strictly lossless, but it usually gives the best-looking
+ * result for odd-size images.  Note that when this option is active,
+ * the expected mathematical equivalences between the transforms may not hold.
+ * (For example, -rot 270 -trim trims only the bottom edge, but -rot 90 -trim
+ * followed by -rot 180 -trim trims both edges.)
+ *
+ * We also offer a lossless-crop option, which discards data outside a given
+ * image region but losslessly preserves what is inside.  Like the rotate and
+ * flip transforms, lossless crop is restricted by the JPEG format: the upper
+ * left corner of the selected region must fall on an iMCU boundary.  If this
+ * does not hold for the given crop parameters, we silently move the upper left
+ * corner up and/or left to make it so, simultaneously increasing the region
+ * dimensions to keep the lower right crop corner unchanged.  (Thus, the
+ * output image covers at least the requested region, but may cover more.)
+ *
+ * We also provide a lossless-resize option, which is kind of a lossless-crop
+ * operation in the DCT coefficient block domain - it discards higher-order
+ * coefficients and losslessly preserves lower-order coefficients of a
+ * sub-block.
+ *
+ * Rotate/flip transform, resize, and crop can be requested together in a
+ * single invocation.  The crop is applied last --- that is, the crop region
+ * is specified in terms of the destination image after transform/resize.
+ *
+ * We also offer a "force to grayscale" option, which simply discards the
+ * chrominance channels of a YCbCr image.  This is lossless in the sense that
+ * the luminance channel is preserved exactly.  It's not the same kind of
+ * thing as the rotate/flip transformations, but it's convenient to handle it
+ * as part of this package, mainly because the transformation routines have to
+ * be aware of the option to know how many components to work on.
+ */
+
+
+/* Short forms of external names for systems with brain-damaged linkers. */
+
+#ifdef NEED_SHORT_EXTERNAL_NAMES
+#define jtransform_parse_crop_spec	jTrParCrop
+#define jtransform_request_workspace	jTrRequest
+#define jtransform_adjust_parameters	jTrAdjust
+#define jtransform_execute_transform	jTrExec
+#define jtransform_perfect_transform	jTrPerfect
+#define jcopy_markers_setup		jCMrkSetup
+#define jcopy_markers_execute		jCMrkExec
+#endif /* NEED_SHORT_EXTERNAL_NAMES */
+
+
+/*
+ * Codes for supported types of image transformations.
+ */
+
+typedef enum {
+	JXFORM_NONE,		/* no transformation */
+	JXFORM_FLIP_H,		/* horizontal flip */
+	JXFORM_FLIP_V,		/* vertical flip */
+	JXFORM_TRANSPOSE,	/* transpose across UL-to-LR axis */
+	JXFORM_TRANSVERSE,	/* transpose across UR-to-LL axis */
+	JXFORM_ROT_90,		/* 90-degree clockwise rotation */
+	JXFORM_ROT_180,		/* 180-degree rotation */
+	JXFORM_ROT_270		/* 270-degree clockwise (or 90 ccw) */
+} JXFORM_CODE;
+
+/*
+ * Codes for crop parameters, which can individually be unspecified,
+ * positive, or negative.  (Negative width or height makes no sense, though.)
+ */
+
+typedef enum {
+	JCROP_UNSET,
+	JCROP_POS,
+	JCROP_NEG
+} JCROP_CODE;
+
+/*
+ * Transform parameters struct.
+ * NB: application must not change any elements of this struct after
+ * calling jtransform_request_workspace.
+ */
+
+typedef struct {
+  /* Options: set by caller */
+  JXFORM_CODE transform;	/* image transform operator */
+  boolean perfect;		/* if TRUE, fail if partial MCUs are requested */
+  boolean trim;			/* if TRUE, trim partial MCUs as needed */
+  boolean force_grayscale;	/* if TRUE, convert color image to grayscale */
+  boolean crop;			/* if TRUE, crop source image */
+
+  /* Crop parameters: application need not set these unless crop is TRUE.
+   * These can be filled in by jtransform_parse_crop_spec().
+   */
+  JDIMENSION crop_width;	/* Width of selected region */
+  JCROP_CODE crop_width_set;
+  JDIMENSION crop_height;	/* Height of selected region */
+  JCROP_CODE crop_height_set;
+  JDIMENSION crop_xoffset;	/* X offset of selected region */
+  JCROP_CODE crop_xoffset_set;	/* (negative measures from right edge) */
+  JDIMENSION crop_yoffset;	/* Y offset of selected region */
+  JCROP_CODE crop_yoffset_set;	/* (negative measures from bottom edge) */
+
+  /* Internal workspace: caller should not touch these */
+  int num_components;		/* # of components in workspace */
+  jvirt_barray_ptr * workspace_coef_arrays; /* workspace for transformations */
+  JDIMENSION output_width;	/* cropped destination dimensions */
+  JDIMENSION output_height;
+  JDIMENSION x_crop_offset;	/* destination crop offsets measured in iMCUs */
+  JDIMENSION y_crop_offset;
+  int iMCU_sample_width;	/* destination iMCU size */
+  int iMCU_sample_height;
+} jpeg_transform_info;
+
+
+#if TRANSFORMS_SUPPORTED
+
+/* Parse a crop specification (written in X11 geometry style) */
+EXTERN(boolean) jtransform_parse_crop_spec
+	JPP((jpeg_transform_info *info, const char *spec));
+/* Request any required workspace */
+EXTERN(boolean) jtransform_request_workspace
+	JPP((j_decompress_ptr srcinfo, jpeg_transform_info *info));
+/* Adjust output image parameters */
+EXTERN(jvirt_barray_ptr *) jtransform_adjust_parameters
+	JPP((j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
+	     jvirt_barray_ptr *src_coef_arrays,
+	     jpeg_transform_info *info));
+/* Execute the actual transformation, if any */
+EXTERN(void) jtransform_execute_transform
+	JPP((j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
+	     jvirt_barray_ptr *src_coef_arrays,
+	     jpeg_transform_info *info));
+/* Determine whether lossless transformation is perfectly
+ * possible for a specified image and transformation.
+ */
+EXTERN(boolean) jtransform_perfect_transform
+	JPP((JDIMENSION image_width, JDIMENSION image_height,
+	     int MCU_width, int MCU_height,
+	     JXFORM_CODE transform));
+
+/* jtransform_execute_transform used to be called
+ * jtransform_execute_transformation, but some compilers complain about
+ * routine names that long.  This macro is here to avoid breaking any
+ * old source code that uses the original name...
+ */
+#define jtransform_execute_transformation	jtransform_execute_transform
+
+#endif /* TRANSFORMS_SUPPORTED */
+
+
+/*
+ * Support for copying optional markers from source to destination file.
+ */
+
+typedef enum {
+	JCOPYOPT_NONE,		/* copy no optional markers */
+	JCOPYOPT_COMMENTS,	/* copy only comment (COM) markers */
+	JCOPYOPT_ALL		/* copy all optional markers */
+} JCOPY_OPTION;
+
+#define JCOPYOPT_DEFAULT  JCOPYOPT_COMMENTS	/* recommended default */
+
+/* Setup decompression object to save desired markers in memory */
+EXTERN(void) jcopy_markers_setup
+	JPP((j_decompress_ptr srcinfo, JCOPY_OPTION option));
+/* Copy markers saved in the given source object to the destination object */
+EXTERN(void) jcopy_markers_execute
+	JPP((j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
+	     JCOPY_OPTION option));
diff --git a/lib/a2jpeg/write-jpeg.c b/lib/a2jpeg/write-jpeg.c
new file mode 100644
index 0000000..3336a24
--- /dev/null
+++ b/lib/a2jpeg/write-jpeg.c
@@ -0,0 +1,47 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <stddef.h>
+#include <string.h>
+#include <errno.h>
+#include <jpeglib.h>
+
+#include "readers.h"
+#include "writers.h"
+#include "misc.h"
+
+#include "write-jpeg.h"
+
+static int jpeg_quality = 75;
+
+int
+jpeg_write(FILE *fp, struct ida_image *img)
+{
+    struct jpeg_compress_struct cinfo;
+    struct jpeg_error_mgr jerr;
+    unsigned char *line;
+    unsigned int i;
+
+    cinfo.err = jpeg_std_error(&jerr);
+    jpeg_create_compress(&cinfo);
+    jpeg_stdio_dest(&cinfo, fp);
+    cinfo.image_width  = img->i.width;
+    cinfo.image_height = img->i.height;
+    if (img->i.dpi) {
+	cinfo.density_unit = 1;
+	cinfo.X_density = img->i.dpi;
+	cinfo.Y_density = img->i.dpi;
+    }
+    cinfo.input_components = 3;
+    cinfo.in_color_space = JCS_RGB;
+    jpeg_set_defaults(&cinfo);
+    jpeg_set_quality(&cinfo, jpeg_quality, TRUE);
+    jpeg_start_compress(&cinfo, TRUE);
+
+    for (i = 0, line = img->data; i < img->i.height; i++, line += img->i.width*3)
+        jpeg_write_scanlines(&cinfo, &line, 1);
+    
+    jpeg_finish_compress(&(cinfo));
+    jpeg_destroy_compress(&(cinfo));
+    return 0;
+}
+
diff --git a/lib/a2jpeg/write-jpeg.h b/lib/a2jpeg/write-jpeg.h
new file mode 100644
index 0000000..b774adc
--- /dev/null
+++ b/lib/a2jpeg/write-jpeg.h
@@ -0,0 +1,24 @@
+/* 
+ * File:   write-jpeg.h
+ * Author: noundou
+ *
+ * Created on January 30, 2011, 1:40 PM
+ */
+
+#ifndef WRITE_JPEG_H
+#define	WRITE_JPEG_H
+
+#ifdef	__cplusplus
+extern "C" {
+#endif
+
+
+int jpeg_write(FILE *fp, struct ida_image *img);
+
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* WRITE_JPEG_H */
+
diff --git a/lib/a2jpeg/writers.c b/lib/a2jpeg/writers.c
new file mode 100644
index 0000000..39e5387
--- /dev/null
+++ b/lib/a2jpeg/writers.c
@@ -0,0 +1,10 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "readers.h"
+#include "writers.h"
+
+/* ----------------------------------------------------------------------- */
+
+LIST_HEAD(writers);
diff --git a/lib/a2jpeg/writers.h b/lib/a2jpeg/writers.h
new file mode 100644
index 0000000..bd4a2b3
--- /dev/null
+++ b/lib/a2jpeg/writers.h
@@ -0,0 +1,14 @@
+#include "list.h"
+#include <X11/Intrinsic.h>
+
+/* save image files */
+struct ida_writer {
+    char  *label;
+    char  *ext[8];
+    int   (*write)(FILE *fp, struct ida_image *img);
+    int   (*conf)(Widget widget, struct ida_image *img);
+    struct list_head list;
+};
+
+extern struct list_head writers;
+void write_register(struct ida_writer *writer);
diff --git a/makefile b/makefile
new file mode 100644
index 0000000..c9ef88b
--- /dev/null
+++ b/makefile
@@ -0,0 +1,79 @@
+.PHONY: clean indent
+.SUFFIXES: .c .h .o .a
+
+OBJLIB_8B=lib/a2jpeg/transupp.o\
+       lib/a2jpeg/jpegtools.o\
+       lib/a2jpeg/readers.o\
+       lib/a2jpeg/op.o\
+       lib/a2jpeg/filter.o\
+       lib/a2jpeg/read-jpeg.o\
+       lib/a2jpeg/write-jpeg.o\
+       lib/a2jpeg/dither.o\
+       lib/a2jpeg/genthumbnail.o
+
+OBJLIB_6B=lib/a2jpeg-6b/transupp.o\
+       lib/a2jpeg-6b/jpegtools.o\
+       lib/a2jpeg-6b/readers.o\
+       lib/a2jpeg-6b/op.o\
+       lib/a2jpeg-6b/filter.o\
+       lib/a2jpeg-6b/read-jpeg.o\
+       lib/a2jpeg-6b/write-jpeg.o\
+       lib/a2jpeg-6b/dither.o\
+       lib/a2jpeg-6b/genthumbnail.o
+
+OBJLIB=$(OBJLIB_6B)
+OBJH=lib/a2jpeg-6b
+
+HEADERS=-I/usr/include/glib-2.0\
+	-I/usr/lib/glib-2.0/include\
+	-I/usr/include/libexif\
+        -I$(OBJH)
+
+SRC=src/jpegr.c
+
+CPPFLAGS=-Wall -c -g\
+	 $(HEADERS)
+
+LIBS=-L. -ljpega2 -lglib-2.0 -lexif -ljpeg 
+
+CC=gcc
+
+all: libjpega2 main
+
+main: $(SRC)
+	$(CC) $(CPPFLAGS) src/jpegr.c
+	$(CC) -o jpegr jpegr.o $(LIBS)
+
+jpeg-6b:
+	$(CC) -c -g -Ilib/a2jpeg-6b lib/a2jpeg-6b/transupp.c
+	$(CC) -c -g -Ilib/a2jpeg-6b $(HEADERS) lib/a2jpeg-6b/jpegtools.c
+	$(CC) -c -g -Ilib/a2jpeg-6b lib/a2jpeg-6b/readers.c
+	$(CC) -c -g -Ilib/a2jpeg-6b lib/a2jpeg-6b/filter.c
+	$(CC) -c -g -Ilib/a2jpeg-6b lib/a2jpeg-6b/op.c
+	$(CC) -c -g -Ilib/a2jpeg-6b lib/a2jpeg-6b/read-jpeg.c
+	$(CC) -c -g -Ilib/a2jpeg-6b lib/a2jpeg-6b/writers.c
+	$(CC) -c -g -Ilib/a2jpeg-6b lib/a2jpeg-6b/write-jpeg.c
+	$(CC) -c -g -Ilib/a2jpeg-6b lib/a2jpeg-6b/dither.c
+	$(CC) -c -g -Ilib/a2jpeg-6b $(HEADERS) lib/a2jpeg-6b/genthumbnail.c
+
+jpeg-8b:
+	$(CC) -c -g -Ilib/a2jpeg-8b lib/a2jpeg/transupp.c
+	$(CC) -c -g -Ilib/a2jpeg-8b $(HEADERS) lib/a2jpeg/jpegtools.c
+	$(CC) -c -g -Ilib/a2jpeg-8b lib/a2jpeg/readers.c
+	$(CC) -c -g -Ilib/a2jpeg-8b lib/a2jpeg/filter.c
+	$(CC) -c -g -Ilib/a2jpeg-8b lib/a2jpeg/op.c
+	$(CC) -c -g -Ilib/a2jpeg-8b lib/a2jpeg/read-jpeg.c
+	$(CC) -c -g -Ilib/a2jpeg-8b lib/a2jpeg/writers.c
+	$(CC) -c -g -Ilib/a2jpeg-8b lib/a2jpeg/write-jpeg.c
+	$(CC) -c -g -Ilib/a2jpeg-8b lib/a2jpeg/dither.c
+	$(CC) -c -g -Ilib/a2jpeg-8b $(HEADERS) lib/a2jpeg/genthumbnail.c
+
+libjpega2: jpeg-6b $(OBJLIB_6B)
+	$(AR) crsu libjpega2.a $(OBJLIB_6B)
+
+indent:
+	indent -br -nce -ncdw -brs -lp -ip5 -npsl -nbad -pcs -saf -sai -saw $S
+
+clean:
+	-rm *.o lib/a2jpeg-6b/*.o lib/a2jpeg/*.o
+	-rm libjpega2.a
diff --git a/src/a2jpeg/README b/src/a2jpeg/README
deleted file mode 100644
index 76e7464..0000000
--- a/src/a2jpeg/README
+++ /dev/null
@@ -1,2 +0,0 @@
-some source files copyed over from
-The Independent JPEG Group's JPEG software
diff --git a/src/a2jpeg/dither.c b/src/a2jpeg/dither.c
deleted file mode 100644
index 2eaeb31..0000000
--- a/src/a2jpeg/dither.c
+++ /dev/null
@@ -1,193 +0,0 @@
-/*
- * ordered dither rotines
- *
- * stolen from The GIMP and trimmed for speed
- *
- */
-
-#include <stdlib.h>
-#include "dither.h"
-
-#define DITHER_LEVEL 8
-
-void (*dither_line)(unsigned char *, unsigned char *, int, int);
-
-static long     red_mult, green_mult;
-static long     red_dither[256];
-static long     green_dither[256];
-static long     blue_dither[256];
-static long     gray_dither[256];
-
-typedef unsigned long vector[DITHER_LEVEL];
-typedef vector  matrix[DITHER_LEVEL];
-
-#if DITHER_LEVEL == 8
-#define DITHER_MASK 7
-static matrix   DM =
-{
-    {0, 32, 8, 40, 2, 34, 10, 42},
-    {48, 16, 56, 24, 50, 18, 58, 26},
-    {12, 44, 4, 36, 14, 46, 6, 38},
-    {60, 28, 52, 20, 62, 30, 54, 22},
-    {3, 35, 11, 43, 1, 33, 9, 41},
-    {51, 19, 59, 27, 49, 17, 57, 25},
-    {15, 47, 7, 39, 13, 45, 5, 37},
-    {63, 31, 55, 23, 61, 29, 53, 21}
-};
-
-#endif
-
-#if DITHER_LEVEL == 4
-#define DITHER_MASK 3
-static matrix   DM =
-{
-    {0, 8, 2, 10},
-    {12, 4, 14, 6},
-    {3, 11, 1, 9},
-    {15, 7, 13, 5}
-};
-
-#endif
-
-void
-init_dither(int shades_r, int shades_g, int shades_b, int shades_gray)
-{
-    int             i, j;
-    unsigned char   low_shade, high_shade;
-    unsigned short  index;
-    float           red_colors_per_shade;
-    float           green_colors_per_shade;
-    float           blue_colors_per_shade;
-    float           gray_colors_per_shade;
-
-    red_mult = shades_g * shades_b;
-    green_mult = shades_b;
-
-    red_colors_per_shade = 256.0 / (shades_r - 1);
-    green_colors_per_shade = 256.0 / (shades_g - 1);
-    blue_colors_per_shade = 256.0 / (shades_b - 1);
-    gray_colors_per_shade = 256.0 / (shades_gray - 1);
-
-    /* this avoids a shift when checking these values */
-    for (i = 0; i < DITHER_LEVEL; i++)
-	for (j = 0; j < DITHER_LEVEL; j++)
-	    DM[i][j] *= 0x10000;
-
-    /*  setup arrays containing three bytes of information for red, green, & blue  */
-    /*  the arrays contain :
-     *    1st byte:    low end shade value
-     *    2nd byte:    high end shade value
-     *    3rd & 4th bytes:    ordered dither matrix index
-     */
-
-    for (i = 0; i < 256; i++) {
-
-	/*  setup the red information  */
-	{
-	    low_shade = (unsigned char) (i / red_colors_per_shade);
-	    high_shade = low_shade + 1;
-
-	    index = (unsigned short)
-		(((i - low_shade * red_colors_per_shade) / red_colors_per_shade) *
-		 (DITHER_LEVEL * DITHER_LEVEL + 1));
-
-	    low_shade *= red_mult;
-	    high_shade *= red_mult;
-
-	    red_dither[i] = (index << 16) + (high_shade << 8) + (low_shade);
-	}
-
-	/*  setup the green information  */
-	{
-	    low_shade = (unsigned char) (i / green_colors_per_shade);
-	    high_shade = low_shade + 1;
-
-	    index = (unsigned short)
-		(((i - low_shade * green_colors_per_shade) / green_colors_per_shade) *
-		 (DITHER_LEVEL * DITHER_LEVEL + 1));
-
-	    low_shade *= green_mult;
-	    high_shade *= green_mult;
-
-	    green_dither[i] = (index << 16) + (high_shade << 8) + (low_shade);
-	}
-
-	/*  setup the blue information  */
-	{
-	    low_shade = (unsigned char) (i / blue_colors_per_shade);
-	    high_shade = low_shade + 1;
-
-	    index = (unsigned short)
-		(((i - low_shade * blue_colors_per_shade) / blue_colors_per_shade) *
-		 (DITHER_LEVEL * DITHER_LEVEL + 1));
-
-	    blue_dither[i] = (index << 16) + (high_shade << 8) + (low_shade);
-	}
-
-	/*  setup the gray information  */
-	{
-	    low_shade = (unsigned char) (i / gray_colors_per_shade);
-	    high_shade = low_shade + 1;
-
-	    index = (unsigned short)
-		(((i - low_shade * gray_colors_per_shade) / gray_colors_per_shade) *
-		 (DITHER_LEVEL * DITHER_LEVEL + 1));
-
-	    gray_dither[i] = (index << 16) + (high_shade << 8) + (low_shade);
-	}
-    }
-}
-
-void
-dither_line_color(unsigned char *src, unsigned char *dest, int y, int width)
-{
-    register long   a, b;
-    long           *ymod, xmod;
-
-    ymod = DM[y & DITHER_MASK];
-
-    while (width--) {
-	xmod = width & DITHER_MASK;
-
-	b = red_dither[*(src++)];
-	if (ymod[xmod] < b)
-	    b >>= 8;
-
-	a = green_dither[*(src++)];
-	if (ymod[xmod] < a)
-	    a >>= 8;
-	b += a;
-
-	a = blue_dither[*(src++)];
-	if (ymod[xmod] < a)
-	    a >>= 8;
-	b += a;
-
-	*(dest++) = b & 0xff;
-    }
-}
-
-void
-dither_line_gray(unsigned char *src, unsigned char *dest, int y, int width)
-{
-    long           *ymod, xmod;
-    register long   a,g;
-
-    ymod = DM[y & DITHER_MASK];
-
-    while (width--) {
-	xmod = width & DITHER_MASK;
-
-#if 1
-	g = (src[0]*3 + src[1]*6 + src[2]) / 10;
-	a = gray_dither[g];
-	src += 3;
-#else
-	a = gray_dither[*(src++)];
-#endif
-	if (ymod[xmod] < a)
-	    a >>= 8;
-
-	*(dest++) = a & 0xff;
-    }
-}
diff --git a/src/a2jpeg/dither.h b/src/a2jpeg/dither.h
deleted file mode 100644
index b209de6..0000000
--- a/src/a2jpeg/dither.h
+++ /dev/null
@@ -1,6 +0,0 @@
-
-extern void (*dither_line)(unsigned char *, unsigned char *, int, int);
-
-void init_dither(int, int, int, int);
-void dither_line_color(unsigned char *, unsigned char *, int, int);
-void dither_line_gray(unsigned char *, unsigned char *, int, int);
diff --git a/src/a2jpeg/filter.c b/src/a2jpeg/filter.c
deleted file mode 100644
index 283a1fa..0000000
--- a/src/a2jpeg/filter.c
+++ /dev/null
@@ -1,495 +0,0 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <math.h>
-#include <string.h>
-
-#include "readers.h"
-#include "filter.h"
-
-int debug = 0;
-
-/* ----------------------------------------------------------------------- */
-
-static void
-op_grayscale(struct ida_image *src, struct ida_rect *rect,
-	     unsigned char *dst, int line, void *data)
-{
-    unsigned char *scanline;
-    int i,g;
-
-    scanline = src->data + line * src->i.width * 3;
-    memcpy(dst,scanline,src->i.width * 3);
-    if (line < rect->y1 || line >= rect->y2)
-	return;
-    dst      += 3*rect->x1;
-    scanline += 3*rect->x1;
-    for (i = rect->x1; i < rect->x2; i++) {
-	g = (scanline[0]*30 + scanline[1]*59+scanline[2]*11)/100;
-	dst[0] = g;
-	dst[1] = g;
-	dst[2] = g;
-	scanline += 3;
-	dst += 3;
-    }
-}
-
-/* ----------------------------------------------------------------------- */
-
-struct op_3x3_handle {
-    struct op_3x3_parm filter;
-    int *linebuf;
-};
-
-static void*
-op_3x3_init(struct ida_image *src, struct ida_rect *rect,
-	    struct ida_image_info *i, void *parm)
-{
-    struct op_3x3_parm *args = parm;
-    struct op_3x3_handle *h;
-
-    h = malloc(sizeof(*h));
-    memcpy(&h->filter,args,sizeof(*args));
-    h->linebuf = malloc(sizeof(int)*3*(src->i.width));
-
-    *i = src->i;
-    return h;
-}
-
-static int inline
-op_3x3_calc_pixel(struct op_3x3_parm *p, unsigned char *s1,
-		  unsigned char *s2, unsigned char *s3)
-{
-    int val = 0;
-
-    val += p->f1[0] * s1[0];
-    val += p->f1[1] * s1[3];
-    val += p->f1[2] * s1[6];
-    val += p->f2[0] * s2[0];
-    val += p->f2[1] * s2[3];
-    val += p->f2[2] * s2[6];
-    val += p->f3[0] * s3[0];
-    val += p->f3[1] * s3[3];
-    val += p->f3[2] * s3[6];
-    if (p->mul && p->div)
-	val = val * p->mul / p->div;
-    val += p->add;
-    return val;
-}
-
-static void
-op_3x3_calc_line(struct ida_image *src, struct ida_rect *rect,
-		 int *dst, unsigned int line, struct op_3x3_parm *p)
-{
-    unsigned char b1[9],b2[9],b3[9];
-    unsigned char *s1,*s2,*s3;
-    unsigned int i,left,right;
-
-    s1 = src->data + (line-1) * src->i.width * 3;
-    s2 = src->data +  line    * src->i.width * 3;
-    s3 = src->data + (line+1) * src->i.width * 3;
-    if (0 == line)
-	s1 = src->data + line * src->i.width * 3;
-    if (src->i.height-1 == line)
-	s3 = src->data + line * src->i.width * 3;
-
-    left  = rect->x1;
-    right = rect->x2;
-    if (0 == left) {
-	/* left border special case: dup first col */
-	memcpy(b1,s1,3);
-	memcpy(b2,s2,3);
-	memcpy(b3,s3,3);
-	memcpy(b1+3,s1,6);
-	memcpy(b2+3,s2,6);
-	memcpy(b3+3,s3,6);
-	dst[0] = op_3x3_calc_pixel(p,b1,b2,b3);
-	dst[1] = op_3x3_calc_pixel(p,b1+1,b2+1,b3+1);
-	dst[2] = op_3x3_calc_pixel(p,b1+2,b2+2,b3+2);
-	left++;
-    }
-    if (src->i.width == right) {
-	/* right border */
-	memcpy(b1,s1+src->i.width*3-6,6);
-	memcpy(b2,s2+src->i.width*3-6,6);
-	memcpy(b3,s3+src->i.width*3-6,6);
-	memcpy(b1+3,s1+src->i.width*3-3,3);
-	memcpy(b2+3,s2+src->i.width*3-3,3);
-	memcpy(b3+3,s3+src->i.width*3-3,3);
-	dst[src->i.width*3-3] = op_3x3_calc_pixel(p,b1,b2,b3);
-	dst[src->i.width*3-2] = op_3x3_calc_pixel(p,b1+1,b2+1,b3+1);
-	dst[src->i.width*3-1] = op_3x3_calc_pixel(p,b1+2,b2+2,b3+2);
-	right--;
-    }
-    
-    dst += 3*left;
-    s1  += 3*(left-1);
-    s2  += 3*(left-1);
-    s3  += 3*(left-1);
-    for (i = left; i < right; i++) {
-	dst[0] = op_3x3_calc_pixel(p,s1++,s2++,s3++);
-	dst[1] = op_3x3_calc_pixel(p,s1++,s2++,s3++);
-	dst[2] = op_3x3_calc_pixel(p,s1++,s2++,s3++);
-	dst += 3;
-    }
-}
-
-static void
-op_3x3_clip_line(unsigned char *dst, int *src, int left, int right)
-{
-    int i,val;
-
-    src += left*3;
-    dst += left*3;
-    for (i = left*3; i < right*3; i++) {
-	val = *(src++);
-	if (val < 0)
-	    val = 0;
-	if (val > 255)
-	    val = 255;
-	*(dst++) = val;
-    }
-}
-
-static void
-op_3x3_work(struct ida_image *src, struct ida_rect *rect,
-	    unsigned char *dst, int line, void *data)
-{
-    struct op_3x3_handle *h = data;
-    unsigned char *scanline;
-
-    scanline = src->data + line * src->i.width * 3;
-    memcpy(dst,scanline,src->i.width * 3);
-    if (line < rect->y1 || line >= rect->y2)
-	return;
-
-    op_3x3_calc_line(src,rect,h->linebuf,line,&h->filter);
-    op_3x3_clip_line(dst,h->linebuf,rect->x1,rect->x2);
-}
-
-static void
-op_3x3_free(void *data)
-{
-    struct op_3x3_handle *h = data;
-
-    free(h->linebuf);
-    free(h);
-}
-	    
-/* ----------------------------------------------------------------------- */
-
-struct op_sharpe_handle {
-    int  factor;
-    int  *linebuf;
-};
-
-static void*
-op_sharpe_init(struct ida_image *src, struct ida_rect *rect,
-	       struct ida_image_info *i, void *parm)
-{
-    struct op_sharpe_parm *args = parm;
-    struct op_sharpe_handle *h;
-
-    h = malloc(sizeof(*h));
-    h->factor  = args->factor;
-    h->linebuf = malloc(sizeof(int)*3*(src->i.width));
-
-    *i = src->i;
-    return h;
-}
-
-static void
-op_sharpe_work(struct ida_image *src, struct ida_rect *rect,
-	       unsigned char *dst, int line, void *data)
-{
-    static struct op_3x3_parm laplace = {
-	f1: {  1,  1,  1 },
-	f2: {  1, -8,  1 },
-	f3: {  1,  1,  1 },
-    };
-    struct op_sharpe_handle *h = data;
-    unsigned char *scanline;
-    int i;
-
-    scanline = src->data + line * src->i.width * 3;
-    memcpy(dst,scanline,src->i.width * 3);
-    if (line < rect->y1 || line >= rect->y2)
-	return;
-
-    op_3x3_calc_line(src,rect,h->linebuf,line,&laplace);
-    for (i = rect->x1*3; i < rect->x2*3; i++)
-	h->linebuf[i] = scanline[i] - h->linebuf[i] * h->factor / 256;
-    op_3x3_clip_line(dst,h->linebuf,rect->x1,rect->x2);
-}
-
-static void
-op_sharpe_free(void *data)
-{
-    struct op_sharpe_handle *h = data;
-
-    free(h->linebuf);
-    free(h);
-}
-
-/* ----------------------------------------------------------------------- */
-
-struct op_resize_state {
-    float xscale,yscale,inleft;
-    float *rowbuf;
-    unsigned int width,height,srcrow;
-};
-
-static void*
-op_resize_init(struct ida_image *src, struct ida_rect *rect,
-	       struct ida_image_info *i, void *parm)
-{
-    struct op_resize_parm *args = parm;
-    struct op_resize_state *h;
-
-    h = malloc(sizeof(*h));
-    h->width  = args->width;
-    h->height = args->height;
-    h->xscale = (float)args->width/src->i.width;
-    h->yscale = (float)args->height/src->i.height;
-    h->rowbuf = malloc(src->i.width * 3 * sizeof(float));
-    h->srcrow = 0;
-    h->inleft = 1;
-
-    *i = src->i;
-    i->width  = args->width;
-    i->height = args->height;
-    i->dpi    = args->dpi;
-    return h;
-}
-
-static void
-op_resize_work(struct ida_image *src, struct ida_rect *rect,
-	       unsigned char *dst, int line, void *data)
-{
-    struct op_resize_state *h = data;
-    float outleft,left,weight,d0,d1,d2;
-    unsigned char *csrcline;
-    float *fsrcline;
-    unsigned int i,sx,dx;
-
-    /* scale y */
-    memset(h->rowbuf, 0, src->i.width * 3 * sizeof(float));
-    outleft = 1/h->yscale;
-    while (outleft > 0  &&  h->srcrow < src->i.height) {
-	if (outleft < h->inleft) {
-	    weight     = outleft * h->yscale;
-	    h->inleft -= outleft;
-	    outleft    = 0;
-	} else {
-	    weight     = h->inleft * h->yscale;
-	    outleft   -= h->inleft;
-	    h->inleft  = 0;
-	}
-#if 0
-	if (debug)
-	    fprintf(stderr,"y:  %6.2f%%: %d/%d => %d/%d\n",
-		    weight*100,h->srcrow,src->height,line,h->height);
-#endif
-	csrcline = src->data + h->srcrow * src->i.width * 3;
-	for (i = 0; i < src->i.width * 3; i++)
-	    h->rowbuf[i] += (float)csrcline[i] * weight;
-	if (0 == h->inleft) {
-	    h->inleft = 1;
-	    h->srcrow++;
-	}
-    }
-
-    /* scale x */
-    left = 1;
-    fsrcline = h->rowbuf;
-    for (sx = 0, dx = 0; dx < h->width; dx++) {
-	d0 = d1 = d2 = 0;
-	outleft = 1/h->xscale;
-	while (outleft > 0  &&  dx < h->width  &&  sx < src->i.width) {
-	    if (outleft < left) {
-		weight   = outleft * h->xscale;
-		left    -= outleft;
-		outleft  = 0;
-	    } else {
-		weight   = left * h->xscale;
-		outleft -= left;
-		left     = 0;
-	    }
-#if 0
-	    if (debug)
-		fprintf(stderr," x: %6.2f%%: %d/%d => %d/%d\n",
-			weight*100,sx,src->width,dx,h->width);
-#endif
-	    d0 += fsrcline[3*sx+0] * weight;
-	    d1 += fsrcline[3*sx+1] * weight;
-	    d2 += fsrcline[3*sx+2] * weight;
-	    if (0 == left) {
-		left = 1;
-		sx++;
-	    }
-	}
-	dst[0] = d0;
-	dst[1] = d1;
-	dst[2] = d2;
-	dst += 3;
-    }
-}
-
-static void
-op_resize_done(void *data)
-{
-    struct op_resize_state *h = data;
-
-    free(h->rowbuf);
-    free(h);
-}
-    
-/* ----------------------------------------------------------------------- */
-
-struct op_rotate_state {
-    float angle,sina,cosa;
-    struct ida_rect calc;
-    int cx,cy;
-};
-
-static void*
-op_rotate_init(struct ida_image *src, struct ida_rect *rect,
-	       struct ida_image_info *i, void *parm)
-{
-    struct op_rotate_parm *args = parm;
-    struct op_rotate_state *h;
-    float  diag;
-
-    h = malloc(sizeof(*h));
-    h->angle = args->angle * 2 * M_PI / 360;
-    h->sina  = sin(h->angle);
-    h->cosa  = cos(h->angle);
-    h->cx    = (rect->x2 - rect->x1) / 2 + rect->x1;
-    h->cy    = (rect->y2 - rect->y1) / 2 + rect->y1;
-
-    /* the area we have to process (worst case: 45°) */
-    diag     = sqrt((rect->x2 - rect->x1)*(rect->x2 - rect->x1) +
-		    (rect->y2 - rect->y1)*(rect->y2 - rect->y1))/2;
-    h->calc.x1 = h->cx - diag;
-    h->calc.x2 = h->cx + diag;
-    h->calc.y1 = h->cy - diag;
-    h->calc.y2 = h->cy + diag;
-    if (h->calc.x1 < 0)
-	h->calc.x1 = 0;
-    if (h->calc.x2 > src->i.width)
-	h->calc.x2 = src->i.width;
-    if (h->calc.y1 < 0)
-	h->calc.y1 = 0;
-    if (h->calc.y2 > src->i.height)
-	h->calc.y2 = src->i.height;
-
-    *i = src->i;
-    return h;
-}
-
-static inline
-unsigned char* op_rotate_getpixel(struct ida_image *src, struct ida_rect *rect,
-				  int sx, int sy, int dx, int dy)
-{
-    static unsigned char black[] = { 0, 0, 0};
-
-    if (sx < rect->x1 || sx >= rect->x2 ||
-	sy < rect->y1 || sy >= rect->y2) {
-	if (dx < rect->x1 || dx >= rect->x2 ||
-	    dy < rect->y1 || dy >= rect->y2)
-	    return src->data + dy * src->i.width * 3 + dx * 3;
-	return black;
-    }
-    return src->data + sy * src->i.width * 3 + sx * 3;
-}
-
-static void
-op_rotate_work(struct ida_image *src, struct ida_rect *rect,
-	       unsigned char *dst, int y, void *data)
-{
-    struct op_rotate_state *h = data;
-    unsigned char *pix;
-    float fx,fy,w;
-    int x,sx,sy;
-
-    pix = src->data + y * src->i.width * 3;
-    memcpy(dst,pix,src->i.width * 3);
-    if (y < h->calc.y1 || y >= h->calc.y2)
-	return;
-
-    dst += 3*h->calc.x1;
-    memset(dst, 0, (h->calc.x2-h->calc.x1) * 3);
-    for (x = h->calc.x1; x < h->calc.x2; x++, dst+=3) {
-	fx = h->cosa * (x - h->cx) - h->sina * (y - h->cy) + h->cx;
-	fy = h->sina * (x - h->cx) + h->cosa * (y - h->cy) + h->cy;
-	sx = (int)fx;
-	sy = (int)fy;
-	if (fx < 0)
-	    sx--;
-	if (fy < 0)
-	    sy--;
-	fx -= sx;
-	fy -= sy;
-
-	pix = op_rotate_getpixel(src,rect,sx,sy,x,y);
-	w = (1-fx) * (1-fy);
-	dst[0] += pix[0] * w;
-	dst[1] += pix[1] * w;
-	dst[2] += pix[2] * w;
-	pix = op_rotate_getpixel(src,rect,sx+1,sy,x,y);
-	w = fx * (1-fy);
-	dst[0] += pix[0] * w;
-	dst[1] += pix[1] * w;
-	dst[2] += pix[2] * w;
-	pix = op_rotate_getpixel(src,rect,sx,sy+1,x,y);
-	w = (1-fx) * fy;
-	dst[0] += pix[0] * w;
-	dst[1] += pix[1] * w;
-	dst[2] += pix[2] * w;
-	pix = op_rotate_getpixel(src,rect,sx+1,sy+1,x,y);
-	w = fx * fy;
-	dst[0] += pix[0] * w;
-	dst[1] += pix[1] * w;
-	dst[2] += pix[2] * w;
-    }
-}
-
-static void
-op_rotate_done(void *data)
-{
-    struct op_rotate_state *h = data;
-
-    free(h);
-}
-
-/* ----------------------------------------------------------------------- */
-
-struct ida_op desc_grayscale = {
-    name:  "grayscale",
-    init:  op_none_init,
-    work:  op_grayscale,
-    done:  op_none_done,
-};
-struct ida_op desc_3x3 = {
-    name:  "3x3",
-    init:  op_3x3_init,
-    work:  op_3x3_work,
-    done:  op_3x3_free,
-};
-struct ida_op desc_sharpe = {
-    name:  "sharpe",
-    init:  op_sharpe_init,
-    work:  op_sharpe_work,
-    done:  op_sharpe_free,
-};
-struct ida_op desc_resize = {
-    name:  "resize",
-    init:  op_resize_init,
-    work:  op_resize_work,
-    done:  op_resize_done,
-};
-struct ida_op desc_rotate = {
-    name:  "rotate",
-    init:  op_rotate_init,
-    work:  op_rotate_work,
-    done:  op_rotate_done,
-};
diff --git a/src/a2jpeg/filter.h b/src/a2jpeg/filter.h
deleted file mode 100644
index 37d67ee..0000000
--- a/src/a2jpeg/filter.h
+++ /dev/null
@@ -1,27 +0,0 @@
-
-struct op_3x3_parm {
-    int f1[3];
-    int f2[3];
-    int f3[3];
-    int mul,div,add;
-};
-
-struct op_sharpe_parm {
-    int factor;
-};
-
-struct op_resize_parm {
-    int width;
-    int height;
-    int dpi;
-};
-
-struct op_rotate_parm {
-    int angle;
-};
-
-extern struct ida_op desc_grayscale;
-extern struct ida_op desc_3x3;
-extern struct ida_op desc_sharpe;
-extern struct ida_op desc_resize;
-extern struct ida_op desc_rotate;
diff --git a/src/a2jpeg/genthumbnail.c b/src/a2jpeg/genthumbnail.c
deleted file mode 100644
index aabe64e..0000000
--- a/src/a2jpeg/genthumbnail.c
+++ /dev/null
@@ -1,295 +0,0 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <stddef.h>
-#include <unistd.h>
-#include <errno.h>
-#include <string.h>
-
-#include <jpeglib.h>
-//#include "transupp.h"		/* Support routines for jpegtran */
-#include "jpegtools.h"
-
-#include "misc.h"
-
-#include "readers.h"
-#include "filter.h"
-#include "genthumbnail.h"
-
-/* ---------------------------------------------------------------------- */
-
-struct ida_image*
-read_jpeg(char *filename)
-{
-    struct ida_image *img;
-    FILE *fp;
-    unsigned int y;
-    void *data;
-    
-    /* open file */
-    if (NULL == (fp = fopen(filename, "r"))) {
-	fprintf(stderr,"open %s: %s\n",filename,strerror(errno));
-	return NULL;
-    }
-
-    /* load image */
-    img = malloc(sizeof(*img));
-    memset(img,0,sizeof(*img));
-    data = jpeg_loader.init(fp,filename,0,&img->i,0);
-    if (NULL == data) {
-	fprintf(stderr,"loading %s [%s] FAILED\n",filename,jpeg_loader.name);
-	free(img);
-	return NULL;
-    }
-    img->data = malloc(img->i.width * img->i.height * 3);
-    for (y = 0; y < img->i.height; y++)
-  	jpeg_loader.read(img->data + img->i.width * 3 * y, y, data);
-    jpeg_loader.done(data);
-    return img;
-}
-
-
-/* ---------------------------------------------------------------------- */
-
-struct ida_image*
-a2_scale_thumbnail(struct ida_image *src, int scale_h, int scale_w)
-{
-    struct op_resize_parm p;
-    struct ida_rect  rect;
-    struct ida_image *dest;
-    void *data;
-    unsigned int y;
-    float xs,ys;
-
-    dest = malloc(sizeof(*dest));
-    memset(dest,0,sizeof(*dest));
-    memset(&rect,0,sizeof(rect));
-    memset(&p,0,sizeof(p));
-
-    p.width  = src->i.width  * scale_w;
-    p.height = src->i.height * scale_h;
-    p.dpi    = src->i.dpi;
-    if (0 == p.width)
-	p.width = 1;
-    if (0 == p.height)
-	p.height = 1;
-
-    data = desc_resize.init(src,&rect,&dest->i,&p);
-    dest->data = malloc(dest->i.width * dest->i.height * 3);
-    for (y = 0; y < dest->i.height; y++)
-	desc_resize.work(src,&rect,
-			 dest->data + 3 * dest->i.width * y,
-			 y, data);
-    desc_resize.done(data);
-    return dest;
-}
-
-/* ---------------------------------------------------------------------- */
-
-struct ida_image*
-scale_thumbnail(struct ida_image *src, int max)
-{
-    struct op_resize_parm p;
-    struct ida_rect  rect;
-    struct ida_image *dest;
-    void *data;
-    unsigned int y;
-    float xs,ys,scale;
-    
-    xs = (float)max / src->i.width;
-    ys = (float)max / src->i.height;
-    scale = (xs < ys) ? xs : ys;
-
-    float scale_w = (float)max / src->i.width;
-    float scale_h = (float)max / src->i.height;
-
-    dest = malloc(sizeof(*dest));
-    memset(dest,0,sizeof(*dest));
-    memset(&rect,0,sizeof(rect));
-    memset(&p,0,sizeof(p));
-    
-    p.width  = src->i.width  * scale_w;
-    p.height = src->i.height * scale_h;
-    p.dpi    = src->i.dpi;
-    if (0 == p.width)
-	p.width = 1;
-    if (0 == p.height)
-	p.height = 1;
-    
-    data = desc_resize.init(src,&rect,&dest->i,&p);
-    dest->data = malloc(dest->i.width * dest->i.height * 3);
-    for (y = 0; y < dest->i.height; y++)
-	desc_resize.work(src,&rect,
-			 dest->data + 3 * dest->i.width * y,
-			 y, data);
-    desc_resize.done(data);
-    return dest;
-}
-
-/* ---------------------------------------------------------------------- */
-
-struct ida_image*
-ece459_scale_thumbnail(struct ida_image *src, int max)
-{
-    struct op_resize_parm p;
-    struct ida_rect  rect;
-    struct ida_image *dest;
-    void *data;
-    unsigned int y;
-
-    float scale_w = (float)max / src->i.width;
-    float scale_h = (float)max / src->i.height;
-
-    dest = malloc(sizeof(*dest));
-    memset(dest,0,sizeof(*dest));
-    memset(&rect,0,sizeof(rect));
-    memset(&p,0,sizeof(p));
-
-    p.width  = src->i.width  * scale_w;
-    p.height = src->i.height * scale_h;
-    p.dpi    = src->i.dpi;
-    if (0 == p.width)
-	p.width = 1;
-    if (0 == p.height)
-	p.height = 1;
-
-    data = desc_resize.init(src,&rect,&dest->i,&p);
-    dest->data = malloc(dest->i.width * dest->i.height * 3);
-    for (y = 0; y < dest->i.height; y++)
-	desc_resize.work(src,&rect,
-			 dest->data + 3 * dest->i.width * y,
-			 y, data);
-    desc_resize.done(data);
-    return dest;
-}
-
-/* ---------------------------------------------------------------------- */
-
-struct thc {
-    struct jpeg_compress_struct dst;
-    struct jpeg_error_mgr err;
-    unsigned char *out;
-    int osize;
-};
-
-static void thc_dest_init(struct jpeg_compress_struct *cinfo)
-{
-    struct thc *h  = container_of(cinfo, struct thc, dst);
-    cinfo->dest->next_output_byte = h->out;
-    cinfo->dest->free_in_buffer   = h->osize;
-}
-
-static boolean thc_dest_flush(struct jpeg_compress_struct *cinfo)
-{
-    fprintf(stderr,"jpeg: panic: output buffer full\n");
-    exit(1);
-}
-
-static void thc_dest_term(struct jpeg_compress_struct *cinfo)
-{
-    struct thc *h  = container_of(cinfo, struct thc, dst);
-    h->osize -= cinfo->dest->free_in_buffer;
-}
-
-static struct jpeg_destination_mgr thumbnail_dst = {
-    .init_destination    = thc_dest_init,
-    .empty_output_buffer = thc_dest_flush,
-    .term_destination    = thc_dest_term,
-};
-
-int
-compress_thumbnail(struct ida_image *img, char *dest, int max)
-{
-    struct thc thc;
-    unsigned char *line;
-    unsigned int i;
-
-    memset(&thc,0,sizeof(thc));
-    thc.dst.err = jpeg_std_error(&thc.err);
-    jpeg_create_compress(&thc.dst);
-    thc.dst.dest = &thumbnail_dst;
-    thc.out = dest;
-    thc.osize = max;
-
-    thc.dst.image_width  = img->i.width;
-    thc.dst.image_height = img->i.height;
-    thc.dst.input_components = 3;
-    thc.dst.in_color_space = JCS_RGB;
-    jpeg_set_defaults(&thc.dst);
-    jpeg_start_compress(&thc.dst, TRUE);
-
-    for (i = 0, line = img->data; i < img->i.height; i++, line += img->i.width*3)
-        jpeg_write_scanlines(&thc.dst, &line, 1);
-    
-    jpeg_finish_compress(&(thc.dst));
-    jpeg_destroy_compress(&(thc.dst));
-
-    return thc.osize;
-}
-
-/* ---------------------------------------------------------------------- */
-
-int create_thumbnail(char *filename, unsigned char *dest, int max)
-{
-    struct ida_image *img,*thumb;
-    int size;
-
-    //fprintf(stderr,"%s: read ",filename);
-    img = read_jpeg(filename);
-    if (!img) {
-	fprintf(stderr,"FAILED\n");
-	return -1;
-    }
-    
-    //fprintf(stderr,"scale ");
-    thumb = scale_thumbnail(img,160);
-    if (!thumb) {
-	free(img->data);
-	free(img);
-	fprintf(stderr,"FAILED\n");
-	return -1;
-    }
-
-    //fprintf(stderr,"compress ");
-    size = compress_thumbnail(thumb,dest,max);
-
-    /* cleanup */
-    free(img->data);
-    free(img);
-    free(thumb->data);
-    free(thumb);
-    return size;
-}
-
-/* ---------------------------------------------------------------------- */
-
-#if 0
-
-#define THUMB_MAX 65536
-
-static int handle_image(char *filename)
-{
-    char *dest;
-    int size;
-
-    dest = malloc(THUMB_MAX);
-    size = create_thumbnail(filename,dest,THUMB_MAX);
-
-    fprintf(stderr,"transform ");
-    jpeg_transform_inplace(filename, JXFORM_NONE, NULL,
-			   dest, size, JFLAG_UPDATE_THUMBNAIL);
-
-    fprintf(stderr,"done\n");
-    return 0;
-}
-
-int main(int argc, char *argv[])
-{
-    int i;
-
-    for (i = 1; i < argc; i++)
-	handle_image(argv[i]);
-    return 0;
-}
-
-#endif
-
diff --git a/src/a2jpeg/genthumbnail.h b/src/a2jpeg/genthumbnail.h
deleted file mode 100644
index fa0c2ed..0000000
--- a/src/a2jpeg/genthumbnail.h
+++ /dev/null
@@ -1,11 +0,0 @@
-int create_thumbnail(char *filename, unsigned char *dest, int max);
-
-//Scale image to (max x max)
-struct ida_image* ece459_scale_thumbnail(struct ida_image *src, int max);
-
-struct ida_image* scale_thumbnail(struct ida_image *src, int max);
-
-int compress_thumbnail(struct ida_image *img, char *dest, int max);
-
-struct ida_image* read_jpeg(char *filename);
-
diff --git a/src/a2jpeg/ida.c b/src/a2jpeg/ida.c
deleted file mode 100644
index 65e1d0a..0000000
--- a/src/a2jpeg/ida.c
+++ /dev/null
@@ -1,1909 +0,0 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <errno.h>
-#include <signal.h>
-#include <locale.h>
-#include <langinfo.h>
-
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <sys/wait.h>
-
-#include <X11/Intrinsic.h>
-#include <X11/StringDefs.h>
-#include <Xm/Xm.h>
-#include <Xm/Primitive.h>
-#include <Xm/Label.h>
-#include <Xm/CascadeB.h>
-#include <Xm/PushB.h>
-#include <Xm/Separator.h>
-#include <Xm/RowColumn.h>
-#include <Xm/ScrolledW.h>
-#include <Xm/Protocols.h>
-#include <Xm/List.h>
-#include <Xm/Form.h>
-#include <Xm/MessageB.h>
-#include <Xm/SelectioB.h>
-#include <Xm/Scale.h>
-#include <Xm/Text.h>
-#include <Xm/FileSB.h>
-#include <Xm/ToggleB.h>
-#include <Xm/DrawingA.h>
-#include <Xm/Transfer.h>
-#include <Xm/TransferP.h>
-
-#include "RegEdit.h"
-#include "ida.h"
-#include "x11.h"
-#include "man.h"
-#include "readers.h"
-#include "writers.h"
-#include "viewer.h"
-#include "op.h"
-#include "lut.h"
-#include "filter.h"
-#include "color.h"
-#include "icons.h"
-#include "browser.h"
-#include "filelist.h"
-#include "xdnd.h"
-#include "selections.h"
-#include "sane.h"
-#include "curl.h"
-#include "idaconfig.h"
-
-/* ---------------------------------------------------------------------- */
-
-static void popup_ac(Widget, XEvent*, String*, Cardinal*);
-static void exit_ac(Widget, XEvent*, String*, Cardinal*);
-static void next_ac(Widget, XEvent*, String*, Cardinal*);
-static void prev_ac(Widget, XEvent*, String*, Cardinal*);
-static void next_page_ac(Widget, XEvent*, String*, Cardinal*);
-static void prev_page_ac(Widget, XEvent*, String*, Cardinal*);
-static void zoom_ac(Widget, XEvent*, String*, Cardinal*);
-static void scroll_ac(Widget, XEvent*, String*, Cardinal*);
-static void debug_ac(Widget, XEvent*, String*, Cardinal*);
-static void load_ac(Widget, XEvent*, String*, Cardinal*);
-static void save_ac(Widget, XEvent*, String*, Cardinal*);
-static void scan_ac(Widget, XEvent*, String*, Cardinal*);
-static void print_ac(Widget, XEvent*, String*, Cardinal*);
-
-static void undo_ac(Widget, XEvent*, String*, Cardinal*);
-static void filter_ac(Widget, XEvent*, String*, Cardinal*);
-static void gamma_ac(Widget, XEvent*, String*, Cardinal*);
-static void bright_ac(Widget, XEvent*, String*, Cardinal*);
-static void contrast_ac(Widget, XEvent*, String*, Cardinal*);
-static void color_ac(Widget, XEvent*, String*, Cardinal*);
-static void f3x3_ac(Widget, XEvent*, String*, Cardinal*);
-static void resize_ac(Widget, XEvent*, String*, Cardinal*);
-static void rotate_ac(Widget, XEvent*, String*, Cardinal*);
-static void sharpe_ac(Widget, XEvent*, String*, Cardinal*);
-
-static XtActionsRec actionTable[] = {
-    { "Exit",     exit_ac      },
-    { "Next",     next_ac      },
-    { "Prev",     prev_ac      },
-    { "NextPage", next_page_ac },
-    { "PrevPage", prev_page_ac },
-    { "Zoom",     zoom_ac      },
-    { "Scroll",   scroll_ac    },
-    { "Debug",    debug_ac     },
-    { "Popup",    popup_ac     },
-    { "Man",      man_action   },
-    { "Load",     load_ac      },
-    { "Save",     save_ac      },
-    { "Scan",     scan_ac      },
-    { "Print",    print_ac     },
-    { "Browser",  browser_ac   },
-    { "Filelist", filelist_ac  },
-
-    { "Undo",     undo_ac      },
-    { "Filter",   filter_ac    },
-    { "Gamma",    gamma_ac     },
-    { "Bright",   bright_ac    },
-    { "Contrast", contrast_ac  },
-    { "Color",    color_ac     },
-    { "F3x3",     f3x3_ac      },
-    { "Resize",   resize_ac    },
-    { "Rotate",   rotate_ac    },
-    { "Sharpe",   sharpe_ac    },
-
-    { "Ipc",      ipc_ac       },
-    { "Xdnd",     XdndAction   },
-};
-
-/* ---------------------------------------------------------------------- */
-
-XtAppContext       app_context;
-Display            *dpy;
-Widget             app_shell;
-int                gray=0;
-char               *binary;
-struct ida_viewer  *ida;
-
-/* ---------------------------------------------------------------------- */
-
-struct ARGS args;
-unsigned int pcd_res;
-unsigned int sane_res;
-
-XtResource args_desc[] = {
-    {
-	"debug",
-	XtCBoolean, XtRBoolean, sizeof(Boolean),
-	XtOffset(struct ARGS*,debug),
-	XtRString, "false"
-    },{
-	"help",
-	XtCBoolean, XtRBoolean, sizeof(Boolean),
-	XtOffset(struct ARGS*,help),
-	XtRString, "false"
-    },{
-	"testload",
-	XtCBoolean, XtRBoolean, sizeof(Boolean),
-	XtOffset(struct ARGS*,testload),
-	XtRString, "false"
-    }
-};
-const int args_count = XtNumber(args_desc);
-
-XrmOptionDescRec opt_desc[] = {
-    { "-d",          "debug",       XrmoptionNoArg,  "true" },
-    { "-debug",      "debug",       XrmoptionNoArg,  "true" },
-    { "-testload",   "testload",    XrmoptionNoArg,  "true" },
-    { "-h",          "help",        XrmoptionNoArg,  "true" },
-    { "-help",       "help",        XrmoptionNoArg,  "true" },
-    { "--help",      "help",        XrmoptionNoArg,  "true" },
-};
-const int opt_count = (sizeof(opt_desc)/sizeof(XrmOptionDescRec));
-
-static String fallback_ressources[] = {
-#include "Ida.ad.h"
-    NULL
-};
-
-/* ---------------------------------------------------------------------- */
-
-static struct ida_writer *cwriter;
-static char *save_filename;
-static char *print_command;
-
-static Widget control_shell,status;
-static Atom   wm_delete_window;
-
-static Widget view,loadbox,savebox,printbox;
-
-/* file list */
-static Widget wlist;
-static char **files = NULL;
-static int  cfile   = -1;
-static int  nfiles  = 0;
-static int  cpage   = 0;
-static int  npages  = 1;
-
-/* filter controls */
-static int gamma_val    = 100;
-static int bright_val   = 0;
-static int contrast_val = 0;
-static int rotate_val   = 0;
-static int sharpe_val   = 10;
-
-static struct MY_TOPLEVELS {
-    char        *name;
-    Widget      *shell;
-    int         mapped;
-} my_toplevels [] = {
-    { "control",   &control_shell },
-};
-#define TOPLEVELS (sizeof(my_toplevels)/sizeof(struct MY_TOPLEVELS))
-
-/* ---------------------------------------------------------------------- */
-
-static void
-popup_ac(Widget widget, XEvent *event,
-	 String *params, Cardinal *num_params)
-{
-    unsigned int i;
-
-    /* which window we are talking about ? */
-    if (*num_params > 0) {
-	for (i = 0; i < TOPLEVELS; i++) {
-	    if (0 == strcasecmp(my_toplevels[i].name,params[0]))
-		break;
-	}
-	if (i == TOPLEVELS) {
-	    fprintf(stderr,"PopupAction: oops: shell not found (name=%s)\n",
-		    params[0]);
-	    return;
-	}
-    } else {
-	for (i = 0; i < TOPLEVELS; i++) {
-	    if (*(my_toplevels[i].shell) == widget)
-		break;
-	}
-	if (i == TOPLEVELS) {
-	    fprintf(stderr,"PopupAction: oops: shell not found (%p:%s)\n",
-		    widget,XtName(widget));
-	    return;
-	}
-    }
-
-    /* popup/down window */
-    if (!my_toplevels[i].mapped) {
-	XtPopup(*(my_toplevels[i].shell), XtGrabNone);
-	my_toplevels[i].mapped = 1;
-    } else {
-	XtPopdown(*(my_toplevels[i].shell));
-	my_toplevels[i].mapped = 0;
-    }
-}
-
-static void
-popupdown_cb(Widget widget, XtPointer clientdata, XtPointer call_data)
-{
-    int i = 0;
-    popup_ac(clientdata, NULL, NULL, &i);
-}
-
-/* ---------------------------------------------------------------------- */
-
-void
-destroy_cb(Widget widget, XtPointer clientdata, XtPointer call_data)
-{
-    XtDestroyWidget(clientdata);
-}
-
-void
-action_cb(Widget widget, XtPointer clientdata, XtPointer call_data)
-{
-    char *calls, *action, *argv[16]; /* max: F3x3(9 args) */
-    int argc;
-
-    calls = strdup(clientdata);
-    action = strtok(calls,"(),");
-    for (argc = 0; NULL != (argv[argc] = strtok(NULL,"(),")); argc++)
-	/* nothing */;
-    XtCallActionProc(widget,action,NULL,argv,argc);
-    free(calls);
-}
-
-static void
-about_cb(Widget widget, XtPointer clientdata, XtPointer call_data)
-{
-    Widget msgbox;
-    
-    msgbox = XmCreateInformationDialog(app_shell,"aboutbox",NULL,0);
-    XtUnmanageChild(XmMessageBoxGetChild(msgbox,XmDIALOG_HELP_BUTTON));
-    XtUnmanageChild(XmMessageBoxGetChild(msgbox,XmDIALOG_CANCEL_BUTTON));
-    XtAddCallback(msgbox,XmNokCallback,destroy_cb,msgbox);
-    XtManageChild(msgbox);
-}
-
-#if 0
-static void
-sorry_cb(Widget widget, XtPointer clientdata, XtPointer call_data)
-{
-    Widget msgbox;
-    
-    msgbox = XmCreateErrorDialog(app_shell,"sorrybox",NULL,0);
-    XtUnmanageChild(XmMessageBoxGetChild(msgbox,XmDIALOG_HELP_BUTTON));
-    XtUnmanageChild(XmMessageBoxGetChild(msgbox,XmDIALOG_CANCEL_BUTTON));
-    XtAddCallback(msgbox,XmNokCallback,destroy_cb,msgbox);
-    XtManageChild(msgbox);
-}
-#endif
-
-void
-debug_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
-{
-    unsigned int i;
-
-    fprintf(stderr,"Debug:");
-    for (i = 0; i < *num; i++)
-	fprintf(stderr," %s",params[i]);
-    fprintf(stderr,"\n");
-}
-
-static void
-display_cb(Widget widget, XtPointer clientdata, XtPointer call_data)
-{
-    XmDisplayCallbackStruct *arg = call_data;
-    
-    switch (arg->reason) {
-    case XmCR_NO_RENDITION:
-	fprintf(stderr,"display_cb: no rendition: \"%s\"\n",arg->tag);
-	break;
-    case XmCR_NO_FONT:
-	fprintf(stderr,"display_cb: no font: \"%s\"\n",arg->font_name);
-	break;
-    default:
-	/* should not happen */
-	fprintf(stderr,"display_cb: unknown reason [%d]\n",arg->reason);
-	break;
-    }
-}
-
-/* ---------------------------------------------------------------------- */
-
-struct ptr_list {
-    struct ptr_list *next;
-    Widget widget;
-};
-struct ptr_list *ptr_head;
-
-void ptr_register(Widget widget)
-{
-    struct ptr_list *item;
-
-    if (XtWindow(widget))
-	XDefineCursor(XtDisplay(widget), XtWindow(widget),
-		      ptrs[POINTER_NORMAL]);
-    item = malloc(sizeof(*item));
-    memset(item,0,sizeof(*item));
-    item->widget = widget;
-    item->next = ptr_head;
-    ptr_head = item;
-}
-
-void ptr_unregister(Widget widget)
-{
-    struct ptr_list *item,*fitem;
-
-    if (ptr_head->widget == widget) {
-	fitem = ptr_head;
-	ptr_head = ptr_head->next;
-	free(fitem);
-	return;
-    }
-    for (item = ptr_head; NULL != item->next; item = item->next) {
-	if (item->next->widget == widget) {
-	    fitem = item->next;
-	    item->next = fitem->next;
-	    free(fitem);
-	    return;
-	}
-    }
-    /* shouldn't happen */
-    fprintf(stderr,"Oops: widget not found in list\n");
-}
-
-void ptr_busy(void)
-{
-    struct ptr_list *item;
-
-    for (item = ptr_head; NULL != item; item = item->next) {
-	if (!XtWindow(item->widget))
-	    continue;
-	XDefineCursor(XtDisplay(item->widget), XtWindow(item->widget),
-		      ptrs[POINTER_BUSY]);
-    }
-    XSync(dpy,False);
-}
-
-void ptr_idle(void)
-{
-    struct ptr_list *item;
-
-    for (item = ptr_head; NULL != item; item = item->next) {
-	if (!XtWindow(item->widget))
-	    continue;
-	XDefineCursor(XtDisplay(item->widget), XtWindow(item->widget),
-		      ptrs[POINTER_NORMAL]);
-    }
-}
-
-/* ---------------------------------------------------------------------- */
-
-static Boolean
-exit_wp(XtPointer client_data)
-{
-    exit(0);
-}
-
-static void
-exit_cb(Widget widget, XtPointer client_data, XtPointer calldata)
-{
-    XtAppAddWorkProc(app_context,exit_wp, NULL);
-    XtDestroyWidget(app_shell);
-}
-
-void
-exit_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
-{
-    exit_cb(widget,NULL,NULL);
-}
-
-/* ---------------------------------------------------------------------- */
-
-static void
-list_update(void)
-{
-    XmStringTable tab;
-    int i;
-
-    tab = malloc(nfiles * sizeof(XmString));
-    for (i = 0; i < nfiles; i++)
-	tab[i] = XmStringGenerate(files[i], NULL, XmMULTIBYTE_TEXT, NULL);
-    XtVaSetValues(wlist,
-		  XmNitems, tab,
-		  XmNitemCount, nfiles,
-		  NULL);
-    for (i = 0; i < nfiles; i++)
-	XmStringFree(tab[i]);
-    free(tab);
-}
-
-static int
-list_append(char *filename)
-{
-    int i;
-
-    for (i = 0; i < nfiles; i++)
-	if (0 == strcmp(files[i],filename))
-	    return i;
-    files = realloc(files,sizeof(char*)*(nfiles+1));
-    files[nfiles] = strdup(filename);
-    nfiles++;
-    return nfiles-1;
-}
-
-static void
-list_cb(Widget widget, XtPointer client_data, XtPointer calldata)
-{
-    XmListCallbackStruct *list = calldata;
-
-    if (0 == list->selected_item_count)
-	return;
-    cfile = list->selected_item_positions[0]-1;
-    cpage = 0;
-    npages = viewer_loadimage(ida,files[cfile],cpage);
-    if (-1 == npages)
-	return;
-    resize_shell();
-}
-
-static void
-pcd_set(Widget widget)
-{
-    WidgetList items;
-    Cardinal nitems;
-    unsigned int i;
-    int value;
-
-    value = GET_PHOTOCD_RES();
-    XtVaGetValues(widget,XtNchildren,&items,
-		  XtNnumChildren,&nitems,NULL);
-    for (i = 0; i < nitems; i++)
-	XmToggleButtonSetState(items[i],value == i+1,False);
-    pcd_res      = value;
-}
-
-static void
-pcd_cb(Widget widget, XtPointer client_data, XtPointer calldata)
-{
-    cfg_set_int(O_PHOTOCD_RES,(intptr_t)client_data);
-    pcd_set(XtParent(widget));
-}
-
-static void
-cfg_bool_cb(Widget widget, XtPointer client_data, XtPointer calldata)
-{
-    char *option = XtName(widget);
-    Boolean value = XmToggleButtonGetState(widget);
-    cfg_set_bool(O_OPTIONS, option, value);
-}
-
-static void
-cfg_save_cb(Widget widget, XtPointer client_data, XtPointer calldata)
-{
-    ida_write_config();
-}
-
-static void
-create_control(void)
-{
-    Widget form,menubar,tool,menu,smenu,push;
-
-    control_shell = XtVaAppCreateShell("ctrl","Iv",
-				       topLevelShellWidgetClass,
-				       dpy,
-				       XtNclientLeader,app_shell,
-				       XmNdeleteResponse,XmDO_NOTHING,
-				       NULL);
-    XmdRegisterEditres(control_shell);
-    XmAddWMProtocolCallback(control_shell,wm_delete_window,
-			    popupdown_cb,control_shell);
-
-    /* widgets */
-    form = XtVaCreateManagedWidget("form", xmFormWidgetClass, control_shell,
-				   NULL);
-    menubar = XmCreateMenuBar(form,"bar",NULL,0);
-    XtManageChild(menubar);
-    tool = XtVaCreateManagedWidget("tool",xmRowColumnWidgetClass, form,
-				   NULL);
-    status = XtVaCreateManagedWidget("status", xmLabelWidgetClass, form,
-				     NULL);
-    wlist = XmCreateScrolledList(form,"list",NULL,0);
-    XtManageChild(wlist);
-    XtAddCallback(wlist,XmNdefaultActionCallback,list_cb,NULL);
-    XtAddCallback(wlist,XmNdestinationCallback,selection_dest,NULL);
-    dnd_add(wlist);
-    
-    /* menu - file */
-    menu = XmCreatePulldownMenu(menubar,"fileM",NULL,0);
-    XtVaCreateManagedWidget("file",xmCascadeButtonWidgetClass,menubar,
-			    XmNsubMenuId,menu,NULL);
-    push = XtVaCreateManagedWidget("load",xmPushButtonWidgetClass,menu,NULL);
-    XtAddCallback(push,XmNactivateCallback,action_cb,"Load()");
-    push = XtVaCreateManagedWidget("save",xmPushButtonWidgetClass,menu,NULL);
-    XtAddCallback(push,XmNactivateCallback,action_cb,"Save()");
-    push = XtVaCreateManagedWidget("browse",xmPushButtonWidgetClass,menu,NULL);
-    XtAddCallback(push,XmNactivateCallback,action_cb,"Browser()");
-    push = XtVaCreateManagedWidget("filelist",xmPushButtonWidgetClass,menu,NULL);
-    XtAddCallback(push,XmNactivateCallback,action_cb,"Filelist()");
-    XtVaCreateManagedWidget("sep",xmSeparatorWidgetClass,menu,NULL);
-#ifdef HAVE_LIBSANE
-    sane_menu(menu);
-#endif
-    push = XtVaCreateManagedWidget("print",xmPushButtonWidgetClass,menu,NULL);
-    XtAddCallback(push,XmNactivateCallback,action_cb,"Print()");
-    XtVaCreateManagedWidget("sep",xmSeparatorWidgetClass,menu,NULL);
-    push = XtVaCreateManagedWidget("quit",xmPushButtonWidgetClass,menu,NULL);
-    XtAddCallback(push,XmNactivateCallback,exit_cb,NULL);
-
-    /* menu - edit */
-    menu = XmCreatePulldownMenu(menubar,"editM",NULL,0);
-    XtVaCreateManagedWidget("edit",xmCascadeButtonWidgetClass,menubar,
-			    XmNsubMenuId,menu,NULL);
-    push = XtVaCreateManagedWidget("undo",xmPushButtonWidgetClass,menu,NULL);
-    XtAddCallback(push,XmNactivateCallback,action_cb,"Undo()");
-    XtVaCreateManagedWidget("sep",xmSeparatorWidgetClass,menu,NULL);
-    push = XtVaCreateManagedWidget("copy",xmPushButtonWidgetClass,menu,NULL);
-    XtAddCallback(push,XmNactivateCallback,action_cb,"Ipc(copy)");
-    push = XtVaCreateManagedWidget("paste",xmPushButtonWidgetClass,menu,NULL);
-    XtAddCallback(push,XmNactivateCallback,action_cb,"Ipc(paste)");
-    XtVaCreateManagedWidget("sep",xmSeparatorWidgetClass,menu,NULL);
-    push = XtVaCreateManagedWidget("flipv",xmPushButtonWidgetClass,menu,NULL);
-    XtAddCallback(push,XmNactivateCallback,action_cb,"Filter(flip-vert)");
-    push = XtVaCreateManagedWidget("fliph",xmPushButtonWidgetClass,menu,NULL);
-    XtAddCallback(push,XmNactivateCallback,action_cb,"Filter(flip-horz)");
-    push = XtVaCreateManagedWidget("rotcw",xmPushButtonWidgetClass,menu,NULL);
-    XtAddCallback(push,XmNactivateCallback,action_cb,"Filter(rotate-cw)");
-    push = XtVaCreateManagedWidget("rotccw",xmPushButtonWidgetClass,menu,NULL);
-    XtAddCallback(push,XmNactivateCallback,action_cb,"Filter(rotate-ccw)");
-    push = XtVaCreateManagedWidget("invert",xmPushButtonWidgetClass,menu,NULL);
-    XtAddCallback(push,XmNactivateCallback,action_cb,"Filter(invert)");
-    XtVaCreateManagedWidget("sep",xmSeparatorWidgetClass,menu,NULL);
-    push = XtVaCreateManagedWidget("crop",xmPushButtonWidgetClass,menu,NULL);
-    XtAddCallback(push,XmNactivateCallback,action_cb,"Filter(crop)");
-    push = XtVaCreateManagedWidget("acrop",xmPushButtonWidgetClass,menu,NULL);
-    XtAddCallback(push,XmNactivateCallback,action_cb,"Filter(autocrop)");
-    push = XtVaCreateManagedWidget("scale",xmPushButtonWidgetClass,menu,NULL);
-    XtAddCallback(push,XmNactivateCallback,action_cb,"Resize()");
-    push = XtVaCreateManagedWidget("rotany",xmPushButtonWidgetClass,menu,NULL);
-    XtAddCallback(push,XmNactivateCallback,action_cb,"Rotate()");
-
-    /* menu - filters / operations */
-    menu = XmCreatePulldownMenu(menubar,"opM",NULL,0);
-    XtVaCreateManagedWidget("op",xmCascadeButtonWidgetClass,menubar,
-			    XmNsubMenuId,menu,NULL);
-    push = XtVaCreateManagedWidget("gamma",xmPushButtonWidgetClass,menu,NULL);
-    XtAddCallback(push,XmNactivateCallback,action_cb,"Gamma()");
-    push = XtVaCreateManagedWidget("bright",xmPushButtonWidgetClass,menu,NULL);
-    XtAddCallback(push,XmNactivateCallback,action_cb,"Bright()");
-    push = XtVaCreateManagedWidget("contr",xmPushButtonWidgetClass,menu,NULL);
-    XtAddCallback(push,XmNactivateCallback,action_cb,"Contrast()");
-    push = XtVaCreateManagedWidget("color",xmPushButtonWidgetClass,menu,NULL);
-    XtAddCallback(push,XmNactivateCallback,action_cb,"Color()");
-    push = XtVaCreateManagedWidget("gray",xmPushButtonWidgetClass,menu,NULL);
-    XtAddCallback(push,XmNactivateCallback,action_cb,"Filter(grayscale)");
-    XtVaCreateManagedWidget("sep",xmSeparatorWidgetClass,menu,NULL);
-    push = XtVaCreateManagedWidget("blur",xmPushButtonWidgetClass,menu,NULL);
-    XtAddCallback(push,XmNactivateCallback,action_cb,
-		  "F3x3(1,1,1, 1,1,1, 1,1,1, 1,9,0)");
-    push = XtVaCreateManagedWidget("sharpe",xmPushButtonWidgetClass,menu,NULL);
-    XtAddCallback(push,XmNactivateCallback,action_cb,"Sharpe()");
-    push = XtVaCreateManagedWidget("edge",xmPushButtonWidgetClass,menu,NULL);
-    XtAddCallback(push,XmNactivateCallback,action_cb,
-		  "F3x3(-1,-1,-1, -1,8,-1, -1,-1,-1)");
-    push = XtVaCreateManagedWidget("emboss",xmPushButtonWidgetClass,menu,NULL);
-    XtAddCallback(push,XmNactivateCallback,action_cb,
-		  "F3x3(1,0,0, 0,0,0, 0,0,-1, 0,0,128)");
-
-    /* menu - view */
-    menu = XmCreatePulldownMenu(menubar,"viewM",NULL,0);
-    XtVaCreateManagedWidget("view",xmCascadeButtonWidgetClass,menubar,
-			    XmNsubMenuId,menu,NULL);
-    push = XtVaCreateManagedWidget("prev",xmPushButtonWidgetClass,menu,NULL);
-    XtAddCallback(push,XmNactivateCallback,action_cb,"Prev()");
-    push = XtVaCreateManagedWidget("next",xmPushButtonWidgetClass,menu,NULL);
-    XtAddCallback(push,XmNactivateCallback,action_cb,"Next()");
-    XtVaCreateManagedWidget("sep",xmSeparatorWidgetClass,menu,NULL);
-    push = XtVaCreateManagedWidget("prevpage",xmPushButtonWidgetClass,menu,NULL);
-    XtAddCallback(push,XmNactivateCallback,action_cb,"PrevPage()");
-    push = XtVaCreateManagedWidget("nextpage",xmPushButtonWidgetClass,menu,NULL);
-    XtAddCallback(push,XmNactivateCallback,action_cb,"NextPage()");
-    XtVaCreateManagedWidget("sep",xmSeparatorWidgetClass,menu,NULL);
-    push = XtVaCreateManagedWidget("zoomin",xmPushButtonWidgetClass,menu,NULL);
-    XtAddCallback(push,XmNactivateCallback,action_cb,"Zoom(inc)");
-    push = XtVaCreateManagedWidget("zoomout",xmPushButtonWidgetClass,menu,NULL);
-    XtAddCallback(push,XmNactivateCallback,action_cb,"Zoom(dec)");
-
-    /* menu - options */
-    menu = XmCreatePulldownMenu(menubar,"optM",NULL,0);
-    push = XtVaCreateManagedWidget("opt",xmCascadeButtonWidgetClass,menubar,
-				   XmNsubMenuId,menu,NULL);
-    smenu = XmCreatePulldownMenu(menu,"pcdM",NULL,0);
-    XtVaCreateManagedWidget("pcd",xmCascadeButtonWidgetClass,menu,
-			    XmNsubMenuId,smenu,NULL);
-    push = XtVaCreateManagedWidget("1",xmToggleButtonWidgetClass,smenu,NULL);
-    XtAddCallback(push,XmNvalueChangedCallback,pcd_cb,(XtPointer)1);
-    push = XtVaCreateManagedWidget("2",xmToggleButtonWidgetClass,smenu,NULL);
-    XtAddCallback(push,XmNvalueChangedCallback,pcd_cb,(XtPointer)2);
-    push = XtVaCreateManagedWidget("3",xmToggleButtonWidgetClass,smenu,NULL);
-    XtAddCallback(push,XmNvalueChangedCallback,pcd_cb,(XtPointer)3);
-    push = XtVaCreateManagedWidget("4",xmToggleButtonWidgetClass,smenu,NULL);
-    XtAddCallback(push,XmNvalueChangedCallback,pcd_cb,(XtPointer)4);
-    push = XtVaCreateManagedWidget("5",xmToggleButtonWidgetClass,smenu,NULL);
-    XtAddCallback(push,XmNvalueChangedCallback,pcd_cb,(XtPointer)5);
-    pcd_set(smenu);
-
-    push = XtVaCreateManagedWidget("autozoom",xmToggleButtonWidgetClass,menu,NULL);
-    XtAddCallback(push,XmNvalueChangedCallback,cfg_bool_cb,NULL);
-    XmToggleButtonSetState(push,GET_AUTOZOOM(),False);
-
-    XtVaCreateManagedWidget("sep",xmSeparatorWidgetClass,menu,NULL);
-    push = XtVaCreateManagedWidget("cfgsave",xmPushButtonWidgetClass,menu,NULL);
-    XtAddCallback(push,XmNactivateCallback,cfg_save_cb,NULL);
-    
-    /* menu - help */
-    menu = XmCreatePulldownMenu(menubar,"helpM",NULL,0);
-    push = XtVaCreateManagedWidget("help",xmCascadeButtonWidgetClass,menubar,
-				   XmNsubMenuId,menu,NULL);
-    XtVaSetValues(menubar,XmNmenuHelpWidget,push,NULL);
-    push = XtVaCreateManagedWidget("man",xmPushButtonWidgetClass,menu,NULL);
-    XtAddCallback(push,XmNactivateCallback,action_cb,"Man(ida)");
-    XtVaCreateManagedWidget("sep",xmSeparatorWidgetClass,menu,NULL);
-    push = XtVaCreateManagedWidget("about",xmPushButtonWidgetClass,menu,NULL);
-    XtAddCallback(push,XmNactivateCallback,about_cb,NULL);
-
-    /* toolbar */
-    push = XtVaCreateManagedWidget("prev",xmPushButtonWidgetClass,tool,NULL);
-    XtAddCallback(push,XmNactivateCallback,action_cb,"Prev()");
-    push = XtVaCreateManagedWidget("next",xmPushButtonWidgetClass,tool,NULL);
-    XtAddCallback(push,XmNactivateCallback,action_cb,"Next()");
-    push = XtVaCreateManagedWidget("zoomin",xmPushButtonWidgetClass,tool,NULL);
-    XtAddCallback(push,XmNactivateCallback,action_cb,"Zoom(inc)");
-    push = XtVaCreateManagedWidget("zoomout",xmPushButtonWidgetClass,tool,NULL);
-    XtAddCallback(push,XmNactivateCallback,action_cb,"Zoom(dec)");
-
-    XtVaCreateManagedWidget("sep",xmSeparatorWidgetClass,tool,NULL);
-    push = XtVaCreateManagedWidget("flipv",xmPushButtonWidgetClass,tool,NULL);
-    XtAddCallback(push,XmNactivateCallback,action_cb,"Filter(flip-vert)");
-    push = XtVaCreateManagedWidget("fliph",xmPushButtonWidgetClass,tool,NULL);
-    XtAddCallback(push,XmNactivateCallback,action_cb,"Filter(flip-horz)");
-    push = XtVaCreateManagedWidget("rotccw",xmPushButtonWidgetClass,tool,NULL);
-    XtAddCallback(push,XmNactivateCallback,action_cb,"Filter(rotate-ccw)");
-    push = XtVaCreateManagedWidget("rotcw",xmPushButtonWidgetClass,tool,NULL);
-    XtAddCallback(push,XmNactivateCallback,action_cb,"Filter(rotate-cw)");
-
-    XtVaCreateManagedWidget("sep",xmSeparatorWidgetClass,tool,NULL);
-    push = XtVaCreateManagedWidget("exit",xmPushButtonWidgetClass,tool,NULL);
-    XtAddCallback(push,XmNactivateCallback,exit_cb,NULL);
-}
-
-/* ---------------------------------------------------------------------- */
-
-void
-resize_shell(void)
-{
-    char *title,*base;
-    Dimension x,y,w,h,sw,sh;
-    XmString str;
-    int len;
-    
-    XtVaGetValues(app_shell, XtNx,&x, XtNy,&y, NULL);
-
-    /* resize shell + move shell
-       size: image size + 2*shadowThickness */
-    w = ida->scrwidth+2;
-    h = ida->scrheight+2;
-    sw = XtScreen(ida->widget)->width;
-    sh = XtScreen(ida->widget)->height;
-    if (w > sw)
-	w = sw;
-    if (h > sh)
-	h = sh;
-    if (x+w > sw)
-	x = sw-w;
-    if (y+h > sh)
-	y = sh-h;
-
-    base = strrchr(ida->file,'/');
-    if (base)
-	base++;
-    else
-	base = ida->file;
-    title = malloc(strlen(base)+128);
-    len = sprintf(title,"%s (%dx%d", base,
-		  ida->img.i.width, ida->img.i.height);
-    if (ida->img.i.dpi)
-	len += sprintf(title+len," | %d dpi",
-		       ida->img.i.dpi);
-    if (ida->img.i.npages > 1)
-        len += sprintf(title+len," | page %d/%d",
-		       cpage+1, ida->img.i.npages);
-    len += sprintf(title+len," | %d%%)", viewer_i2s(ida->zoom,100));
-    XtVaSetValues(app_shell, XtNtitle,title,
-		  /* XtNx,x, XtNy,y, */ XtNwidth,w, XtNheight,h,
-		  NULL);
-    str = XmStringGenerate(title,NULL,XmMULTIBYTE_TEXT,NULL);
-    XtVaSetValues(status,XmNlabelString,str,NULL);
-    XmStringFree(str);
-    free(title);
-}
-
-static int
-load_file(int nr, int np)
-{
-    if(nr < 0 || nr >= nfiles)
-        return -1;
-    npages = viewer_loadimage(ida,files[nr],np);
-    if (-1 == npages)
-	return -1;
-    resize_shell();
-#if 0
-    XmListSelectPos(wlist,nr+1,False);
-    cfile = nr;
-#endif
-    return npages;
-}
-
-char*
-load_tmpfile(char *base)
-{
-    char *tmpdir;
-    char *filename;
-
-    tmpdir = getenv("TMPDIR");
-    if (NULL == tmpdir)
-	tmpdir="/tmp";
-    filename = malloc(strlen(tmpdir)+strlen(base)+16);
-    sprintf(filename,"%s/%s-XXXXXX",tmpdir,base);
-    return filename;
-}
-
-static void
-load_logo(void)
-{
-    static unsigned char logo[] = {
-#include "logo.h"
-    };
-    char *filename = load_tmpfile("ida-logo");
-    int fd;
-    fd = mkstemp(filename);
-    write(fd,logo,sizeof(logo));
-    close(fd);
-    cpage = 0;
-    npages = 1;
-    if (0 < viewer_loadimage(ida,filename,cpage)) {
-	ida->file = "ida " VERSION;
-	resize_shell();
-    }
-    unlink(filename);
-    free(filename);
-}
-
-static void
-load_stdin(void)
-{
-    char *filename = load_tmpfile("ida-stdin");
-    char buf[4096];
-    int rc,fd;
-    fd = mkstemp(filename);
-    for (;;) {
-	rc = read(0,buf,sizeof(buf));
-	if (rc <= 0)
-	    break;
-	write(fd,buf,rc);
-    }
-    close(fd);
-    cpage = 0;
-    npages = 1;
-    if (0 < viewer_loadimage(ida,filename,cpage)) {
-	ida->file = "stdin";
-	resize_shell();
-    }
-    unlink(filename);
-    free(filename);
-}
-
-void
-next_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
-{
-    for (;;) {
-	if (cfile >= nfiles-1)
-	    return;
-	cfile++;
-        cpage = 0;
-	if (0 <= load_file(cfile,cpage))
-	    break;
-    }
-}
-
-void
-prev_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
-{
-    for (;;) {
-	if (cfile < 1)
-	    return;
-	cfile--;
-        cpage = 0;
-	if (0 <= load_file(cfile,cpage))
-	    break;
-    }
-}
-
-void
-next_page_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
-{
-    for (;;) {
-	if (cpage >= npages-1)
-	    return;
-	cpage++;
-	if (0 <= load_file(cfile,cpage))
-	    break;
-    }
-}
-
-void
-prev_page_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
-{
-    for (;;) {
-	if (cpage <= 0)
-	    return;
-	cpage--;
-	if (0 <= load_file(cfile,cpage))
-	    break;
-    }
-}
-
-void
-zoom_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
-{
-    int zoom;
-    
-    if (0 == *num)
-	return;
-
-    if (0 == strcasecmp(params[0],"auto")) {
-	viewer_autozoom(ida);
-	return;
-    }
-
-    if (0 == strcasecmp(params[0],"inc")) {
-	zoom = ida->zoom+1;
-    } else if (0 == strcasecmp(params[0],"dec")) {
-	zoom = ida->zoom-1;
-    } else {
-	zoom = atoi(params[0]);
-    }
-    viewer_setzoom(ida,zoom);
-    resize_shell();
-}
-
-void
-scroll_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
-{
-    fprintf(stderr,"Scroll(): %s\n",XtName(widget));
-}
-
-/* ---------------------------------------------------------------------- */
-
-void new_file(char *name, int complain)
-{
-    struct stat st;
-    int n;
-
-    if (curl_is_url(name))
-	goto load;
-
-    if (0 == strncasecmp(name,"file:",5))
-	name += 5;
-    if (-1 == stat(name,&st)) {
-	if (complain)
-	    fprintf(stderr,"stat %s: %s\n",name,strerror(errno));
-	return;
-    }
-    switch (st.st_mode & S_IFMT) {
-    case S_IFDIR:
-	browser_window(name);
-	break;
-    case S_IFREG:
-	goto load;
-	break;
-    }
-    return;
-    
- load:
-    n = list_append(name);
-    list_update();
-    cpage = 0;
-    load_file(n,cpage);
-}
-
-static void
-load_done_cb(Widget widget, XtPointer clientdata, XtPointer call_data)
-{
-    XmFileSelectionBoxCallbackStruct *cb = call_data;
-    char *line;
-
-    if (cb->reason == XmCR_OK) {
-        line = XmStringUnparse(cb->value,NULL,
-                               XmMULTIBYTE_TEXT,XmMULTIBYTE_TEXT,
-                               NULL,0,0);
-	new_file(line,1);
-    }
-    XtUnmanageChild(widget);
-}
-
-void
-load_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
-{
-    Widget help;
-
-    if (NULL == loadbox) {
-	loadbox = XmCreateFileSelectionDialog(app_shell,"load",NULL,0);
-	help = XmFileSelectionBoxGetChild(loadbox,XmDIALOG_HELP_BUTTON);
-	XtUnmanageChild(help);
-	XtAddCallback(loadbox,XmNokCallback,load_done_cb,NULL);
-	XtAddCallback(loadbox,XmNcancelCallback,load_done_cb,NULL);
-    } else {
-	XmFileSelectionDoSearch(loadbox,NULL);
-    }
-    XtManageChild(loadbox);
-}
-
-void
-scan_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
-{
-#ifdef HAVE_LIBSANE
-    cpage = 0;
-    if (*num)
-	npages = viewer_loader_start(ida, &sane_loader, NULL, params[0], 0);
-    else
-	npages = viewer_loader_start(ida, &sane_loader, NULL, "", 0);
-    if (-1 == npages)
-	return;
-    ida->file = "scanned image";
-    resize_shell();
-#endif
-}
-
-/* ---------------------------------------------------------------------- */
-
-void
-do_save_print(void)
-{
-    FILE *fp;
-    
-    if (save_filename) {
-	XtUnmanageChild(savebox);
-	ptr_busy();
-	if (NULL == (fp = fopen(save_filename,"wb"))) {
-	    fprintf(stderr,"save: can't open %s: %s\n",
-		    save_filename,strerror(errno));
-	} else if (-1 == cwriter->write(fp,&ida->img)) {
-	    fclose(fp);
-	    fprintf(stderr,"saving %s FAILED",save_filename);
-	} else {
-	    fclose(fp);
-	    list_append(save_filename);
-	    list_update();
-	}
-	ptr_idle();
-    }
-    if (print_command) {
-	XtUnmanageChild(printbox);
-	ptr_busy();
-	if (NULL == (fp = popen(print_command,"w"))) {
-	    fprintf(stderr,"print: can't exec %s: %s\n",
-		    print_command,strerror(errno));
-	} else {
-	    if (-1 == cwriter->write(fp,&ida->img))
-		fprintf(stderr,"printing FAILED");
-	    fclose(fp);
-	}
-	ptr_idle();
-    }
-}
-
-static void
-save_done_cb(Widget widget, XtPointer clientdata, XtPointer call_data)
-{
-    XmFileSelectionBoxCallbackStruct *cb = call_data;
-
-    if (cb->reason == XmCR_OK) {
-	print_command = NULL;
-	save_filename = XmStringUnparse(cb->value,NULL,
-					XmMULTIBYTE_TEXT,XmMULTIBYTE_TEXT,
-					NULL,0,0);
-	if (cwriter->conf) {
-	    cwriter->conf(widget,&ida->img);
-	} else {
-	    do_save_print();
-	}
-    } else {
-	XtUnmanageChild(widget);
-    }
-}
-
-static void
-save_fmt_cb(Widget widget, XtPointer clientdata, XtPointer call_data)
-{
-    cwriter = clientdata;
-}
-
-static void
-save_ext_cb(Widget widget, XtPointer clientdata, XtPointer call_data)
-{
-    Widget option = clientdata;
-    Widget menu;
-    WidgetList children;
-    Cardinal nchildren;
-    struct ida_writer *wr = NULL;
-    struct list_head *item;
-    char *name,*ext;
-    int i,j,pick;
-
-    name = XmTextGetString(widget);
-    ext = strrchr(name,'.');
-    if (NULL == ext)
-	return;
-    if (strchr(ext,'/'))
-	return;
-    ext++;
-
-    i = 0; pick = -1;
-    list_for_each(item,&writers) {
-	wr = list_entry(item, struct ida_writer, list);
-	for (j = 0; NULL != wr->ext[j]; j++)
-	    if (0 == strcasecmp(ext,wr->ext[j]))
-		pick = i;
-	if (-1 != pick)
-	    break;
-	i++;
-    }
-    if (-1 == pick)
-	return;
-
-    XtVaGetValues(option,XmNsubMenuId,&menu,NULL);
-    XtVaGetValues(menu,XtNchildren,&children,
-		  XtNnumChildren,&nchildren,NULL);
-    XtVaSetValues(option,XmNmenuHistory,children[pick],NULL);
-    cwriter = wr;
-}
-
-static void
-save_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
-{
-    Widget help,menu,option,push,text;
-    Arg args[2];
-    struct ida_writer *wr = NULL;
-    struct list_head *item;
-
-    if (NULL == savebox) {
-	savebox = XmCreateFileSelectionDialog(app_shell,"save",NULL,0);
-	help = XmFileSelectionBoxGetChild(savebox,XmDIALOG_HELP_BUTTON);
-	text = XmFileSelectionBoxGetChild(savebox,XmDIALOG_TEXT);
-	XtUnmanageChild(help);
-
-	menu = XmCreatePulldownMenu(savebox,"formatM",NULL,0);
-	XtSetArg(args[0],XmNsubMenuId,menu);
-	option = XmCreateOptionMenu(savebox,"format",args,1);
-	XtManageChild(option);
-	list_for_each(item,&writers) {
-	    wr = list_entry(item, struct ida_writer, list);
-	    push = XtVaCreateManagedWidget(wr->label,
-					   xmPushButtonWidgetClass,menu,
-					   NULL);
-	    XtAddCallback(push,XmNactivateCallback,save_fmt_cb,wr);
-	}
-	cwriter = list_entry(writers.next, struct ida_writer, list);
-
-	XtAddCallback(text,XmNvalueChangedCallback,save_ext_cb,option);
-	XtAddCallback(savebox,XmNokCallback,save_done_cb,NULL);
-	XtAddCallback(savebox,XmNcancelCallback,save_done_cb,NULL);
-    } else {
-	XmFileSelectionDoSearch(savebox,NULL);
-    }
-    XtManageChild(savebox);
-}
-
-/* ---------------------------------------------------------------------- */
-
-static void
-print_done_cb(Widget widget, XtPointer clientdata, XtPointer call_data)
-{
-    XmSelectionBoxCallbackStruct *cb = call_data;
-
-    if (cb->reason == XmCR_OK) {
-	save_filename = NULL;
-	print_command = XmStringUnparse(cb->value,NULL,
-					XmMULTIBYTE_TEXT,XmMULTIBYTE_TEXT,
-					NULL,0,0);
-	cwriter = &ps_writer;
-	cwriter->conf(widget,&ida->img);
-    } else {
-	XtUnmanageChild(widget);
-    }
-}
-
-static void
-print_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
-{
-    if (NULL == printbox) {
-	printbox = XmCreatePromptDialog(app_shell,"print",NULL,0);
-	XtUnmanageChild(XmSelectionBoxGetChild(printbox,XmDIALOG_HELP_BUTTON));
-	XtAddCallback(printbox,XmNokCallback,print_done_cb,NULL);
-	XtAddCallback(printbox,XmNcancelCallback,print_done_cb,NULL);
-    }
-    XtManageChild(printbox);
-}
-
-/* ---------------------------------------------------------------------- */
-
-static struct ida_op *ops[] = {
-    &desc_flip_vert,
-    &desc_flip_horz,
-    &desc_rotate_cw,
-    &desc_rotate_ccw,
-    &desc_invert,
-    &desc_crop,
-    &desc_autocrop,
-    &desc_grayscale,
-    NULL
-};
-
-void
-filter_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
-{
-    struct ida_op *op = NULL;
-    int i;
-
-    if (*num < 1)
-	return;
-    for (i = 0; NULL != ops[i]; i++) {
-	op = ops[i];
-	if (0 == strcasecmp(op->name,params[0]))
-	    break;
-    }
-    if (NULL == ops[i]) {
-	fprintf(stderr,"Oops: unknown filter: %s\n",params[0]);
-	return;
-    }
-
-    viewer_start_op(ida,op,NULL);
-    if (ida->op_src.i.width  != ida->img.i.width ||
-	ida->op_src.i.height != ida->img.i.height)
-	resize_shell();
-}
-
-void
-f3x3_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
-{
-    struct op_3x3_parm p;
-
-    if (*num < 9) {
-	fprintf(stderr,"F3x3: wrong number of args (%d, need 9)\n",*num);
-	return;
-    }
-    memset(&p,0,sizeof(p));
-    p.f1[0] = atoi(params[0]);
-    p.f1[1] = atoi(params[1]);
-    p.f1[2] = atoi(params[2]);
-    p.f2[0] = atoi(params[3]);
-    p.f2[1] = atoi(params[4]);
-    p.f2[2] = atoi(params[5]);
-    p.f3[0] = atoi(params[6]);
-    p.f3[1] = atoi(params[7]);
-    p.f3[2] = atoi(params[8]);
-    if (*num >  9) p.mul = atoi(params[ 9]);
-    if (*num > 10) p.div = atoi(params[10]);
-    if (*num > 11) p.add = atoi(params[11]);
-    if (debug) {
-	fprintf(stderr,"f3x3: -----------\n");
-	fprintf(stderr,"f3x3: %3d %3d %3d\n",p.f1[0],p.f1[1],p.f1[2]);
-	fprintf(stderr,"f3x3: %3d %3d %3d\n",p.f2[0],p.f2[1],p.f2[2]);
-	fprintf(stderr,"f3x3: %3d %3d %3d\n",p.f3[0],p.f3[1],p.f3[2]);
-	fprintf(stderr,"f3x3: *%d/%d+%d\n",p.mul,p.div,p.add);
-    }
-    viewer_start_op(ida,&desc_3x3,&p);
-}
-
-void
-undo_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
-{
-    Widget msgbox;
-    int resize;
-
-    resize = (ida->undo.i.width  != ida->img.i.width ||
-	      ida->undo.i.height != ida->img.i.height);
-    if (-1 == viewer_undo(ida)) {
-	msgbox = XmCreateInformationDialog(app_shell,"noundobox",NULL,0);
-	XtUnmanageChild(XmMessageBoxGetChild(msgbox,XmDIALOG_HELP_BUTTON));
-	XtUnmanageChild(XmMessageBoxGetChild(msgbox,XmDIALOG_CANCEL_BUTTON));
-	XtAddCallback(msgbox,XmNokCallback,destroy_cb,msgbox);
-	XtManageChild(msgbox);
-    } else {
-	if (resize)
-	    resize_shell();
-    }
-}
-
-/* ---------------------------------------------------------------------- */
-
-struct ida_prompt {
-    Widget shell;
-    Widget box;
-    Widget scale;
-    Widget text;
-    int apply;
-    int value;
-    int decimal;
-    int factor;    /* 10^decimal */
-    void (*notify)(int value, int preview);
-};
-
-static void
-prompt_setvalue(struct ida_prompt *me, int value, int scale, int text)
-{
-    char str[32];
-    int min,max;
-    
-    if (me->value == value)
-	return;
-    XtVaGetValues(me->scale,XmNminimum,&min,XmNmaximum,&max,NULL);
-    if (value < min || value > max)
-	return;
-
-    me->value = value;
-    if (scale)
-	XmScaleSetValue(me->scale,value);
-    if (text) {
-	if (me->decimal) {
-	    sprintf(str,"%*.*f",me->decimal+2,me->decimal,
-		    (float)value/me->factor);
-	} else {
-	    sprintf(str,"%d",value);
-	}
-	XmTextSetString(me->text,str);
-    }
-    if (me->notify)
-	me->notify(value,1);
-}
-
-static void
-prompt_scale_cb(Widget widget, XtPointer client_data, XtPointer calldata)
-{
-    struct ida_prompt *me = client_data;
-    XmScaleCallbackStruct *cd = calldata;
-
-    prompt_setvalue(me,cd->value,0,1);
-}
-
-static void
-prompt_text_cb(Widget widget, XtPointer client_data, XtPointer calldata)
-{
-    struct ida_prompt *me = client_data;
-    float fvalue;
-    int value;
-
-    if (me->decimal) {
-	fvalue  = atof(XmTextGetString(me->text));
-	fvalue += 0.5/me->factor;
-	value = (int)(fvalue * me->factor);
-    } else {
-	value = atoi(XmTextGetString(me->text));
-    }
-    prompt_setvalue(me,value,1,0);
-}
-
-static void
-prompt_box_cb(Widget widget, XtPointer client_data, XtPointer calldata)
-{
-    struct ida_prompt *me = client_data;
-    XmSelectionBoxCallbackStruct *cd = calldata;
-
-    if (XmCR_OK == cd->reason)
-	me->apply = 1;
-    XtDestroyWidget(me->shell);
-}
-
-static void
-prompt_shell_cb(Widget widget, XtPointer client_data, XtPointer calldata)
-{
-    struct ida_prompt *me = client_data;
-
-    if (me->apply)
-	me->notify(me->value,0);
-    else
-	viewer_cancel_preview(ida);
-    free(me);
-}
-
-static void
-prompt_init(char *name, int decimal, int value,
-	    void (*notify)(int value, int preview))
-{
-    struct ida_prompt *me;
-
-    me = malloc(sizeof(*me));
-    memset(me,0,sizeof(*me));
-    if (decimal) {
-	int i;
-	me->decimal = decimal;
-	me->factor = 1;
-	for (i = 0; i < decimal; i++)
-	    me->factor *= 10;
-    }
-    me->notify = notify;
-    
-    me->box = XmCreatePromptDialog(app_shell,name,NULL,0);
-    me->shell = XtParent(me->box);
-    me->text = XmSelectionBoxGetChild(me->box,XmDIALOG_TEXT);
-    XmdRegisterEditres(XtParent(me->box));
-    XtUnmanageChild(XmSelectionBoxGetChild(me->box,XmDIALOG_HELP_BUTTON));
-    me->scale = XtVaCreateManagedWidget("scale",xmScaleWidgetClass,
-					me->box,NULL);
-
-    XtAddCallback(me->scale,XmNdragCallback,prompt_scale_cb,me);
-    XtAddCallback(me->scale,XmNvalueChangedCallback,prompt_scale_cb,me);
-    XtAddCallback(me->text,XmNvalueChangedCallback,prompt_text_cb,me);
-    XtAddCallback(me->box,XmNokCallback,prompt_box_cb,me);
-    XtAddCallback(me->box,XmNcancelCallback,prompt_box_cb,me);
-    XtAddCallback(me->shell,XmNdestroyCallback,prompt_shell_cb,me);
-    
-    XtManageChild(me->box);
-    prompt_setvalue(me,value,1,1);
-}
-
-/* ---------------------------------------------------------------------- */
-
-static void
-gamma_notify(int value, int preview)
-{
-    struct op_map_parm param;
-    float gamma = (float)value/100;
-
-    param.red = op_map_nothing;
-    param.red.gamma   = gamma;
-    param.green = param.red;
-    param.blue  = param.red;
-    if (preview) {
-	viewer_start_preview(ida,&desc_map,&param);
-    } else {
-	gamma_val = value;
-	viewer_start_op(ida,&desc_map,&param);
-    }
-}
-
-void
-gamma_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
-{
-    prompt_init("gamma",2,gamma_val,gamma_notify);
-}
-
-static void
-bright_notify(int value, int preview)
-{
-    struct op_map_parm param;
-
-    param.red = op_map_nothing;
-    param.red.bottom += value;
-    param.red.top    += value;
-    param.green = param.red;
-    param.blue  = param.red;
-    if (preview) {
-	viewer_start_preview(ida,&desc_map,&param);
-    } else {
-	bright_val = value;
-	viewer_start_op(ida,&desc_map,&param);
-    }
-}
-
-void
-bright_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
-{
-    prompt_init("bright",0,bright_val,bright_notify);
-}
-
-static void
-contrast_notify(int value, int preview)
-{
-    struct op_map_parm param;
-
-    param.red = op_map_nothing;
-    param.red.bottom -= value;
-    param.red.top    += value;
-    param.green = param.red;
-    param.blue  = param.red;
-    if (preview) {
-	viewer_start_preview(ida,&desc_map,&param);
-    } else {
-	contrast_val = value;
-	viewer_start_op(ida,&desc_map,&param);
-    }
-}
-
-void
-contrast_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
-{
-    prompt_init("contrast",0,contrast_val,contrast_notify);
-}
-
-static void
-rotate_notify(int value, int preview)
-{
-    struct op_rotate_parm parm;
-
-    parm.angle = value;
-    if (preview) {
-	viewer_start_preview(ida,&desc_rotate,&parm);
-    } else {
-	rotate_val = value;
-	viewer_start_op(ida,&desc_rotate,&parm);
-    }
-}
-
-void
-rotate_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
-{
-    prompt_init("rotate",0,rotate_val,rotate_notify);
-}
-
-static void
-sharpe_notify(int value, int preview)
-{
-    struct op_sharpe_parm parm;
-
-    parm.factor = value;
-    if (preview) {
-	viewer_start_preview(ida,&desc_sharpe,&parm);
-    } else {
-	sharpe_val = value;
-	viewer_start_op(ida,&desc_sharpe,&parm);
-    }
-}
-
-void
-sharpe_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
-{
-    prompt_init("sharpe",0,sharpe_val,sharpe_notify);
-}
-
-void
-color_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
-{
-    color_init(&ida->img);
-}
-
-/* ---------------------------------------------------------------------- */
-
-struct ida_resize {
-    Widget dlg,tx,ty,tr,lock,size,res,label;
-    int yupdate,xupdate,rupdate;
-    int apply;
-};
-
-static void
-resize_phys_size(struct ida_resize *h)
-{
-    char buf[128];
-    XmString str;
-    int dpi;
-    float x,y;
-
-    dpi = atoi(XmTextGetString(h->tr));
-    if (dpi) {
-	x = (float)atoi(XmTextGetString(h->tx)) / dpi;
-	y = (float)atoi(XmTextGetString(h->ty)) / dpi;
-	sprintf(buf,"%.2f x %.2f inch\n%.2f x %.2f cm",
-		x,y, x*2.54, y*2.54);
-    } else {
-	strcpy(buf,"unknown");
-    }
-    str = XmStringGenerate(buf, NULL, XmMULTIBYTE_TEXT,NULL);
-    XtVaSetValues(h->label,XmNlabelString,str,NULL);
-}
-
-static void
-resize_sync_cb(Widget widget, XtPointer client_data, XtPointer calldata)
-{
-    struct ida_resize *h = client_data;
-    char buf[32];
-    int i,lock,res;
-
-    lock = XmToggleButtonGetState(h->lock);
-    res  = XmToggleButtonGetState(h->res);
-
-    /* update text fields */
-    if (h->tx == widget) {
-	if (h->xupdate) {
-	    h->xupdate--;
-	    return;
-	}
-	i = atoi(XmTextGetString(h->tx));
-	if (lock) {
-	    sprintf(buf,"%d",i * ida->img.i.height / ida->img.i.width);
-	    h->yupdate++;
-	    XmTextSetString(h->ty,buf);
-	    if (res) {
-		sprintf(buf,"%d", ida->img.i.dpi * i / ida->img.i.width);
-		h->rupdate++;
-		XmTextSetString(h->tr,buf);
-	    }
-	} else {
-	    if (res) {
-		h->rupdate++;
-		XmTextSetString(h->tr,"0");
-	    }
-	}
-	resize_phys_size(h);
-    }
-    if (h->ty == widget) {
-	if (h->yupdate) {
-	    h->yupdate--;
-	    return;
-	}
-	i = atoi(XmTextGetString(h->ty));
-	if (lock) {
-	    sprintf(buf,"%d",i * ida->img.i.width / ida->img.i.height);
-	    h->xupdate++;
-	    XmTextSetString(h->tx,buf);
-	    if (res) {
-		sprintf(buf,"%d", ida->img.i.dpi * i / ida->img.i.height);
-		h->rupdate++;
-		XmTextSetString(h->tr,buf);
-	    }
-	} else {
-	    if (res) {
-		h->rupdate++;
-		XmTextSetString(h->tr,"0");
-	    }
-	}
-	resize_phys_size(h);
-    }
-    if (h->tr == widget) {
-	if (h->rupdate) {
-	    h->rupdate--;
-	    return;
-	}
-	i = atoi(XmTextGetString(h->tr));
-	sprintf(buf,"%d", ida->img.i.width * i / ida->img.i.dpi);
-	h->xupdate++;
-	XmTextSetString(h->tx,buf);
-	sprintf(buf,"%d", ida->img.i.height * i / ida->img.i.dpi);
-	h->yupdate++;
-	XmTextSetString(h->ty,buf);
-	resize_phys_size(h);
-    }
-
-    /* radio buttons pressed */
-    if (h->size == widget && XmToggleButtonGetState(h->size)) {
-	XmToggleButtonSetState(h->res,0,False);
-	sprintf(buf,"%d", ida->img.i.dpi);
-	h->rupdate++;
-	XmTextSetString(h->tr,buf);
-	XtVaSetValues(h->tr,XmNsensitive,False,NULL);
-	resize_phys_size(h);
-    }
-    if (h->res == widget && XmToggleButtonGetState(h->res)) {
-	XmToggleButtonSetState(h->size,0,False);
-	XtVaSetValues(h->tr,XmNsensitive,True,NULL);
-    }
-}
-
-static void
-resize_button_cb(Widget widget, XtPointer client_data, XtPointer calldata)
-{
-    struct ida_resize *h = client_data;
-    XmSelectionBoxCallbackStruct *cb = calldata;
-
-    if (cb->reason == XmCR_OK)
-	h->apply = 1;
-    XtDestroyWidget(XtParent(h->dlg));
-}
-
-static void
-resize_destroy(Widget widget, XtPointer client_data, XtPointer calldata)
-{
-    struct ida_resize *h = client_data;
-    struct op_resize_parm param;
-
-    if (!h->apply)
-	return;
-    param.width  = atoi(XmTextGetString(h->tx));
-    param.height = atoi(XmTextGetString(h->ty));
-    param.dpi    = atoi(XmTextGetString(h->tr));
-    if (0 == param.width  ||
-	0 == param.height) {
-	fprintf(stderr,"resize: invalid argument\n");
-	return;
-    }
-	
-    viewer_start_op(ida,&desc_resize,&param);
-    resize_shell();
-    free(h);
-}
-
-static void
-resize_ac(Widget widget, XEvent *event, String *params, Cardinal *num)
-{
-    Widget rc,rc2;
-    char buf[32];
-    struct ida_resize *h;
-
-    h = malloc(sizeof(*h));
-    memset(h,0,sizeof(*h));
-    
-    h->dlg = XmCreatePromptDialog(app_shell,"resize",NULL,0);
-    XmdRegisterEditres(XtParent(h->dlg));
-    XtUnmanageChild(XmSelectionBoxGetChild(h->dlg,XmDIALOG_SELECTION_LABEL));
-    XtUnmanageChild(XmSelectionBoxGetChild(h->dlg,XmDIALOG_HELP_BUTTON));
-    XtUnmanageChild(XmSelectionBoxGetChild(h->dlg,XmDIALOG_TEXT));
-    rc = XtVaCreateManagedWidget("rc", xmRowColumnWidgetClass,h->dlg, NULL);
-    XtVaCreateManagedWidget("lx", xmLabelWidgetClass,rc, NULL);
-    h->tx = XtVaCreateManagedWidget("tx", xmTextWidgetClass,rc, NULL);
-    XtVaCreateManagedWidget("ly", xmLabelWidgetClass,rc, NULL);
-    h->ty = XtVaCreateManagedWidget("ty", xmTextWidgetClass,rc, NULL);
-    XtVaCreateManagedWidget("lr", xmLabelWidgetClass,rc, NULL);
-    h->tr = XtVaCreateManagedWidget("tr", xmTextWidgetClass,rc, NULL);
-    h->lock = XtVaCreateManagedWidget("lock", xmToggleButtonWidgetClass,
-				      rc, NULL);
-    rc2 = XtVaCreateManagedWidget("rc", xmRowColumnWidgetClass,rc, NULL);
-    h->size = XtVaCreateManagedWidget("size", xmToggleButtonWidgetClass,
-				      rc2, NULL);
-    h->res  = XtVaCreateManagedWidget("res", xmToggleButtonWidgetClass,
-				      rc2, NULL);
-    XtVaCreateManagedWidget("phys", xmLabelWidgetClass,rc,NULL);
-    h->label = XtVaCreateManagedWidget("label", xmLabelWidgetClass,
-				       rc, NULL);
-
-    sprintf(buf,"%d",ida->img.i.width);
-    XmTextSetString(h->tx,buf);
-    sprintf(buf,"%d",ida->img.i.height);
-    XmTextSetString(h->ty,buf);
-    sprintf(buf,"%d",ida->img.i.dpi);
-    XmTextSetString(h->tr,buf);
-    XtVaSetValues(h->tr,XmNsensitive,False,NULL);
-    XmToggleButtonSetState(h->lock,1,False);
-    XmToggleButtonSetState(h->size,1,False);
-    XmToggleButtonSetState(h->res,0,False);
-    if (!ida->img.i.dpi) {
-    	XtVaSetValues(h->size,XmNsensitive,False,NULL);
-	XtVaSetValues(h->res, XmNsensitive,False,NULL);
-    }
-    resize_phys_size(h);
-    
-    XtAddCallback(XtParent(h->dlg),XmNdestroyCallback,resize_destroy,h);
-    XtAddCallback(h->dlg, XmNokCallback,           resize_button_cb, h);
-    XtAddCallback(h->dlg, XmNcancelCallback,       resize_button_cb, h);
-    XtAddCallback(h->tx,  XmNvalueChangedCallback, resize_sync_cb,   h);
-    XtAddCallback(h->ty,  XmNvalueChangedCallback, resize_sync_cb,   h);
-    XtAddCallback(h->tr,  XmNvalueChangedCallback, resize_sync_cb,   h);
-    XtAddCallback(h->size,XmNvalueChangedCallback, resize_sync_cb,   h);
-    XtAddCallback(h->res, XmNvalueChangedCallback, resize_sync_cb,   h);
-    XtManageChild(h->dlg);
-}
-
-/* ---------------------------------------------------------------------- */
-
-struct stderr_handler {
-    Widget box;
-    XmString str;
-    int pipe,err;
-    XtInputId id;
-};
-
-static void
-stderr_input(XtPointer clientdata, int *src, XtInputId *id)
-{
-    struct stderr_handler *h = clientdata;
-    XmString item;
-    Widget label;
-    char buf[1024];
-    int rc;
-
-    rc = read(h->pipe,buf,sizeof(buf)-1);
-    if (rc <= 0) {
-	/* Oops */
-	XtRemoveInput(h->id);
-	close(h->pipe);
-	XtDestroyWidget(h->box);
-	free(h);
-    }
-    buf[rc] = 0;
-    write(h->err,buf,rc);
-    item = XmStringGenerate(buf, NULL, XmMULTIBYTE_TEXT,NULL);
-    h->str = XmStringConcatAndFree(h->str,item);
-    label = XmMessageBoxGetChild(h->box,XmDIALOG_MESSAGE_LABEL);
-    XtVaSetValues(label,XmNlabelString,h->str,NULL);
-    XtManageChild(h->box);
-}
-
-static void
-stderr_ok_cb(Widget widget, XtPointer clientdata, XtPointer call_data)
-{
-    struct stderr_handler *h = clientdata;
-
-    XmStringFree(h->str);
-    h->str = XmStringGenerate("", NULL, XmMULTIBYTE_TEXT,NULL);
-    XtUnmanageChild(h->box);
-}
-
-static void
-stderr_close_cb(Widget widget, XtPointer clientdata, XtPointer call_data)
-{
-    struct stderr_handler *h = clientdata;
-
-    XmStringFree(h->str);
-    h->str = XmStringGenerate("", NULL, XmMULTIBYTE_TEXT,NULL);
-}
-
-static void
-stderr_init(void)
-{
-    struct stderr_handler *h;
-    int p[2];
-
-    h = malloc(sizeof(*h));
-    memset(h,0,sizeof(*h));
-    h->str = XmStringGenerate("", NULL, XmMULTIBYTE_TEXT,NULL);
-    h->box = XmCreateErrorDialog(app_shell,"errbox",NULL,0);
-    XtUnmanageChild(XmMessageBoxGetChild(h->box,XmDIALOG_HELP_BUTTON));
-    XtUnmanageChild(XmMessageBoxGetChild(h->box,XmDIALOG_CANCEL_BUTTON));
-    XtAddCallback(h->box,XmNokCallback,stderr_ok_cb,h);
-    XtAddCallback(XtParent(h->box),XmNpopdownCallback,stderr_close_cb,h);
-    XSync(XtDisplay(app_shell),False);
-    if (!debug) {
-	pipe(p);
-	h->err = dup(2);
-	dup2(p[1],2);
-	close(p[1]);
-	h->pipe = p[0];
-	h->id = XtAppAddInput(app_context,h->pipe,(XtPointer)XtInputReadMask,
-			      stderr_input,h);
-    }
-}
-
-/* ---------------------------------------------------------------------- */
-
-static void
-create_mainwindow(void)
-{
-    Widget img;
-
-    XmdRegisterEditres(app_shell);
-    view = XmCreateScrolledWindow(app_shell,"view",NULL,0);
-    XtManageChild(view);
-    img = XtVaCreateManagedWidget("image", xmDrawingAreaWidgetClass,view,NULL);
-    XtAddCallback(img,XmNdestinationCallback,selection_dest,NULL);
-    XtAddCallback(img,XmNconvertCallback,selection_convert,NULL);
-    dnd_add(img);
-    ida = viewer_init(img);
-    XtInstallAllAccelerators(img,app_shell);
-}
-
-static void
-usage(void)
-{
-    fprintf(stderr,
-	    "ida " VERSION " - image viewer & editor\n"
-	    "usage: ida [ options ] [ files ]\n"
-	    "options:\n"
-	    "   -h, -help    this text\n"
-	    "       -pcd n   pick PhotoCD size (n = 1 .. 5, default 3)\n"
-	    "   -d, -debug   enable debug messages\n");
-    exit(0);
-}
-
-int
-main(int argc, char *argv[])
-{
-    int i, files, zero = 0;
-    struct stat st;
-    Pixel background;
-
-    setlocale(LC_ALL,"");
-    if (0 == strcasecmp("utf-8", nl_langinfo(CODESET))) {
-	/* ### FIXME ###
-	 * for not-yet known reasons ida crashes somewhere deep in
-	 * the Motif libraries when running in utf-8 locale ... */
-	setenv("LC_ALL", "POSIX", 1);
-	setlocale(LC_ALL,"");
-    }
-    
-    binary = argv[0];
-    ida_init_config();
-    ida_read_config();
-
-    XtSetLanguageProc(NULL,NULL,NULL);
-    app_shell = XtAppInitialize(&app_context, "Ida",
-				opt_desc, opt_count,
-				&argc, argv,
-				fallback_ressources,
-				NULL, 0);
-    dpy = XtDisplay(app_shell);
-    XtGetApplicationResources(app_shell,&args,
-			      args_desc,args_count,
-			      NULL,0);
-    pcd_res  = GET_PHOTOCD_RES();
-    sane_res = GET_SANE_RES();
-    if (args.help)
-	usage();
-    if (args.debug) {
-	debug=1;
-	xdnd_debug = 1;
-	XSynchronize(dpy,1);
-    }
-
-    XtAppAddActions(app_context, actionTable,
-		    sizeof(actionTable) / sizeof(XtActionsRec));
-    if (0) {
-	XtAddCallback(XmGetXmDisplay(dpy),XmNnoFontCallback,
-		      display_cb,NULL);
-	XtAddCallback(XmGetXmDisplay(dpy),XmNnoRenditionCallback,
-		      display_cb,NULL);
-    }
-    XtVaGetValues(app_shell, XtNbackground,&background, NULL);
-    x11_color_init(app_shell,&gray);
-    x11_icons_init(dpy, background /* x11_gray */);
-    stderr_init();
-    ipc_init();
-
-    wm_delete_window = XInternAtom(dpy,"WM_DELETE_WINDOW",False);
-    create_mainwindow();
-    create_control();
-    XtRealizeWidget(app_shell);
-    ptr_register(ida->widget);
-    ptr_register(control_shell);
-
-    /* handle cmd line args */
-    if (2 == argc && 0 == strcmp(argv[1],"-")) {
-	load_stdin();
-    } else if (argc > 1) {
-	for (files = 0, i = 1; i < argc; i++) {
- 	    if (curl_is_url(argv[i])) {
-		list_append(argv[i]);
-		files++;
-		continue;
-	    }
-	    if (-1 == stat(argv[i],&st)) {
-		if (debug)
-		    fprintf(stderr,"stat %s: %s\n",argv[i],strerror(errno));
-		continue;
-	    }
-	    switch (st.st_mode & S_IFMT) {
-	    case S_IFDIR:
-		browser_window(argv[i]);
-		break;
-	    case S_IFREG:
-		list_append(argv[i]);
-		files++;
-		break;
-	    }
-	}
-	if (files) {
-	    list_update();
-	    next_ac(ida->widget,NULL,NULL,&zero);
-	}
-    }
-
-    if (NULL == ida->file)
-	load_logo();
-
-    XtAppMainLoop(app_context);
-    return 0; /* keep compiler happy */
-}
diff --git a/src/a2jpeg/ida.h b/src/a2jpeg/ida.h
deleted file mode 100644
index 7fa8b0a..0000000
--- a/src/a2jpeg/ida.h
+++ /dev/null
@@ -1,26 +0,0 @@
-struct ARGS {
-    Boolean        debug;
-    Boolean        help;
-    Boolean        testload;
-};
-
-extern struct ARGS        args;
-extern unsigned int       pcd_res;
-
-extern Widget             app_shell;
-extern XtAppContext       app_context;
-extern Display            *dpy;
-extern struct ida_viewer  *ida;
-
-void action_cb(Widget widget, XtPointer clientdata, XtPointer call_data);
-void destroy_cb(Widget widget, XtPointer clientdata, XtPointer call_data);
-
-void ptr_register(Widget widget);
-void ptr_unregister(Widget widget);
-void ptr_busy(void);
-void ptr_idle(void);
-
-void do_save_print(void);
-void resize_shell(void);
-char* load_tmpfile(char *base);
-void new_file(char *name, int complain);
diff --git a/src/a2jpeg/jinclude.h b/src/a2jpeg/jinclude.h
deleted file mode 100644
index 0a4f151..0000000
--- a/src/a2jpeg/jinclude.h
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
- * jinclude.h
- *
- * Copyright (C) 1991-1994, Thomas G. Lane.
- * This file is part of the Independent JPEG Group's software.
- * For conditions of distribution and use, see the accompanying README file.
- *
- * This file exists to provide a single place to fix any problems with
- * including the wrong system include files.  (Common problems are taken
- * care of by the standard jconfig symbols, but on really weird systems
- * you may have to edit this file.)
- *
- * NOTE: this file is NOT intended to be included by applications using the
- * JPEG library.  Most applications need only include jpeglib.h.
- */
-
-
-/* Include auto-config file to find out which system include files we need. */
-
-#include "jconfig.h"		/* auto configuration options */
-#define JCONFIG_INCLUDED	/* so that jpeglib.h doesn't do it again */
-
-/*
- * We need the NULL macro and size_t typedef.
- * On an ANSI-conforming system it is sufficient to include <stddef.h>.
- * Otherwise, we get them from <stdlib.h> or <stdio.h>; we may have to
- * pull in <sys/types.h> as well.
- * Note that the core JPEG library does not require <stdio.h>;
- * only the default error handler and data source/destination modules do.
- * But we must pull it in because of the references to FILE in jpeglib.h.
- * You can remove those references if you want to compile without <stdio.h>.
- */
-
-#ifdef HAVE_STDDEF_H
-#include <stddef.h>
-#endif
-
-#ifdef HAVE_STDLIB_H
-#include <stdlib.h>
-#endif
-
-#ifdef NEED_SYS_TYPES_H
-#include <sys/types.h>
-#endif
-
-#include <stdio.h>
-
-/*
- * We need memory copying and zeroing functions, plus strncpy().
- * ANSI and System V implementations declare these in <string.h>.
- * BSD doesn't have the mem() functions, but it does have bcopy()/bzero().
- * Some systems may declare memset and memcpy in <memory.h>.
- *
- * NOTE: we assume the size parameters to these functions are of type size_t.
- * Change the casts in these macros if not!
- */
-
-#ifdef NEED_BSD_STRINGS
-
-#include <strings.h>
-#define MEMZERO(target,size)	bzero((void *)(target), (size_t)(size))
-#define MEMCOPY(dest,src,size)	bcopy((const void *)(src), (void *)(dest), (size_t)(size))
-
-#else /* not BSD, assume ANSI/SysV string lib */
-
-#include <string.h>
-#define MEMZERO(target,size)	memset((void *)(target), 0, (size_t)(size))
-#define MEMCOPY(dest,src,size)	memcpy((void *)(dest), (const void *)(src), (size_t)(size))
-
-#endif
-
-/*
- * In ANSI C, and indeed any rational implementation, size_t is also the
- * type returned by sizeof().  However, it seems there are some irrational
- * implementations out there, in which sizeof() returns an int even though
- * size_t is defined as long or unsigned long.  To ensure consistent results
- * we always use this SIZEOF() macro in place of using sizeof() directly.
- */
-
-#define SIZEOF(object)	((size_t) sizeof(object))
-
-/*
- * The modules that use fread() and fwrite() always invoke them through
- * these macros.  On some systems you may need to twiddle the argument casts.
- * CAUTION: argument order is different from underlying functions!
- */
-
-#define JFREAD(file,buf,sizeofbuf)  \
-  ((size_t) fread((void *) (buf), (size_t) 1, (size_t) (sizeofbuf), (file)))
-#define JFWRITE(file,buf,sizeofbuf)  \
-  ((size_t) fwrite((const void *) (buf), (size_t) 1, (size_t) (sizeofbuf), (file)))
diff --git a/src/a2jpeg/jpegint.h b/src/a2jpeg/jpegint.h
deleted file mode 100644
index 95b00d4..0000000
--- a/src/a2jpeg/jpegint.h
+++ /dev/null
@@ -1,392 +0,0 @@
-/*
- * jpegint.h
- *
- * Copyright (C) 1991-1997, Thomas G. Lane.
- * This file is part of the Independent JPEG Group's software.
- * For conditions of distribution and use, see the accompanying README file.
- *
- * This file provides common declarations for the various JPEG modules.
- * These declarations are considered internal to the JPEG library; most
- * applications using the library shouldn't need to include this file.
- */
-
-
-/* Declarations for both compression & decompression */
-
-typedef enum {			/* Operating modes for buffer controllers */
-	JBUF_PASS_THRU,		/* Plain stripwise operation */
-	/* Remaining modes require a full-image buffer to have been created */
-	JBUF_SAVE_SOURCE,	/* Run source subobject only, save output */
-	JBUF_CRANK_DEST,	/* Run dest subobject only, using saved data */
-	JBUF_SAVE_AND_PASS	/* Run both subobjects, save output */
-} J_BUF_MODE;
-
-/* Values of global_state field (jdapi.c has some dependencies on ordering!) */
-#define CSTATE_START	100	/* after create_compress */
-#define CSTATE_SCANNING	101	/* start_compress done, write_scanlines OK */
-#define CSTATE_RAW_OK	102	/* start_compress done, write_raw_data OK */
-#define CSTATE_WRCOEFS	103	/* jpeg_write_coefficients done */
-#define DSTATE_START	200	/* after create_decompress */
-#define DSTATE_INHEADER	201	/* reading header markers, no SOS yet */
-#define DSTATE_READY	202	/* found SOS, ready for start_decompress */
-#define DSTATE_PRELOAD	203	/* reading multiscan file in start_decompress*/
-#define DSTATE_PRESCAN	204	/* performing dummy pass for 2-pass quant */
-#define DSTATE_SCANNING	205	/* start_decompress done, read_scanlines OK */
-#define DSTATE_RAW_OK	206	/* start_decompress done, read_raw_data OK */
-#define DSTATE_BUFIMAGE	207	/* expecting jpeg_start_output */
-#define DSTATE_BUFPOST	208	/* looking for SOS/EOI in jpeg_finish_output */
-#define DSTATE_RDCOEFS	209	/* reading file in jpeg_read_coefficients */
-#define DSTATE_STOPPING	210	/* looking for EOI in jpeg_finish_decompress */
-
-
-/* Declarations for compression modules */
-
-/* Master control module */
-struct jpeg_comp_master {
-  JMETHOD(void, prepare_for_pass, (j_compress_ptr cinfo));
-  JMETHOD(void, pass_startup, (j_compress_ptr cinfo));
-  JMETHOD(void, finish_pass, (j_compress_ptr cinfo));
-
-  /* State variables made visible to other modules */
-  boolean call_pass_startup;	/* True if pass_startup must be called */
-  boolean is_last_pass;		/* True during last pass */
-};
-
-/* Main buffer control (downsampled-data buffer) */
-struct jpeg_c_main_controller {
-  JMETHOD(void, start_pass, (j_compress_ptr cinfo, J_BUF_MODE pass_mode));
-  JMETHOD(void, process_data, (j_compress_ptr cinfo,
-			       JSAMPARRAY input_buf, JDIMENSION *in_row_ctr,
-			       JDIMENSION in_rows_avail));
-};
-
-/* Compression preprocessing (downsampling input buffer control) */
-struct jpeg_c_prep_controller {
-  JMETHOD(void, start_pass, (j_compress_ptr cinfo, J_BUF_MODE pass_mode));
-  JMETHOD(void, pre_process_data, (j_compress_ptr cinfo,
-				   JSAMPARRAY input_buf,
-				   JDIMENSION *in_row_ctr,
-				   JDIMENSION in_rows_avail,
-				   JSAMPIMAGE output_buf,
-				   JDIMENSION *out_row_group_ctr,
-				   JDIMENSION out_row_groups_avail));
-};
-
-/* Coefficient buffer control */
-struct jpeg_c_coef_controller {
-  JMETHOD(void, start_pass, (j_compress_ptr cinfo, J_BUF_MODE pass_mode));
-  JMETHOD(boolean, compress_data, (j_compress_ptr cinfo,
-				   JSAMPIMAGE input_buf));
-};
-
-/* Colorspace conversion */
-struct jpeg_color_converter {
-  JMETHOD(void, start_pass, (j_compress_ptr cinfo));
-  JMETHOD(void, color_convert, (j_compress_ptr cinfo,
-				JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
-				JDIMENSION output_row, int num_rows));
-};
-
-/* Downsampling */
-struct jpeg_downsampler {
-  JMETHOD(void, start_pass, (j_compress_ptr cinfo));
-  JMETHOD(void, downsample, (j_compress_ptr cinfo,
-			     JSAMPIMAGE input_buf, JDIMENSION in_row_index,
-			     JSAMPIMAGE output_buf,
-			     JDIMENSION out_row_group_index));
-
-  boolean need_context_rows;	/* TRUE if need rows above & below */
-};
-
-/* Forward DCT (also controls coefficient quantization) */
-struct jpeg_forward_dct {
-  JMETHOD(void, start_pass, (j_compress_ptr cinfo));
-  /* perhaps this should be an array??? */
-  JMETHOD(void, forward_DCT, (j_compress_ptr cinfo,
-			      jpeg_component_info * compptr,
-			      JSAMPARRAY sample_data, JBLOCKROW coef_blocks,
-			      JDIMENSION start_row, JDIMENSION start_col,
-			      JDIMENSION num_blocks));
-};
-
-/* Entropy encoding */
-struct jpeg_entropy_encoder {
-  JMETHOD(void, start_pass, (j_compress_ptr cinfo, boolean gather_statistics));
-  JMETHOD(boolean, encode_mcu, (j_compress_ptr cinfo, JBLOCKROW *MCU_data));
-  JMETHOD(void, finish_pass, (j_compress_ptr cinfo));
-};
-
-/* Marker writing */
-struct jpeg_marker_writer {
-  JMETHOD(void, write_file_header, (j_compress_ptr cinfo));
-  JMETHOD(void, write_frame_header, (j_compress_ptr cinfo));
-  JMETHOD(void, write_scan_header, (j_compress_ptr cinfo));
-  JMETHOD(void, write_file_trailer, (j_compress_ptr cinfo));
-  JMETHOD(void, write_tables_only, (j_compress_ptr cinfo));
-  /* These routines are exported to allow insertion of extra markers */
-  /* Probably only COM and APPn markers should be written this way */
-  JMETHOD(void, write_marker_header, (j_compress_ptr cinfo, int marker,
-				      unsigned int datalen));
-  JMETHOD(void, write_marker_byte, (j_compress_ptr cinfo, int val));
-};
-
-
-/* Declarations for decompression modules */
-
-/* Master control module */
-struct jpeg_decomp_master {
-  JMETHOD(void, prepare_for_output_pass, (j_decompress_ptr cinfo));
-  JMETHOD(void, finish_output_pass, (j_decompress_ptr cinfo));
-
-  /* State variables made visible to other modules */
-  boolean is_dummy_pass;	/* True during 1st pass for 2-pass quant */
-};
-
-/* Input control module */
-struct jpeg_input_controller {
-  JMETHOD(int, consume_input, (j_decompress_ptr cinfo));
-  JMETHOD(void, reset_input_controller, (j_decompress_ptr cinfo));
-  JMETHOD(void, start_input_pass, (j_decompress_ptr cinfo));
-  JMETHOD(void, finish_input_pass, (j_decompress_ptr cinfo));
-
-  /* State variables made visible to other modules */
-  boolean has_multiple_scans;	/* True if file has multiple scans */
-  boolean eoi_reached;		/* True when EOI has been consumed */
-};
-
-/* Main buffer control (downsampled-data buffer) */
-struct jpeg_d_main_controller {
-  JMETHOD(void, start_pass, (j_decompress_ptr cinfo, J_BUF_MODE pass_mode));
-  JMETHOD(void, process_data, (j_decompress_ptr cinfo,
-			       JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
-			       JDIMENSION out_rows_avail));
-};
-
-/* Coefficient buffer control */
-struct jpeg_d_coef_controller {
-  JMETHOD(void, start_input_pass, (j_decompress_ptr cinfo));
-  JMETHOD(int, consume_data, (j_decompress_ptr cinfo));
-  JMETHOD(void, start_output_pass, (j_decompress_ptr cinfo));
-  JMETHOD(int, decompress_data, (j_decompress_ptr cinfo,
-				 JSAMPIMAGE output_buf));
-  /* Pointer to array of coefficient virtual arrays, or NULL if none */
-  jvirt_barray_ptr *coef_arrays;
-};
-
-/* Decompression postprocessing (color quantization buffer control) */
-struct jpeg_d_post_controller {
-  JMETHOD(void, start_pass, (j_decompress_ptr cinfo, J_BUF_MODE pass_mode));
-  JMETHOD(void, post_process_data, (j_decompress_ptr cinfo,
-				    JSAMPIMAGE input_buf,
-				    JDIMENSION *in_row_group_ctr,
-				    JDIMENSION in_row_groups_avail,
-				    JSAMPARRAY output_buf,
-				    JDIMENSION *out_row_ctr,
-				    JDIMENSION out_rows_avail));
-};
-
-/* Marker reading & parsing */
-struct jpeg_marker_reader {
-  JMETHOD(void, reset_marker_reader, (j_decompress_ptr cinfo));
-  /* Read markers until SOS or EOI.
-   * Returns same codes as are defined for jpeg_consume_input:
-   * JPEG_SUSPENDED, JPEG_REACHED_SOS, or JPEG_REACHED_EOI.
-   */
-  JMETHOD(int, read_markers, (j_decompress_ptr cinfo));
-  /* Read a restart marker --- exported for use by entropy decoder only */
-  jpeg_marker_parser_method read_restart_marker;
-
-  /* State of marker reader --- nominally internal, but applications
-   * supplying COM or APPn handlers might like to know the state.
-   */
-  boolean saw_SOI;		/* found SOI? */
-  boolean saw_SOF;		/* found SOF? */
-  int next_restart_num;		/* next restart number expected (0-7) */
-  unsigned int discarded_bytes;	/* # of bytes skipped looking for a marker */
-};
-
-/* Entropy decoding */
-struct jpeg_entropy_decoder {
-  JMETHOD(void, start_pass, (j_decompress_ptr cinfo));
-  JMETHOD(boolean, decode_mcu, (j_decompress_ptr cinfo,
-				JBLOCKROW *MCU_data));
-
-  /* This is here to share code between baseline and progressive decoders; */
-  /* other modules probably should not use it */
-  boolean insufficient_data;	/* set TRUE after emitting warning */
-};
-
-/* Inverse DCT (also performs dequantization) */
-typedef JMETHOD(void, inverse_DCT_method_ptr,
-		(j_decompress_ptr cinfo, jpeg_component_info * compptr,
-		 JCOEFPTR coef_block,
-		 JSAMPARRAY output_buf, JDIMENSION output_col));
-
-struct jpeg_inverse_dct {
-  JMETHOD(void, start_pass, (j_decompress_ptr cinfo));
-  /* It is useful to allow each component to have a separate IDCT method. */
-  inverse_DCT_method_ptr inverse_DCT[MAX_COMPONENTS];
-};
-
-/* Upsampling (note that upsampler must also call color converter) */
-struct jpeg_upsampler {
-  JMETHOD(void, start_pass, (j_decompress_ptr cinfo));
-  JMETHOD(void, upsample, (j_decompress_ptr cinfo,
-			   JSAMPIMAGE input_buf,
-			   JDIMENSION *in_row_group_ctr,
-			   JDIMENSION in_row_groups_avail,
-			   JSAMPARRAY output_buf,
-			   JDIMENSION *out_row_ctr,
-			   JDIMENSION out_rows_avail));
-
-  boolean need_context_rows;	/* TRUE if need rows above & below */
-};
-
-/* Colorspace conversion */
-struct jpeg_color_deconverter {
-  JMETHOD(void, start_pass, (j_decompress_ptr cinfo));
-  JMETHOD(void, color_convert, (j_decompress_ptr cinfo,
-				JSAMPIMAGE input_buf, JDIMENSION input_row,
-				JSAMPARRAY output_buf, int num_rows));
-};
-
-/* Color quantization or color precision reduction */
-struct jpeg_color_quantizer {
-  JMETHOD(void, start_pass, (j_decompress_ptr cinfo, boolean is_pre_scan));
-  JMETHOD(void, color_quantize, (j_decompress_ptr cinfo,
-				 JSAMPARRAY input_buf, JSAMPARRAY output_buf,
-				 int num_rows));
-  JMETHOD(void, finish_pass, (j_decompress_ptr cinfo));
-  JMETHOD(void, new_color_map, (j_decompress_ptr cinfo));
-};
-
-
-/* Miscellaneous useful macros */
-
-#undef MAX
-#define MAX(a,b)	((a) > (b) ? (a) : (b))
-#undef MIN
-#define MIN(a,b)	((a) < (b) ? (a) : (b))
-
-
-/* We assume that right shift corresponds to signed division by 2 with
- * rounding towards minus infinity.  This is correct for typical "arithmetic
- * shift" instructions that shift in copies of the sign bit.  But some
- * C compilers implement >> with an unsigned shift.  For these machines you
- * must define RIGHT_SHIFT_IS_UNSIGNED.
- * RIGHT_SHIFT provides a proper signed right shift of an INT32 quantity.
- * It is only applied with constant shift counts.  SHIFT_TEMPS must be
- * included in the variables of any routine using RIGHT_SHIFT.
- */
-
-#ifdef RIGHT_SHIFT_IS_UNSIGNED
-#define SHIFT_TEMPS	INT32 shift_temp;
-#define RIGHT_SHIFT(x,shft)  \
-	((shift_temp = (x)) < 0 ? \
-	 (shift_temp >> (shft)) | ((~((INT32) 0)) << (32-(shft))) : \
-	 (shift_temp >> (shft)))
-#else
-#define SHIFT_TEMPS
-#define RIGHT_SHIFT(x,shft)	((x) >> (shft))
-#endif
-
-
-/* Short forms of external names for systems with brain-damaged linkers. */
-
-#ifdef NEED_SHORT_EXTERNAL_NAMES
-#define jinit_compress_master	jICompress
-#define jinit_c_master_control	jICMaster
-#define jinit_c_main_controller	jICMainC
-#define jinit_c_prep_controller	jICPrepC
-#define jinit_c_coef_controller	jICCoefC
-#define jinit_color_converter	jICColor
-#define jinit_downsampler	jIDownsampler
-#define jinit_forward_dct	jIFDCT
-#define jinit_huff_encoder	jIHEncoder
-#define jinit_phuff_encoder	jIPHEncoder
-#define jinit_marker_writer	jIMWriter
-#define jinit_master_decompress	jIDMaster
-#define jinit_d_main_controller	jIDMainC
-#define jinit_d_coef_controller	jIDCoefC
-#define jinit_d_post_controller	jIDPostC
-#define jinit_input_controller	jIInCtlr
-#define jinit_marker_reader	jIMReader
-#define jinit_huff_decoder	jIHDecoder
-#define jinit_phuff_decoder	jIPHDecoder
-#define jinit_inverse_dct	jIIDCT
-#define jinit_upsampler		jIUpsampler
-#define jinit_color_deconverter	jIDColor
-#define jinit_1pass_quantizer	jI1Quant
-#define jinit_2pass_quantizer	jI2Quant
-#define jinit_merged_upsampler	jIMUpsampler
-#define jinit_memory_mgr	jIMemMgr
-#define jdiv_round_up		jDivRound
-#define jround_up		jRound
-#define jcopy_sample_rows	jCopySamples
-#define jcopy_block_row		jCopyBlocks
-#define jzero_far		jZeroFar
-#define jpeg_zigzag_order	jZIGTable
-#define jpeg_natural_order	jZAGTable
-#endif /* NEED_SHORT_EXTERNAL_NAMES */
-
-
-/* Compression module initialization routines */
-EXTERN(void) jinit_compress_master JPP((j_compress_ptr cinfo));
-EXTERN(void) jinit_c_master_control JPP((j_compress_ptr cinfo,
-					 boolean transcode_only));
-EXTERN(void) jinit_c_main_controller JPP((j_compress_ptr cinfo,
-					  boolean need_full_buffer));
-EXTERN(void) jinit_c_prep_controller JPP((j_compress_ptr cinfo,
-					  boolean need_full_buffer));
-EXTERN(void) jinit_c_coef_controller JPP((j_compress_ptr cinfo,
-					  boolean need_full_buffer));
-EXTERN(void) jinit_color_converter JPP((j_compress_ptr cinfo));
-EXTERN(void) jinit_downsampler JPP((j_compress_ptr cinfo));
-EXTERN(void) jinit_forward_dct JPP((j_compress_ptr cinfo));
-EXTERN(void) jinit_huff_encoder JPP((j_compress_ptr cinfo));
-EXTERN(void) jinit_phuff_encoder JPP((j_compress_ptr cinfo));
-EXTERN(void) jinit_marker_writer JPP((j_compress_ptr cinfo));
-/* Decompression module initialization routines */
-EXTERN(void) jinit_master_decompress JPP((j_decompress_ptr cinfo));
-EXTERN(void) jinit_d_main_controller JPP((j_decompress_ptr cinfo,
-					  boolean need_full_buffer));
-EXTERN(void) jinit_d_coef_controller JPP((j_decompress_ptr cinfo,
-					  boolean need_full_buffer));
-EXTERN(void) jinit_d_post_controller JPP((j_decompress_ptr cinfo,
-					  boolean need_full_buffer));
-EXTERN(void) jinit_input_controller JPP((j_decompress_ptr cinfo));
-EXTERN(void) jinit_marker_reader JPP((j_decompress_ptr cinfo));
-EXTERN(void) jinit_huff_decoder JPP((j_decompress_ptr cinfo));
-EXTERN(void) jinit_phuff_decoder JPP((j_decompress_ptr cinfo));
-EXTERN(void) jinit_inverse_dct JPP((j_decompress_ptr cinfo));
-EXTERN(void) jinit_upsampler JPP((j_decompress_ptr cinfo));
-EXTERN(void) jinit_color_deconverter JPP((j_decompress_ptr cinfo));
-EXTERN(void) jinit_1pass_quantizer JPP((j_decompress_ptr cinfo));
-EXTERN(void) jinit_2pass_quantizer JPP((j_decompress_ptr cinfo));
-EXTERN(void) jinit_merged_upsampler JPP((j_decompress_ptr cinfo));
-/* Memory manager initialization */
-EXTERN(void) jinit_memory_mgr JPP((j_common_ptr cinfo));
-
-/* Utility routines in jutils.c */
-EXTERN(long) jdiv_round_up JPP((long a, long b));
-EXTERN(long) jround_up JPP((long a, long b));
-EXTERN(void) jcopy_sample_rows JPP((JSAMPARRAY input_array, int source_row,
-				    JSAMPARRAY output_array, int dest_row,
-				    int num_rows, JDIMENSION num_cols));
-EXTERN(void) jcopy_block_row JPP((JBLOCKROW input_row, JBLOCKROW output_row,
-				  JDIMENSION num_blocks));
-EXTERN(void) jzero_far JPP((void FAR * target, size_t bytestozero));
-/* Constant tables in jutils.c */
-#if 0				/* This table is not actually needed in v6a */
-extern const int jpeg_zigzag_order[]; /* natural coef order to zigzag order */
-#endif
-extern const int jpeg_natural_order[]; /* zigzag coef order to natural order */
-
-/* Suppress undefined-structure complaints if necessary. */
-
-#ifdef INCOMPLETE_TYPES_BROKEN
-#ifndef AM_MEMORY_MANAGER	/* only jmemmgr.c defines these */
-struct jvirt_sarray_control { long dummy; };
-struct jvirt_barray_control { long dummy; };
-#endif
-#endif /* INCOMPLETE_TYPES_BROKEN */
diff --git a/src/a2jpeg/jpeglib.h b/src/a2jpeg/jpeglib.h
deleted file mode 100644
index d1be8dd..0000000
--- a/src/a2jpeg/jpeglib.h
+++ /dev/null
@@ -1,1096 +0,0 @@
-/*
- * jpeglib.h
- *
- * Copyright (C) 1991-1998, Thomas G. Lane.
- * This file is part of the Independent JPEG Group's software.
- * For conditions of distribution and use, see the accompanying README file.
- *
- * This file defines the application interface for the JPEG library.
- * Most applications using the library need only include this file,
- * and perhaps jerror.h if they want to know the exact error codes.
- */
-
-#ifndef JPEGLIB_H
-#define JPEGLIB_H
-
-/*
- * First we include the configuration files that record how this
- * installation of the JPEG library is set up.  jconfig.h can be
- * generated automatically for many systems.  jmorecfg.h contains
- * manual configuration options that most people need not worry about.
- */
-
-#ifndef JCONFIG_INCLUDED	/* in case jinclude.h already did */
-#include "jconfig.h"		/* widely used configuration options */
-#endif
-#include "jmorecfg.h"		/* seldom changed options */
-
-
-/* Version ID for the JPEG library.
- * Might be useful for tests like "#if JPEG_LIB_VERSION >= 60".
- */
-
-#define JPEG_LIB_VERSION  62	/* Version 6b */
-
-
-/* Various constants determining the sizes of things.
- * All of these are specified by the JPEG standard, so don't change them
- * if you want to be compatible.
- */
-
-#define DCTSIZE		    8	/* The basic DCT block is 8x8 samples */
-#define DCTSIZE2	    64	/* DCTSIZE squared; # of elements in a block */
-#define NUM_QUANT_TBLS      4	/* Quantization tables are numbered 0..3 */
-#define NUM_HUFF_TBLS       4	/* Huffman tables are numbered 0..3 */
-#define NUM_ARITH_TBLS      16	/* Arith-coding tables are numbered 0..15 */
-#define MAX_COMPS_IN_SCAN   4	/* JPEG limit on # of components in one scan */
-#define MAX_SAMP_FACTOR     4	/* JPEG limit on sampling factors */
-/* Unfortunately, some bozo at Adobe saw no reason to be bound by the standard;
- * the PostScript DCT filter can emit files with many more than 10 blocks/MCU.
- * If you happen to run across such a file, you can up D_MAX_BLOCKS_IN_MCU
- * to handle it.  We even let you do this from the jconfig.h file.  However,
- * we strongly discourage changing C_MAX_BLOCKS_IN_MCU; just because Adobe
- * sometimes emits noncompliant files doesn't mean you should too.
- */
-#define C_MAX_BLOCKS_IN_MCU   10 /* compressor's limit on blocks per MCU */
-#ifndef D_MAX_BLOCKS_IN_MCU
-#define D_MAX_BLOCKS_IN_MCU   10 /* decompressor's limit on blocks per MCU */
-#endif
-
-
-/* Data structures for images (arrays of samples and of DCT coefficients).
- * On 80x86 machines, the image arrays are too big for near pointers,
- * but the pointer arrays can fit in near memory.
- */
-
-typedef JSAMPLE FAR *JSAMPROW;	/* ptr to one image row of pixel samples. */
-typedef JSAMPROW *JSAMPARRAY;	/* ptr to some rows (a 2-D sample array) */
-typedef JSAMPARRAY *JSAMPIMAGE;	/* a 3-D sample array: top index is color */
-
-typedef JCOEF JBLOCK[DCTSIZE2];	/* one block of coefficients */
-typedef JBLOCK FAR *JBLOCKROW;	/* pointer to one row of coefficient blocks */
-typedef JBLOCKROW *JBLOCKARRAY;		/* a 2-D array of coefficient blocks */
-typedef JBLOCKARRAY *JBLOCKIMAGE;	/* a 3-D array of coefficient blocks */
-
-typedef JCOEF FAR *JCOEFPTR;	/* useful in a couple of places */
-
-
-/* Types for JPEG compression parameters and working tables. */
-
-
-/* DCT coefficient quantization tables. */
-
-typedef struct {
-  /* This array gives the coefficient quantizers in natural array order
-   * (not the zigzag order in which they are stored in a JPEG DQT marker).
-   * CAUTION: IJG versions prior to v6a kept this array in zigzag order.
-   */
-  UINT16 quantval[DCTSIZE2];	/* quantization step for each coefficient */
-  /* This field is used only during compression.  It's initialized FALSE when
-   * the table is created, and set TRUE when it's been output to the file.
-   * You could suppress output of a table by setting this to TRUE.
-   * (See jpeg_suppress_tables for an example.)
-   */
-  boolean sent_table;		/* TRUE when table has been output */
-} JQUANT_TBL;
-
-
-/* Huffman coding tables. */
-
-typedef struct {
-  /* These two fields directly represent the contents of a JPEG DHT marker */
-  UINT8 bits[17];		/* bits[k] = # of symbols with codes of */
-				/* length k bits; bits[0] is unused */
-  UINT8 huffval[256];		/* The symbols, in order of incr code length */
-  /* This field is used only during compression.  It's initialized FALSE when
-   * the table is created, and set TRUE when it's been output to the file.
-   * You could suppress output of a table by setting this to TRUE.
-   * (See jpeg_suppress_tables for an example.)
-   */
-  boolean sent_table;		/* TRUE when table has been output */
-} JHUFF_TBL;
-
-
-/* Basic info about one component (color channel). */
-
-typedef struct {
-  /* These values are fixed over the whole image. */
-  /* For compression, they must be supplied by parameter setup; */
-  /* for decompression, they are read from the SOF marker. */
-  int component_id;		/* identifier for this component (0..255) */
-  int component_index;		/* its index in SOF or cinfo->comp_info[] */
-  int h_samp_factor;		/* horizontal sampling factor (1..4) */
-  int v_samp_factor;		/* vertical sampling factor (1..4) */
-  int quant_tbl_no;		/* quantization table selector (0..3) */
-  /* These values may vary between scans. */
-  /* For compression, they must be supplied by parameter setup; */
-  /* for decompression, they are read from the SOS marker. */
-  /* The decompressor output side may not use these variables. */
-  int dc_tbl_no;		/* DC entropy table selector (0..3) */
-  int ac_tbl_no;		/* AC entropy table selector (0..3) */
-  
-  /* Remaining fields should be treated as private by applications. */
-  
-  /* These values are computed during compression or decompression startup: */
-  /* Component's size in DCT blocks.
-   * Any dummy blocks added to complete an MCU are not counted; therefore
-   * these values do not depend on whether a scan is interleaved or not.
-   */
-  JDIMENSION width_in_blocks;
-  JDIMENSION height_in_blocks;
-  /* Size of a DCT block in samples.  Always DCTSIZE for compression.
-   * For decompression this is the size of the output from one DCT block,
-   * reflecting any scaling we choose to apply during the IDCT step.
-   * Values of 1,2,4,8 are likely to be supported.  Note that different
-   * components may receive different IDCT scalings.
-   */
-  int DCT_scaled_size;
-  /* The downsampled dimensions are the component's actual, unpadded number
-   * of samples at the main buffer (preprocessing/compression interface), thus
-   * downsampled_width = ceil(image_width * Hi/Hmax)
-   * and similarly for height.  For decompression, IDCT scaling is included, so
-   * downsampled_width = ceil(image_width * Hi/Hmax * DCT_scaled_size/DCTSIZE)
-   */
-  JDIMENSION downsampled_width;	 /* actual width in samples */
-  JDIMENSION downsampled_height; /* actual height in samples */
-  /* This flag is used only for decompression.  In cases where some of the
-   * components will be ignored (eg grayscale output from YCbCr image),
-   * we can skip most computations for the unused components.
-   */
-  boolean component_needed;	/* do we need the value of this component? */
-
-  /* These values are computed before starting a scan of the component. */
-  /* The decompressor output side may not use these variables. */
-  int MCU_width;		/* number of blocks per MCU, horizontally */
-  int MCU_height;		/* number of blocks per MCU, vertically */
-  int MCU_blocks;		/* MCU_width * MCU_height */
-  int MCU_sample_width;		/* MCU width in samples, MCU_width*DCT_scaled_size */
-  int last_col_width;		/* # of non-dummy blocks across in last MCU */
-  int last_row_height;		/* # of non-dummy blocks down in last MCU */
-
-  /* Saved quantization table for component; NULL if none yet saved.
-   * See jdinput.c comments about the need for this information.
-   * This field is currently used only for decompression.
-   */
-  JQUANT_TBL * quant_table;
-
-  /* Private per-component storage for DCT or IDCT subsystem. */
-  void * dct_table;
-} jpeg_component_info;
-
-
-/* The script for encoding a multiple-scan file is an array of these: */
-
-typedef struct {
-  int comps_in_scan;		/* number of components encoded in this scan */
-  int component_index[MAX_COMPS_IN_SCAN]; /* their SOF/comp_info[] indexes */
-  int Ss, Se;			/* progressive JPEG spectral selection parms */
-  int Ah, Al;			/* progressive JPEG successive approx. parms */
-} jpeg_scan_info;
-
-/* The decompressor can save APPn and COM markers in a list of these: */
-
-typedef struct jpeg_marker_struct FAR * jpeg_saved_marker_ptr;
-
-struct jpeg_marker_struct {
-  jpeg_saved_marker_ptr next;	/* next in list, or NULL */
-  UINT8 marker;			/* marker code: JPEG_COM, or JPEG_APP0+n */
-  unsigned int original_length;	/* # bytes of data in the file */
-  unsigned int data_length;	/* # bytes of data saved at data[] */
-  JOCTET FAR * data;		/* the data contained in the marker */
-  /* the marker length word is not counted in data_length or original_length */
-};
-
-/* Known color spaces. */
-
-typedef enum {
-	JCS_UNKNOWN,		/* error/unspecified */
-	JCS_GRAYSCALE,		/* monochrome */
-	JCS_RGB,		/* red/green/blue */
-	JCS_YCbCr,		/* Y/Cb/Cr (also known as YUV) */
-	JCS_CMYK,		/* C/M/Y/K */
-	JCS_YCCK		/* Y/Cb/Cr/K */
-} J_COLOR_SPACE;
-
-/* DCT/IDCT algorithm options. */
-
-typedef enum {
-	JDCT_ISLOW,		/* slow but accurate integer algorithm */
-	JDCT_IFAST,		/* faster, less accurate integer method */
-	JDCT_FLOAT		/* floating-point: accurate, fast on fast HW */
-} J_DCT_METHOD;
-
-#ifndef JDCT_DEFAULT		/* may be overridden in jconfig.h */
-#define JDCT_DEFAULT  JDCT_ISLOW
-#endif
-#ifndef JDCT_FASTEST		/* may be overridden in jconfig.h */
-#define JDCT_FASTEST  JDCT_IFAST
-#endif
-
-/* Dithering options for decompression. */
-
-typedef enum {
-	JDITHER_NONE,		/* no dithering */
-	JDITHER_ORDERED,	/* simple ordered dither */
-	JDITHER_FS		/* Floyd-Steinberg error diffusion dither */
-} J_DITHER_MODE;
-
-
-/* Common fields between JPEG compression and decompression master structs. */
-
-#define jpeg_common_fields \
-  struct jpeg_error_mgr * err;	/* Error handler module */\
-  struct jpeg_memory_mgr * mem;	/* Memory manager module */\
-  struct jpeg_progress_mgr * progress; /* Progress monitor, or NULL if none */\
-  void * client_data;		/* Available for use by application */\
-  boolean is_decompressor;	/* So common code can tell which is which */\
-  int global_state		/* For checking call sequence validity */
-
-/* Routines that are to be used by both halves of the library are declared
- * to receive a pointer to this structure.  There are no actual instances of
- * jpeg_common_struct, only of jpeg_compress_struct and jpeg_decompress_struct.
- */
-struct jpeg_common_struct {
-  jpeg_common_fields;		/* Fields common to both master struct types */
-  /* Additional fields follow in an actual jpeg_compress_struct or
-   * jpeg_decompress_struct.  All three structs must agree on these
-   * initial fields!  (This would be a lot cleaner in C++.)
-   */
-};
-
-typedef struct jpeg_common_struct * j_common_ptr;
-typedef struct jpeg_compress_struct * j_compress_ptr;
-typedef struct jpeg_decompress_struct * j_decompress_ptr;
-
-
-/* Master record for a compression instance */
-
-struct jpeg_compress_struct {
-  jpeg_common_fields;		/* Fields shared with jpeg_decompress_struct */
-
-  /* Destination for compressed data */
-  struct jpeg_destination_mgr * dest;
-
-  /* Description of source image --- these fields must be filled in by
-   * outer application before starting compression.  in_color_space must
-   * be correct before you can even call jpeg_set_defaults().
-   */
-
-  JDIMENSION image_width;	/* input image width */
-  JDIMENSION image_height;	/* input image height */
-  int input_components;		/* # of color components in input image */
-  J_COLOR_SPACE in_color_space;	/* colorspace of input image */
-
-  double input_gamma;		/* image gamma of input image */
-
-  /* Compression parameters --- these fields must be set before calling
-   * jpeg_start_compress().  We recommend calling jpeg_set_defaults() to
-   * initialize everything to reasonable defaults, then changing anything
-   * the application specifically wants to change.  That way you won't get
-   * burnt when new parameters are added.  Also note that there are several
-   * helper routines to simplify changing parameters.
-   */
-
-  int data_precision;		/* bits of precision in image data */
-
-  int num_components;		/* # of color components in JPEG image */
-  J_COLOR_SPACE jpeg_color_space; /* colorspace of JPEG image */
-
-  jpeg_component_info * comp_info;
-  /* comp_info[i] describes component that appears i'th in SOF */
-  
-  JQUANT_TBL * quant_tbl_ptrs[NUM_QUANT_TBLS];
-  /* ptrs to coefficient quantization tables, or NULL if not defined */
-  
-  JHUFF_TBL * dc_huff_tbl_ptrs[NUM_HUFF_TBLS];
-  JHUFF_TBL * ac_huff_tbl_ptrs[NUM_HUFF_TBLS];
-  /* ptrs to Huffman coding tables, or NULL if not defined */
-  
-  UINT8 arith_dc_L[NUM_ARITH_TBLS]; /* L values for DC arith-coding tables */
-  UINT8 arith_dc_U[NUM_ARITH_TBLS]; /* U values for DC arith-coding tables */
-  UINT8 arith_ac_K[NUM_ARITH_TBLS]; /* Kx values for AC arith-coding tables */
-
-  int num_scans;		/* # of entries in scan_info array */
-  const jpeg_scan_info * scan_info; /* script for multi-scan file, or NULL */
-  /* The default value of scan_info is NULL, which causes a single-scan
-   * sequential JPEG file to be emitted.  To create a multi-scan file,
-   * set num_scans and scan_info to point to an array of scan definitions.
-   */
-
-  boolean raw_data_in;		/* TRUE=caller supplies downsampled data */
-  boolean arith_code;		/* TRUE=arithmetic coding, FALSE=Huffman */
-  boolean optimize_coding;	/* TRUE=optimize entropy encoding parms */
-  boolean CCIR601_sampling;	/* TRUE=first samples are cosited */
-  int smoothing_factor;		/* 1..100, or 0 for no input smoothing */
-  J_DCT_METHOD dct_method;	/* DCT algorithm selector */
-
-  /* The restart interval can be specified in absolute MCUs by setting
-   * restart_interval, or in MCU rows by setting restart_in_rows
-   * (in which case the correct restart_interval will be figured
-   * for each scan).
-   */
-  unsigned int restart_interval; /* MCUs per restart, or 0 for no restart */
-  int restart_in_rows;		/* if > 0, MCU rows per restart interval */
-
-  /* Parameters controlling emission of special markers. */
-
-  boolean write_JFIF_header;	/* should a JFIF marker be written? */
-  UINT8 JFIF_major_version;	/* What to write for the JFIF version number */
-  UINT8 JFIF_minor_version;
-  /* These three values are not used by the JPEG code, merely copied */
-  /* into the JFIF APP0 marker.  density_unit can be 0 for unknown, */
-  /* 1 for dots/inch, or 2 for dots/cm.  Note that the pixel aspect */
-  /* ratio is defined by X_density/Y_density even when density_unit=0. */
-  UINT8 density_unit;		/* JFIF code for pixel size units */
-  UINT16 X_density;		/* Horizontal pixel density */
-  UINT16 Y_density;		/* Vertical pixel density */
-  boolean write_Adobe_marker;	/* should an Adobe marker be written? */
-  
-  /* State variable: index of next scanline to be written to
-   * jpeg_write_scanlines().  Application may use this to control its
-   * processing loop, e.g., "while (next_scanline < image_height)".
-   */
-
-  JDIMENSION next_scanline;	/* 0 .. image_height-1  */
-
-  /* Remaining fields are known throughout compressor, but generally
-   * should not be touched by a surrounding application.
-   */
-
-  /*
-   * These fields are computed during compression startup
-   */
-  boolean progressive_mode;	/* TRUE if scan script uses progressive mode */
-  int max_h_samp_factor;	/* largest h_samp_factor */
-  int max_v_samp_factor;	/* largest v_samp_factor */
-
-  JDIMENSION total_iMCU_rows;	/* # of iMCU rows to be input to coef ctlr */
-  /* The coefficient controller receives data in units of MCU rows as defined
-   * for fully interleaved scans (whether the JPEG file is interleaved or not).
-   * There are v_samp_factor * DCTSIZE sample rows of each component in an
-   * "iMCU" (interleaved MCU) row.
-   */
-  
-  /*
-   * These fields are valid during any one scan.
-   * They describe the components and MCUs actually appearing in the scan.
-   */
-  int comps_in_scan;		/* # of JPEG components in this scan */
-  jpeg_component_info * cur_comp_info[MAX_COMPS_IN_SCAN];
-  /* *cur_comp_info[i] describes component that appears i'th in SOS */
-  
-  JDIMENSION MCUs_per_row;	/* # of MCUs across the image */
-  JDIMENSION MCU_rows_in_scan;	/* # of MCU rows in the image */
-  
-  int blocks_in_MCU;		/* # of DCT blocks per MCU */
-  int MCU_membership[C_MAX_BLOCKS_IN_MCU];
-  /* MCU_membership[i] is index in cur_comp_info of component owning */
-  /* i'th block in an MCU */
-
-  int Ss, Se, Ah, Al;		/* progressive JPEG parameters for scan */
-
-  /*
-   * Links to compression subobjects (methods and private variables of modules)
-   */
-  struct jpeg_comp_master * master;
-  struct jpeg_c_main_controller * main;
-  struct jpeg_c_prep_controller * prep;
-  struct jpeg_c_coef_controller * coef;
-  struct jpeg_marker_writer * marker;
-  struct jpeg_color_converter * cconvert;
-  struct jpeg_downsampler * downsample;
-  struct jpeg_forward_dct * fdct;
-  struct jpeg_entropy_encoder * entropy;
-  jpeg_scan_info * script_space; /* workspace for jpeg_simple_progression */
-  int script_space_size;
-};
-
-
-/* Master record for a decompression instance */
-
-struct jpeg_decompress_struct {
-  jpeg_common_fields;		/* Fields shared with jpeg_compress_struct */
-
-  /* Source of compressed data */
-  struct jpeg_source_mgr * src;
-
-  /* Basic description of image --- filled in by jpeg_read_header(). */
-  /* Application may inspect these values to decide how to process image. */
-
-  JDIMENSION image_width;	/* nominal image width (from SOF marker) */
-  JDIMENSION image_height;	/* nominal image height */
-  int num_components;		/* # of color components in JPEG image */
-  J_COLOR_SPACE jpeg_color_space; /* colorspace of JPEG image */
-
-  /* Decompression processing parameters --- these fields must be set before
-   * calling jpeg_start_decompress().  Note that jpeg_read_header() initializes
-   * them to default values.
-   */
-
-  J_COLOR_SPACE out_color_space; /* colorspace for output */
-
-  unsigned int scale_num, scale_denom; /* fraction by which to scale image */
-
-  double output_gamma;		/* image gamma wanted in output */
-
-  boolean buffered_image;	/* TRUE=multiple output passes */
-  boolean raw_data_out;		/* TRUE=downsampled data wanted */
-
-  J_DCT_METHOD dct_method;	/* IDCT algorithm selector */
-  boolean do_fancy_upsampling;	/* TRUE=apply fancy upsampling */
-  boolean do_block_smoothing;	/* TRUE=apply interblock smoothing */
-
-  boolean quantize_colors;	/* TRUE=colormapped output wanted */
-  /* the following are ignored if not quantize_colors: */
-  J_DITHER_MODE dither_mode;	/* type of color dithering to use */
-  boolean two_pass_quantize;	/* TRUE=use two-pass color quantization */
-  int desired_number_of_colors;	/* max # colors to use in created colormap */
-  /* these are significant only in buffered-image mode: */
-  boolean enable_1pass_quant;	/* enable future use of 1-pass quantizer */
-  boolean enable_external_quant;/* enable future use of external colormap */
-  boolean enable_2pass_quant;	/* enable future use of 2-pass quantizer */
-
-  /* Description of actual output image that will be returned to application.
-   * These fields are computed by jpeg_start_decompress().
-   * You can also use jpeg_calc_output_dimensions() to determine these values
-   * in advance of calling jpeg_start_decompress().
-   */
-
-  JDIMENSION output_width;	/* scaled image width */
-  JDIMENSION output_height;	/* scaled image height */
-  int out_color_components;	/* # of color components in out_color_space */
-  int output_components;	/* # of color components returned */
-  /* output_components is 1 (a colormap index) when quantizing colors;
-   * otherwise it equals out_color_components.
-   */
-  int rec_outbuf_height;	/* min recommended height of scanline buffer */
-  /* If the buffer passed to jpeg_read_scanlines() is less than this many rows
-   * high, space and time will be wasted due to unnecessary data copying.
-   * Usually rec_outbuf_height will be 1 or 2, at most 4.
-   */
-
-  /* When quantizing colors, the output colormap is described by these fields.
-   * The application can supply a colormap by setting colormap non-NULL before
-   * calling jpeg_start_decompress; otherwise a colormap is created during
-   * jpeg_start_decompress or jpeg_start_output.
-   * The map has out_color_components rows and actual_number_of_colors columns.
-   */
-  int actual_number_of_colors;	/* number of entries in use */
-  JSAMPARRAY colormap;		/* The color map as a 2-D pixel array */
-
-  /* State variables: these variables indicate the progress of decompression.
-   * The application may examine these but must not modify them.
-   */
-
-  /* Row index of next scanline to be read from jpeg_read_scanlines().
-   * Application may use this to control its processing loop, e.g.,
-   * "while (output_scanline < output_height)".
-   */
-  JDIMENSION output_scanline;	/* 0 .. output_height-1  */
-
-  /* Current input scan number and number of iMCU rows completed in scan.
-   * These indicate the progress of the decompressor input side.
-   */
-  int input_scan_number;	/* Number of SOS markers seen so far */
-  JDIMENSION input_iMCU_row;	/* Number of iMCU rows completed */
-
-  /* The "output scan number" is the notional scan being displayed by the
-   * output side.  The decompressor will not allow output scan/row number
-   * to get ahead of input scan/row, but it can fall arbitrarily far behind.
-   */
-  int output_scan_number;	/* Nominal scan number being displayed */
-  JDIMENSION output_iMCU_row;	/* Number of iMCU rows read */
-
-  /* Current progression status.  coef_bits[c][i] indicates the precision
-   * with which component c's DCT coefficient i (in zigzag order) is known.
-   * It is -1 when no data has yet been received, otherwise it is the point
-   * transform (shift) value for the most recent scan of the coefficient
-   * (thus, 0 at completion of the progression).
-   * This pointer is NULL when reading a non-progressive file.
-   */
-  int (*coef_bits)[DCTSIZE2];	/* -1 or current Al value for each coef */
-
-  /* Internal JPEG parameters --- the application usually need not look at
-   * these fields.  Note that the decompressor output side may not use
-   * any parameters that can change between scans.
-   */
-
-  /* Quantization and Huffman tables are carried forward across input
-   * datastreams when processing abbreviated JPEG datastreams.
-   */
-
-  JQUANT_TBL * quant_tbl_ptrs[NUM_QUANT_TBLS];
-  /* ptrs to coefficient quantization tables, or NULL if not defined */
-
-  JHUFF_TBL * dc_huff_tbl_ptrs[NUM_HUFF_TBLS];
-  JHUFF_TBL * ac_huff_tbl_ptrs[NUM_HUFF_TBLS];
-  /* ptrs to Huffman coding tables, or NULL if not defined */
-
-  /* These parameters are never carried across datastreams, since they
-   * are given in SOF/SOS markers or defined to be reset by SOI.
-   */
-
-  int data_precision;		/* bits of precision in image data */
-
-  jpeg_component_info * comp_info;
-  /* comp_info[i] describes component that appears i'th in SOF */
-
-  boolean progressive_mode;	/* TRUE if SOFn specifies progressive mode */
-  boolean arith_code;		/* TRUE=arithmetic coding, FALSE=Huffman */
-
-  UINT8 arith_dc_L[NUM_ARITH_TBLS]; /* L values for DC arith-coding tables */
-  UINT8 arith_dc_U[NUM_ARITH_TBLS]; /* U values for DC arith-coding tables */
-  UINT8 arith_ac_K[NUM_ARITH_TBLS]; /* Kx values for AC arith-coding tables */
-
-  unsigned int restart_interval; /* MCUs per restart interval, or 0 for no restart */
-
-  /* These fields record data obtained from optional markers recognized by
-   * the JPEG library.
-   */
-  boolean saw_JFIF_marker;	/* TRUE iff a JFIF APP0 marker was found */
-  /* Data copied from JFIF marker; only valid if saw_JFIF_marker is TRUE: */
-  UINT8 JFIF_major_version;	/* JFIF version number */
-  UINT8 JFIF_minor_version;
-  UINT8 density_unit;		/* JFIF code for pixel size units */
-  UINT16 X_density;		/* Horizontal pixel density */
-  UINT16 Y_density;		/* Vertical pixel density */
-  boolean saw_Adobe_marker;	/* TRUE iff an Adobe APP14 marker was found */
-  UINT8 Adobe_transform;	/* Color transform code from Adobe marker */
-
-  boolean CCIR601_sampling;	/* TRUE=first samples are cosited */
-
-  /* Aside from the specific data retained from APPn markers known to the
-   * library, the uninterpreted contents of any or all APPn and COM markers
-   * can be saved in a list for examination by the application.
-   */
-  jpeg_saved_marker_ptr marker_list; /* Head of list of saved markers */
-
-  /* Remaining fields are known throughout decompressor, but generally
-   * should not be touched by a surrounding application.
-   */
-
-  /*
-   * These fields are computed during decompression startup
-   */
-  int max_h_samp_factor;	/* largest h_samp_factor */
-  int max_v_samp_factor;	/* largest v_samp_factor */
-
-  int min_DCT_scaled_size;	/* smallest DCT_scaled_size of any component */
-
-  JDIMENSION total_iMCU_rows;	/* # of iMCU rows in image */
-  /* The coefficient controller's input and output progress is measured in
-   * units of "iMCU" (interleaved MCU) rows.  These are the same as MCU rows
-   * in fully interleaved JPEG scans, but are used whether the scan is
-   * interleaved or not.  We define an iMCU row as v_samp_factor DCT block
-   * rows of each component.  Therefore, the IDCT output contains
-   * v_samp_factor*DCT_scaled_size sample rows of a component per iMCU row.
-   */
-
-  JSAMPLE * sample_range_limit; /* table for fast range-limiting */
-
-  /*
-   * These fields are valid during any one scan.
-   * They describe the components and MCUs actually appearing in the scan.
-   * Note that the decompressor output side must not use these fields.
-   */
-  int comps_in_scan;		/* # of JPEG components in this scan */
-  jpeg_component_info * cur_comp_info[MAX_COMPS_IN_SCAN];
-  /* *cur_comp_info[i] describes component that appears i'th in SOS */
-
-  JDIMENSION MCUs_per_row;	/* # of MCUs across the image */
-  JDIMENSION MCU_rows_in_scan;	/* # of MCU rows in the image */
-
-  int blocks_in_MCU;		/* # of DCT blocks per MCU */
-  int MCU_membership[D_MAX_BLOCKS_IN_MCU];
-  /* MCU_membership[i] is index in cur_comp_info of component owning */
-  /* i'th block in an MCU */
-
-  int Ss, Se, Ah, Al;		/* progressive JPEG parameters for scan */
-
-  /* This field is shared between entropy decoder and marker parser.
-   * It is either zero or the code of a JPEG marker that has been
-   * read from the data source, but has not yet been processed.
-   */
-  int unread_marker;
-
-  /*
-   * Links to decompression subobjects (methods, private variables of modules)
-   */
-  struct jpeg_decomp_master * master;
-  struct jpeg_d_main_controller * main;
-  struct jpeg_d_coef_controller * coef;
-  struct jpeg_d_post_controller * post;
-  struct jpeg_input_controller * inputctl;
-  struct jpeg_marker_reader * marker;
-  struct jpeg_entropy_decoder * entropy;
-  struct jpeg_inverse_dct * idct;
-  struct jpeg_upsampler * upsample;
-  struct jpeg_color_deconverter * cconvert;
-  struct jpeg_color_quantizer * cquantize;
-};
-
-
-/* "Object" declarations for JPEG modules that may be supplied or called
- * directly by the surrounding application.
- * As with all objects in the JPEG library, these structs only define the
- * publicly visible methods and state variables of a module.  Additional
- * private fields may exist after the public ones.
- */
-
-
-/* Error handler object */
-
-struct jpeg_error_mgr {
-  /* Error exit handler: does not return to caller */
-  JMETHOD(void, error_exit, (j_common_ptr cinfo));
-  /* Conditionally emit a trace or warning message */
-  JMETHOD(void, emit_message, (j_common_ptr cinfo, int msg_level));
-  /* Routine that actually outputs a trace or error message */
-  JMETHOD(void, output_message, (j_common_ptr cinfo));
-  /* Format a message string for the most recent JPEG error or message */
-  JMETHOD(void, format_message, (j_common_ptr cinfo, char * buffer));
-#define JMSG_LENGTH_MAX  200	/* recommended size of format_message buffer */
-  /* Reset error state variables at start of a new image */
-  JMETHOD(void, reset_error_mgr, (j_common_ptr cinfo));
-  
-  /* The message ID code and any parameters are saved here.
-   * A message can have one string parameter or up to 8 int parameters.
-   */
-  int msg_code;
-#define JMSG_STR_PARM_MAX  80
-  union {
-    int i[8];
-    char s[JMSG_STR_PARM_MAX];
-  } msg_parm;
-  
-  /* Standard state variables for error facility */
-  
-  int trace_level;		/* max msg_level that will be displayed */
-  
-  /* For recoverable corrupt-data errors, we emit a warning message,
-   * but keep going unless emit_message chooses to abort.  emit_message
-   * should count warnings in num_warnings.  The surrounding application
-   * can check for bad data by seeing if num_warnings is nonzero at the
-   * end of processing.
-   */
-  long num_warnings;		/* number of corrupt-data warnings */
-
-  /* These fields point to the table(s) of error message strings.
-   * An application can change the table pointer to switch to a different
-   * message list (typically, to change the language in which errors are
-   * reported).  Some applications may wish to add additional error codes
-   * that will be handled by the JPEG library error mechanism; the second
-   * table pointer is used for this purpose.
-   *
-   * First table includes all errors generated by JPEG library itself.
-   * Error code 0 is reserved for a "no such error string" message.
-   */
-  const char * const * jpeg_message_table; /* Library errors */
-  int last_jpeg_message;    /* Table contains strings 0..last_jpeg_message */
-  /* Second table can be added by application (see cjpeg/djpeg for example).
-   * It contains strings numbered first_addon_message..last_addon_message.
-   */
-  const char * const * addon_message_table; /* Non-library errors */
-  int first_addon_message;	/* code for first string in addon table */
-  int last_addon_message;	/* code for last string in addon table */
-};
-
-
-/* Progress monitor object */
-
-struct jpeg_progress_mgr {
-  JMETHOD(void, progress_monitor, (j_common_ptr cinfo));
-
-  long pass_counter;		/* work units completed in this pass */
-  long pass_limit;		/* total number of work units in this pass */
-  int completed_passes;		/* passes completed so far */
-  int total_passes;		/* total number of passes expected */
-};
-
-
-/* Data destination object for compression */
-
-struct jpeg_destination_mgr {
-  JOCTET * next_output_byte;	/* => next byte to write in buffer */
-  size_t free_in_buffer;	/* # of byte spaces remaining in buffer */
-
-  JMETHOD(void, init_destination, (j_compress_ptr cinfo));
-  JMETHOD(boolean, empty_output_buffer, (j_compress_ptr cinfo));
-  JMETHOD(void, term_destination, (j_compress_ptr cinfo));
-};
-
-
-/* Data source object for decompression */
-
-struct jpeg_source_mgr {
-  const JOCTET * next_input_byte; /* => next byte to read from buffer */
-  size_t bytes_in_buffer;	/* # of bytes remaining in buffer */
-
-  JMETHOD(void, init_source, (j_decompress_ptr cinfo));
-  JMETHOD(boolean, fill_input_buffer, (j_decompress_ptr cinfo));
-  JMETHOD(void, skip_input_data, (j_decompress_ptr cinfo, long num_bytes));
-  JMETHOD(boolean, resync_to_restart, (j_decompress_ptr cinfo, int desired));
-  JMETHOD(void, term_source, (j_decompress_ptr cinfo));
-};
-
-
-/* Memory manager object.
- * Allocates "small" objects (a few K total), "large" objects (tens of K),
- * and "really big" objects (virtual arrays with backing store if needed).
- * The memory manager does not allow individual objects to be freed; rather,
- * each created object is assigned to a pool, and whole pools can be freed
- * at once.  This is faster and more convenient than remembering exactly what
- * to free, especially where malloc()/free() are not too speedy.
- * NB: alloc routines never return NULL.  They exit to error_exit if not
- * successful.
- */
-
-#define JPOOL_PERMANENT	0	/* lasts until master record is destroyed */
-#define JPOOL_IMAGE	1	/* lasts until done with image/datastream */
-#define JPOOL_NUMPOOLS	2
-
-typedef struct jvirt_sarray_control * jvirt_sarray_ptr;
-typedef struct jvirt_barray_control * jvirt_barray_ptr;
-
-
-struct jpeg_memory_mgr {
-  /* Method pointers */
-  JMETHOD(void *, alloc_small, (j_common_ptr cinfo, int pool_id,
-				size_t sizeofobject));
-  JMETHOD(void FAR *, alloc_large, (j_common_ptr cinfo, int pool_id,
-				     size_t sizeofobject));
-  JMETHOD(JSAMPARRAY, alloc_sarray, (j_common_ptr cinfo, int pool_id,
-				     JDIMENSION samplesperrow,
-				     JDIMENSION numrows));
-  JMETHOD(JBLOCKARRAY, alloc_barray, (j_common_ptr cinfo, int pool_id,
-				      JDIMENSION blocksperrow,
-				      JDIMENSION numrows));
-  JMETHOD(jvirt_sarray_ptr, request_virt_sarray, (j_common_ptr cinfo,
-						  int pool_id,
-						  boolean pre_zero,
-						  JDIMENSION samplesperrow,
-						  JDIMENSION numrows,
-						  JDIMENSION maxaccess));
-  JMETHOD(jvirt_barray_ptr, request_virt_barray, (j_common_ptr cinfo,
-						  int pool_id,
-						  boolean pre_zero,
-						  JDIMENSION blocksperrow,
-						  JDIMENSION numrows,
-						  JDIMENSION maxaccess));
-  JMETHOD(void, realize_virt_arrays, (j_common_ptr cinfo));
-  JMETHOD(JSAMPARRAY, access_virt_sarray, (j_common_ptr cinfo,
-					   jvirt_sarray_ptr ptr,
-					   JDIMENSION start_row,
-					   JDIMENSION num_rows,
-					   boolean writable));
-  JMETHOD(JBLOCKARRAY, access_virt_barray, (j_common_ptr cinfo,
-					    jvirt_barray_ptr ptr,
-					    JDIMENSION start_row,
-					    JDIMENSION num_rows,
-					    boolean writable));
-  JMETHOD(void, free_pool, (j_common_ptr cinfo, int pool_id));
-  JMETHOD(void, self_destruct, (j_common_ptr cinfo));
-
-  /* Limit on memory allocation for this JPEG object.  (Note that this is
-   * merely advisory, not a guaranteed maximum; it only affects the space
-   * used for virtual-array buffers.)  May be changed by outer application
-   * after creating the JPEG object.
-   */
-  long max_memory_to_use;
-
-  /* Maximum allocation request accepted by alloc_large. */
-  long max_alloc_chunk;
-};
-
-
-/* Routine signature for application-supplied marker processing methods.
- * Need not pass marker code since it is stored in cinfo->unread_marker.
- */
-typedef JMETHOD(boolean, jpeg_marker_parser_method, (j_decompress_ptr cinfo));
-
-
-/* Declarations for routines called by application.
- * The JPP macro hides prototype parameters from compilers that can't cope.
- * Note JPP requires double parentheses.
- */
-
-#ifdef HAVE_PROTOTYPES
-#define JPP(arglist)	arglist
-#else
-#define JPP(arglist)	()
-#endif
-
-
-/* Short forms of external names for systems with brain-damaged linkers.
- * We shorten external names to be unique in the first six letters, which
- * is good enough for all known systems.
- * (If your compiler itself needs names to be unique in less than 15 
- * characters, you are out of luck.  Get a better compiler.)
- */
-
-#ifdef NEED_SHORT_EXTERNAL_NAMES
-#define jpeg_std_error		jStdError
-#define jpeg_CreateCompress	jCreaCompress
-#define jpeg_CreateDecompress	jCreaDecompress
-#define jpeg_destroy_compress	jDestCompress
-#define jpeg_destroy_decompress	jDestDecompress
-#define jpeg_stdio_dest		jStdDest
-#define jpeg_stdio_src		jStdSrc
-#define jpeg_set_defaults	jSetDefaults
-#define jpeg_set_colorspace	jSetColorspace
-#define jpeg_default_colorspace	jDefColorspace
-#define jpeg_set_quality	jSetQuality
-#define jpeg_set_linear_quality	jSetLQuality
-#define jpeg_add_quant_table	jAddQuantTable
-#define jpeg_quality_scaling	jQualityScaling
-#define jpeg_simple_progression	jSimProgress
-#define jpeg_suppress_tables	jSuppressTables
-#define jpeg_alloc_quant_table	jAlcQTable
-#define jpeg_alloc_huff_table	jAlcHTable
-#define jpeg_start_compress	jStrtCompress
-#define jpeg_write_scanlines	jWrtScanlines
-#define jpeg_finish_compress	jFinCompress
-#define jpeg_write_raw_data	jWrtRawData
-#define jpeg_write_marker	jWrtMarker
-#define jpeg_write_m_header	jWrtMHeader
-#define jpeg_write_m_byte	jWrtMByte
-#define jpeg_write_tables	jWrtTables
-#define jpeg_read_header	jReadHeader
-#define jpeg_start_decompress	jStrtDecompress
-#define jpeg_read_scanlines	jReadScanlines
-#define jpeg_finish_decompress	jFinDecompress
-#define jpeg_read_raw_data	jReadRawData
-#define jpeg_has_multiple_scans	jHasMultScn
-#define jpeg_start_output	jStrtOutput
-#define jpeg_finish_output	jFinOutput
-#define jpeg_input_complete	jInComplete
-#define jpeg_new_colormap	jNewCMap
-#define jpeg_consume_input	jConsumeInput
-#define jpeg_calc_output_dimensions	jCalcDimensions
-#define jpeg_save_markers	jSaveMarkers
-#define jpeg_set_marker_processor	jSetMarker
-#define jpeg_read_coefficients	jReadCoefs
-#define jpeg_write_coefficients	jWrtCoefs
-#define jpeg_copy_critical_parameters	jCopyCrit
-#define jpeg_abort_compress	jAbrtCompress
-#define jpeg_abort_decompress	jAbrtDecompress
-#define jpeg_abort		jAbort
-#define jpeg_destroy		jDestroy
-#define jpeg_resync_to_restart	jResyncRestart
-#endif /* NEED_SHORT_EXTERNAL_NAMES */
-
-
-/* Default error-management setup */
-EXTERN(struct jpeg_error_mgr *) jpeg_std_error
-	JPP((struct jpeg_error_mgr * err));
-
-/* Initialization of JPEG compression objects.
- * jpeg_create_compress() and jpeg_create_decompress() are the exported
- * names that applications should call.  These expand to calls on
- * jpeg_CreateCompress and jpeg_CreateDecompress with additional information
- * passed for version mismatch checking.
- * NB: you must set up the error-manager BEFORE calling jpeg_create_xxx.
- */
-#define jpeg_create_compress(cinfo) \
-    jpeg_CreateCompress((cinfo), JPEG_LIB_VERSION, \
-			(size_t) sizeof(struct jpeg_compress_struct))
-#define jpeg_create_decompress(cinfo) \
-    jpeg_CreateDecompress((cinfo), JPEG_LIB_VERSION, \
-			  (size_t) sizeof(struct jpeg_decompress_struct))
-EXTERN(void) jpeg_CreateCompress JPP((j_compress_ptr cinfo,
-				      int version, size_t structsize));
-EXTERN(void) jpeg_CreateDecompress JPP((j_decompress_ptr cinfo,
-					int version, size_t structsize));
-/* Destruction of JPEG compression objects */
-EXTERN(void) jpeg_destroy_compress JPP((j_compress_ptr cinfo));
-EXTERN(void) jpeg_destroy_decompress JPP((j_decompress_ptr cinfo));
-
-/* Standard data source and destination managers: stdio streams. */
-/* Caller is responsible for opening the file before and closing after. */
-EXTERN(void) jpeg_stdio_dest JPP((j_compress_ptr cinfo, FILE * outfile));
-EXTERN(void) jpeg_stdio_src JPP((j_decompress_ptr cinfo, FILE * infile));
-
-/* Default parameter setup for compression */
-EXTERN(void) jpeg_set_defaults JPP((j_compress_ptr cinfo));
-/* Compression parameter setup aids */
-EXTERN(void) jpeg_set_colorspace JPP((j_compress_ptr cinfo,
-				      J_COLOR_SPACE colorspace));
-EXTERN(void) jpeg_default_colorspace JPP((j_compress_ptr cinfo));
-EXTERN(void) jpeg_set_quality JPP((j_compress_ptr cinfo, int quality,
-				   boolean force_baseline));
-EXTERN(void) jpeg_set_linear_quality JPP((j_compress_ptr cinfo,
-					  int scale_factor,
-					  boolean force_baseline));
-EXTERN(void) jpeg_add_quant_table JPP((j_compress_ptr cinfo, int which_tbl,
-				       const unsigned int *basic_table,
-				       int scale_factor,
-				       boolean force_baseline));
-EXTERN(int) jpeg_quality_scaling JPP((int quality));
-EXTERN(void) jpeg_simple_progression JPP((j_compress_ptr cinfo));
-EXTERN(void) jpeg_suppress_tables JPP((j_compress_ptr cinfo,
-				       boolean suppress));
-EXTERN(JQUANT_TBL *) jpeg_alloc_quant_table JPP((j_common_ptr cinfo));
-EXTERN(JHUFF_TBL *) jpeg_alloc_huff_table JPP((j_common_ptr cinfo));
-
-/* Main entry points for compression */
-EXTERN(void) jpeg_start_compress JPP((j_compress_ptr cinfo,
-				      boolean write_all_tables));
-EXTERN(JDIMENSION) jpeg_write_scanlines JPP((j_compress_ptr cinfo,
-					     JSAMPARRAY scanlines,
-					     JDIMENSION num_lines));
-EXTERN(void) jpeg_finish_compress JPP((j_compress_ptr cinfo));
-
-/* Replaces jpeg_write_scanlines when writing raw downsampled data. */
-EXTERN(JDIMENSION) jpeg_write_raw_data JPP((j_compress_ptr cinfo,
-					    JSAMPIMAGE data,
-					    JDIMENSION num_lines));
-
-/* Write a special marker.  See libjpeg.doc concerning safe usage. */
-EXTERN(void) jpeg_write_marker
-	JPP((j_compress_ptr cinfo, int marker,
-	     const JOCTET * dataptr, unsigned int datalen));
-/* Same, but piecemeal. */
-EXTERN(void) jpeg_write_m_header
-	JPP((j_compress_ptr cinfo, int marker, unsigned int datalen));
-EXTERN(void) jpeg_write_m_byte
-	JPP((j_compress_ptr cinfo, int val));
-
-/* Alternate compression function: just write an abbreviated table file */
-EXTERN(void) jpeg_write_tables JPP((j_compress_ptr cinfo));
-
-/* Decompression startup: read start of JPEG datastream to see what's there */
-EXTERN(int) jpeg_read_header JPP((j_decompress_ptr cinfo,
-				  boolean require_image));
-/* Return value is one of: */
-#define JPEG_SUSPENDED		0 /* Suspended due to lack of input data */
-#define JPEG_HEADER_OK		1 /* Found valid image datastream */
-#define JPEG_HEADER_TABLES_ONLY	2 /* Found valid table-specs-only datastream */
-/* If you pass require_image = TRUE (normal case), you need not check for
- * a TABLES_ONLY return code; an abbreviated file will cause an error exit.
- * JPEG_SUSPENDED is only possible if you use a data source module that can
- * give a suspension return (the stdio source module doesn't).
- */
-
-/* Main entry points for decompression */
-EXTERN(boolean) jpeg_start_decompress JPP((j_decompress_ptr cinfo));
-EXTERN(JDIMENSION) jpeg_read_scanlines JPP((j_decompress_ptr cinfo,
-					    JSAMPARRAY scanlines,
-					    JDIMENSION max_lines));
-EXTERN(boolean) jpeg_finish_decompress JPP((j_decompress_ptr cinfo));
-
-/* Replaces jpeg_read_scanlines when reading raw downsampled data. */
-EXTERN(JDIMENSION) jpeg_read_raw_data JPP((j_decompress_ptr cinfo,
-					   JSAMPIMAGE data,
-					   JDIMENSION max_lines));
-
-/* Additional entry points for buffered-image mode. */
-EXTERN(boolean) jpeg_has_multiple_scans JPP((j_decompress_ptr cinfo));
-EXTERN(boolean) jpeg_start_output JPP((j_decompress_ptr cinfo,
-				       int scan_number));
-EXTERN(boolean) jpeg_finish_output JPP((j_decompress_ptr cinfo));
-EXTERN(boolean) jpeg_input_complete JPP((j_decompress_ptr cinfo));
-EXTERN(void) jpeg_new_colormap JPP((j_decompress_ptr cinfo));
-EXTERN(int) jpeg_consume_input JPP((j_decompress_ptr cinfo));
-/* Return value is one of: */
-/* #define JPEG_SUSPENDED	0    Suspended due to lack of input data */
-#define JPEG_REACHED_SOS	1 /* Reached start of new scan */
-#define JPEG_REACHED_EOI	2 /* Reached end of image */
-#define JPEG_ROW_COMPLETED	3 /* Completed one iMCU row */
-#define JPEG_SCAN_COMPLETED	4 /* Completed last iMCU row of a scan */
-
-/* Precalculate output dimensions for current decompression parameters. */
-EXTERN(void) jpeg_calc_output_dimensions JPP((j_decompress_ptr cinfo));
-
-/* Control saving of COM and APPn markers into marker_list. */
-EXTERN(void) jpeg_save_markers
-	JPP((j_decompress_ptr cinfo, int marker_code,
-	     unsigned int length_limit));
-
-/* Install a special processing method for COM or APPn markers. */
-EXTERN(void) jpeg_set_marker_processor
-	JPP((j_decompress_ptr cinfo, int marker_code,
-	     jpeg_marker_parser_method routine));
-
-/* Read or write raw DCT coefficients --- useful for lossless transcoding. */
-EXTERN(jvirt_barray_ptr *) jpeg_read_coefficients JPP((j_decompress_ptr cinfo));
-EXTERN(void) jpeg_write_coefficients JPP((j_compress_ptr cinfo,
-					  jvirt_barray_ptr * coef_arrays));
-EXTERN(void) jpeg_copy_critical_parameters JPP((j_decompress_ptr srcinfo,
-						j_compress_ptr dstinfo));
-
-/* If you choose to abort compression or decompression before completing
- * jpeg_finish_(de)compress, then you need to clean up to release memory,
- * temporary files, etc.  You can just call jpeg_destroy_(de)compress
- * if you're done with the JPEG object, but if you want to clean it up and
- * reuse it, call this:
- */
-EXTERN(void) jpeg_abort_compress JPP((j_compress_ptr cinfo));
-EXTERN(void) jpeg_abort_decompress JPP((j_decompress_ptr cinfo));
-
-/* Generic versions of jpeg_abort and jpeg_destroy that work on either
- * flavor of JPEG object.  These may be more convenient in some places.
- */
-EXTERN(void) jpeg_abort JPP((j_common_ptr cinfo));
-EXTERN(void) jpeg_destroy JPP((j_common_ptr cinfo));
-
-/* Default restart-marker-resync procedure for use by data source modules */
-EXTERN(boolean) jpeg_resync_to_restart JPP((j_decompress_ptr cinfo,
-					    int desired));
-
-
-/* These marker codes are exported since applications and data source modules
- * are likely to want to use them.
- */
-
-#define JPEG_RST0	0xD0	/* RST0 marker code */
-#define JPEG_EOI	0xD9	/* EOI marker code */
-#define JPEG_APP0	0xE0	/* APP0 marker code */
-#define JPEG_COM	0xFE	/* COM marker code */
-
-
-/* If we have a brain-damaged compiler that emits warnings (or worse, errors)
- * for structure definitions that are never filled in, keep it quiet by
- * supplying dummy definitions for the various substructures.
- */
-
-#ifdef INCOMPLETE_TYPES_BROKEN
-#ifndef JPEG_INTERNALS		/* will be defined in jpegint.h */
-struct jvirt_sarray_control { long dummy; };
-struct jvirt_barray_control { long dummy; };
-struct jpeg_comp_master { long dummy; };
-struct jpeg_c_main_controller { long dummy; };
-struct jpeg_c_prep_controller { long dummy; };
-struct jpeg_c_coef_controller { long dummy; };
-struct jpeg_marker_writer { long dummy; };
-struct jpeg_color_converter { long dummy; };
-struct jpeg_downsampler { long dummy; };
-struct jpeg_forward_dct { long dummy; };
-struct jpeg_entropy_encoder { long dummy; };
-struct jpeg_decomp_master { long dummy; };
-struct jpeg_d_main_controller { long dummy; };
-struct jpeg_d_coef_controller { long dummy; };
-struct jpeg_d_post_controller { long dummy; };
-struct jpeg_input_controller { long dummy; };
-struct jpeg_marker_reader { long dummy; };
-struct jpeg_entropy_decoder { long dummy; };
-struct jpeg_inverse_dct { long dummy; };
-struct jpeg_upsampler { long dummy; };
-struct jpeg_color_deconverter { long dummy; };
-struct jpeg_color_quantizer { long dummy; };
-#endif /* JPEG_INTERNALS */
-#endif /* INCOMPLETE_TYPES_BROKEN */
-
-
-/*
- * The JPEG library modules define JPEG_INTERNALS before including this file.
- * The internal structure declarations are read only when that is true.
- * Applications using the library should not include jpegint.h, but may wish
- * to include jerror.h.
- */
-
-#ifdef JPEG_INTERNALS
-#include "jpegint.h"		/* fetch private declarations */
-#include "jerror.h"		/* fetch error codes too */
-#endif
-
-#endif /* JPEGLIB_H */
diff --git a/src/a2jpeg/jpegtools.c b/src/a2jpeg/jpegtools.c
deleted file mode 100644
index 91854d8..0000000
--- a/src/a2jpeg/jpegtools.c
+++ /dev/null
@@ -1,621 +0,0 @@
-/*
- * jpegtran.c
- *
- * Copyright (C) 1995-1997, Thomas G. Lane.
- * This file is part of the Independent JPEG Group's software.
- * For conditions of distribution and use, see the accompanying README file.
- * 
- * plenty of changes by Gerd Hoffmann <kraxel@bytesex.org>, with focus on
- * digital image processing and sane exif handling:
- *
- *   - does transformations only (flip/rotate/transpose/transverse).
- *   - also transforms the exif thumbnail if present.
- *   - can automatically figure transformation from the
- *     exif orientation tag.
- *   - updates the exif orientation tag.
- *   - updates the exif pixel dimension tags.
- *
- * This file contains a command-line user interface for JPEG transcoding.
- * It is very similar to cjpeg.c, but provides lossless transcoding between
- * different JPEG file formats.  It also provides some lossless and sort-of-
- * lossless transformations of JPEG data.
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <stddef.h>
-#include <unistd.h>
-#include <errno.h>
-#include <string.h>
-#include <utime.h>
-#include <setjmp.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-
-#include <jpeglib.h>
-//#include "a2jpeg/transupp.h"		/* Support routines for jpegtran */
-#include "jpegtools.h"
-
-#include "misc.h"
-
-#include <libexif/exif-data.h>
-#include <libexif/exif-utils.h>
-#include <libexif/exif-ifd.h>
-#include <libexif/exif-tag.h>
-
-static int do_transform(struct jpeg_decompress_struct *src,
-			struct jpeg_compress_struct   *dst,
-			JXFORM_CODE transform,
-			unsigned char *comment,
-			char *thumbnail, int tsize,
-			unsigned int flags);
-
-static JXFORM_CODE transmagic[] = {
-    [ 1 ] = JXFORM_NONE,
-    [ 2 ] = JXFORM_FLIP_H,
-    [ 3 ] = JXFORM_ROT_180,
-    [ 4 ] = JXFORM_FLIP_V,
-    [ 5 ] = JXFORM_TRANSPOSE,
-    [ 6 ] = JXFORM_ROT_90,
-    [ 7 ] = JXFORM_TRANSVERSE,
-    [ 8 ] = JXFORM_ROT_270,
-};
-
-#if 0
-static char *transname[] = {
-    [ JXFORM_NONE ]       = "none",
-    [ JXFORM_FLIP_H ]     = "flip h",
-    [ JXFORM_FLIP_V ]     = "flip v",
-    [ JXFORM_TRANSPOSE ]  = "transpose",
-    [ JXFORM_TRANSVERSE ] = "transverse",
-    [ JXFORM_ROT_90 ]     = "rot 90",
-    [ JXFORM_ROT_180 ]    = "rot 190",
-    [ JXFORM_ROT_270 ]    = "rot 270",
-};
-#endif
-
-/* ---------------------------------------------------------------------- */
-
-/* libjpeg error handler -- exit via longjump */
-struct longjmp_error_mgr {
-    struct jpeg_error_mgr jpeg;
-    jmp_buf setjmp_buffer;
-};
-
-static void longjmp_error_exit(j_common_ptr cinfo)
-{
-    struct longjmp_error_mgr *h = (struct longjmp_error_mgr*)cinfo->err;
-    (*cinfo->err->output_message)(cinfo);
-    longjmp(h->setjmp_buffer, 1);
-}
-
-/* ---------------------------------------------------------------------- */
-
-static long get_int(ExifData *ed, ExifEntry *ee)
-{
-    ExifByteOrder o = exif_data_get_byte_order(ed);
-    long value;
-    
-    switch (ee->format) {
-    case EXIF_FORMAT_SHORT:
-	value = exif_get_short (ee->data, o);
-	break;
-    case EXIF_FORMAT_LONG:
-	value = exif_get_long (ee->data, o);
-	break;
-    case EXIF_FORMAT_SLONG:
-	value = exif_get_slong (ee->data, o);
-	break;
-    default:
-	fprintf(stderr,"get_int oops\n");
-	exit(1);
-    }
-    return value;
-}
-
-static void set_int(ExifData *ed, ExifEntry *ee, long value)
-{
-    ExifByteOrder o = exif_data_get_byte_order(ed);
-
-    switch (ee->format) {
-    case EXIF_FORMAT_SHORT:
-	exif_set_short (ee->data, o, value);
-	break;
-    case EXIF_FORMAT_LONG:
-	exif_set_long (ee->data, o, value);
-	break;
-    case EXIF_FORMAT_SLONG:
-	exif_set_slong (ee->data, o, value);
-	break;
-    default:
-	fprintf(stderr,"set_int oops\n");
-	exit(1);
-    }
-}
-
-static void update_orientation(ExifData *ed, int ifd, int orientation)
-{
-    ExifEntry *ee;
-
-    ee = exif_content_get_entry(ed->ifd[ifd], 0x0112);
-    if (NULL == ee)
-	return;
-    set_int(ed,ee,orientation);
-}
-
-static void update_dimension(ExifData *ed, JXFORM_CODE transform,
-			     int src_x, int src_y)
-{
-    static struct {
-	int idf;
-	int tag;
-	int x;
-    } fields[] = {
-	{
-	    .idf = EXIF_IFD_EXIF,
-	    .tag = EXIF_TAG_PIXEL_X_DIMENSION,
-	    .x   = 1,
-	},{
-	    .idf = EXIF_IFD_EXIF,
-	    .tag = EXIF_TAG_PIXEL_Y_DIMENSION,
-	    .x   = 0,
-	},{
-	    .idf = EXIF_IFD_INTEROPERABILITY,
-	    .tag = EXIF_TAG_RELATED_IMAGE_WIDTH,
-	    .x   = 1,
-	},{
-	    .idf = EXIF_IFD_INTEROPERABILITY,
-	    .tag = EXIF_TAG_RELATED_IMAGE_LENGTH,
-	    .x   = 0,
-	}
-    };
-    ExifEntry *ee;
-    int i;
-
-    for (i = 0; i < sizeof(fields)/sizeof(fields[0]); i++) {
-	ee = exif_content_get_entry(ed->ifd[fields[i].idf], fields[i].tag);
-	if (!ee)
-	    continue;
-	switch (transform) {
-	case JXFORM_ROT_90:
-	case JXFORM_ROT_270:
-	case JXFORM_TRANSPOSE:
-	case JXFORM_TRANSVERSE:
-	    /* x/y reversed */
-	    set_int(ed, ee, fields[i].x ? src_y : src_x);
-	    break;
-	default:
-	    /* normal */
-	    set_int(ed, ee, fields[i].x ? src_x : src_y);
-	    break;
-	}
-    }
-}
-
-int get_orientation(ExifData *ed)
-{
-    ExifEntry *ee;
-
-    ee = exif_content_get_entry(ed->ifd[EXIF_IFD_0], 0x0112);
-    if (NULL == ee)
-	return 1; /* top - left */
-    return get_int(ed,ee);
-}
-
-/* ---------------------------------------------------------------------- */
-
-struct th {
-    struct jpeg_decompress_struct src;
-    struct jpeg_compress_struct   dst;
-    struct jpeg_error_mgr jsrcerr, jdsterr;
-    unsigned char *in;
-    unsigned char *out;
-    int isize, osize;
-};
-
-static void thumbnail_src_init(struct jpeg_decompress_struct *cinfo)
-{
-    struct th *h  = container_of(cinfo, struct th, src);
-    cinfo->src->next_input_byte = h->in;
-    cinfo->src->bytes_in_buffer = h->isize;
-}
-
-static int thumbnail_src_fill(struct jpeg_decompress_struct *cinfo)
-{
-    fprintf(stderr,"jpeg: panic: no more thumbnail input data\n");
-    exit(1);
-}
-
-static void thumbnail_src_skip(struct jpeg_decompress_struct *cinfo,
-			       long num_bytes)
-{
-    cinfo->src->next_input_byte += num_bytes;
-}
-
-static void thumbnail_src_term(struct jpeg_decompress_struct *cinfo)
-{
-    /* nothing */
-}
-
-static void thumbnail_dest_init(struct jpeg_compress_struct *cinfo)
-{
-    struct th *h  = container_of(cinfo, struct th, dst);
-    h->osize = h->isize * 2;
-    h->out   = malloc(h->osize);
-    cinfo->dest->next_output_byte = h->out;
-    cinfo->dest->free_in_buffer   = h->osize;
-}
-
-static boolean thumbnail_dest_flush(struct jpeg_compress_struct *cinfo)
-{
-    fprintf(stderr,"jpeg: panic: output buffer full\n");
-    exit(1);
-}
-
-static void thumbnail_dest_term(struct jpeg_compress_struct *cinfo)
-{
-    struct th *h  = container_of(cinfo, struct th, dst);
-    h->osize -= cinfo->dest->free_in_buffer;
-}
-
-static struct jpeg_source_mgr thumbnail_src = {
-    .init_source         = thumbnail_src_init,
-    .fill_input_buffer   = thumbnail_src_fill,
-    .skip_input_data     = thumbnail_src_skip,
-    .resync_to_restart   = jpeg_resync_to_restart,
-    .term_source         = thumbnail_src_term,
-};
-
-static struct jpeg_destination_mgr thumbnail_dst = {
-    .init_destination    = thumbnail_dest_init,
-    .empty_output_buffer = thumbnail_dest_flush,
-    .term_destination    = thumbnail_dest_term,
-};
-
-static void do_thumbnail(ExifData *ed, JXFORM_CODE transform)
-{
-    struct th th;
-
-    if (JXFORM_NONE == transform)
-	return;
-    
-    memset(&th,0,sizeof(th));
-    th.in    = ed->data;
-    th.isize = ed->size;
-    
-    /* setup src */
-    th.src.err = jpeg_std_error(&th.jsrcerr);
-    jpeg_create_decompress(&th.src);
-    th.src.src = &thumbnail_src;
-    
-    /* setup dst */
-    th.dst.err = jpeg_std_error(&th.jdsterr);
-    jpeg_create_compress(&th.dst);
-    th.dst.dest = &thumbnail_dst;
-
-    /* transform image */
-    do_transform(&th.src,&th.dst,transform,NULL,NULL,0,JFLAG_TRANSFORM_IMAGE);
-
-    /* cleanup */
-    jpeg_destroy_decompress(&th.src);
-    jpeg_destroy_compress(&th.dst);
-
-    /* replace thumbnail */
-    free(ed->data);
-    ed->data = th.out;
-    ed->size = th.osize;
-}
-
-static void do_exif(struct jpeg_decompress_struct *src,
-		    JXFORM_CODE *transform,
-		    char *thumbnail, int tsize,
-		    unsigned int flags)
-{
-    jpeg_saved_marker_ptr mark;
-    ExifData *ed = NULL;
-    unsigned char *data;
-    unsigned int  size;
-    
-    for (mark = src->marker_list; NULL != mark; mark = mark->next) {
-	if (mark->marker != JPEG_APP0 +1)
-	    continue;
-	ed = exif_data_new_from_data(mark->data,mark->data_length);
-	break;
-    }
-    if (flags & JFLAG_UPDATE_THUMBNAIL) {
-	if (NULL == ed)
-	    ed = exif_data_new();
-	if (NULL == mark) {
-	    mark = src->mem->alloc_large((j_common_ptr)src,JPOOL_IMAGE,sizeof(*mark));
-	    memset(mark,0,sizeof(*mark));
-	    mark->marker = JPEG_APP0 +1;
-	    mark->next = src->marker_list;
-	    src->marker_list = mark;
-	}
-	if (ed->data)
-	    free(ed->data);
-	ed->data = thumbnail;
-	ed->size = tsize;
-    }
-    if (NULL == ed)
-	return;
-
-    if (-1 == *transform) {
-	/* automagic image transformation */
-	int orientation = get_orientation(ed);
-	*transform = JXFORM_NONE;
-	if (orientation >= 1 && orientation <= 8)
-	    *transform = transmagic[orientation];
-#if 0
-	if (debug)
-	    fprintf(stderr,"autotrans: %s\n",transname[*transform]);
-#endif
-    }
-
-    /* update exif data */
-    if (flags & JFLAG_UPDATE_ORIENTATION) {
-	update_orientation(ed,EXIF_IFD_0,1);
-	update_orientation(ed,EXIF_IFD_1,1);
-    }
-    if (ed->data && ed->data[0] == 0xff && ed->data[1] == 0xd8 &&
-	(flags & JFLAG_TRANSFORM_THUMBNAIL))
-	do_thumbnail(ed,*transform);
-    update_dimension(ed, (flags & JFLAG_TRANSFORM_IMAGE) ? *transform : JXFORM_NONE,
-		     src->image_width, src->image_height);
-
-    /* build new exif data block */
-    exif_data_save_data(ed,&data,&size);
-    exif_data_unref(ed);
-
-    /* update jpeg APP1 (EXIF) marker */
-    mark->data = src->mem->alloc_large((j_common_ptr)src,JPOOL_IMAGE,size);
-    mark->original_length = size;
-    mark->data_length = size;
-    memcpy(mark->data,data,size);
-    free(data);
-}
-
-/* ---------------------------------------------------------------------- */
-
-static void do_comment(struct jpeg_decompress_struct *src,
-		       unsigned char *comment)
-{
-    jpeg_saved_marker_ptr mark;
-    int size;
-
-    /* find or create comment marker */
-    for (mark = src->marker_list;; mark = mark->next) {
-	if (mark->marker == JPEG_COM)
-	    break;
-	if (NULL == mark->next) {
-	    mark->next = src->mem->alloc_large((j_common_ptr)src,JPOOL_IMAGE,
-					       sizeof(*mark));
-	    mark = mark->next;
-	    memset(mark,0,sizeof(*mark));
-	    mark->marker = JPEG_COM;
-	    break;
-	}
-    }
-
-    /* update comment marker */
-    size = strlen(comment) +1;
-    mark->data = src->mem->alloc_large((j_common_ptr)src,JPOOL_IMAGE,size);
-    mark->original_length = size;
-    mark->data_length = size;
-    memcpy(mark->data,comment,size);
-}
-
-static int do_transform(struct jpeg_decompress_struct *src,
-			struct jpeg_compress_struct *dst,
-			JXFORM_CODE transform,
-			unsigned char *comment,
-			char *thumbnail, int tsize,
-			unsigned int flags)
-{
-    jvirt_barray_ptr * src_coef_arrays;
-    jvirt_barray_ptr * dst_coef_arrays;
-    jpeg_transform_info transformoption;
-
-    jcopy_markers_setup(src, JCOPYOPT_ALL);
-    if (JPEG_HEADER_OK != jpeg_read_header(src, TRUE))
-	return -1;
-
-    do_exif(src,&transform,thumbnail,tsize,flags);
-    if (-1 == transform)
-	transform = JXFORM_NONE;
-    if (!(flags & JFLAG_TRANSFORM_IMAGE))
-	transform = JXFORM_NONE;
-    if ((flags & JFLAG_UPDATE_COMMENT) && NULL != comment)
-	do_comment(src,comment);
-
-    memset(&transformoption,0,sizeof(transformoption));
-    transformoption.transform = transform;
-    transformoption.trim      = FALSE;
-    transformoption.force_grayscale = FALSE;
-
-    /* Any space needed by a transform option must be requested before
-     * jpeg_read_coefficients so that memory allocation will be done right.
-     */
-    jtransform_request_workspace(src, &transformoption);
-    src_coef_arrays = jpeg_read_coefficients(src);
-    jpeg_copy_critical_parameters(src, dst);
-    dst_coef_arrays = jtransform_adjust_parameters
-	(src, dst, src_coef_arrays, &transformoption);
-    
-    /* Start compressor (note no image data is actually written here) */
-    jpeg_write_coefficients(dst, dst_coef_arrays);
-    
-    /* Copy to the output file any extra markers that we want to preserve */
-    jcopy_markers_execute(src, dst, JCOPYOPT_ALL);
-    
-    /* Execute image transformation, if any */
-    jtransform_execute_transformation(src, dst,
-				      src_coef_arrays,
-				      &transformoption);
-    
-    /* Finish compression and release memory */
-    jpeg_finish_compress(dst);
-    jpeg_finish_decompress(src);
-
-    return 0;
-}
-
-/* ---------------------------------------------------------------------- */
-
-int jpeg_transform_fp(FILE *in, FILE *out,
-		      JXFORM_CODE transform,
-		      unsigned char *comment,
-		      char *thumbnail, int tsize,
-		      unsigned int flags)
-{
-    struct jpeg_decompress_struct src;
-    struct jpeg_compress_struct   dst;
-    struct jpeg_error_mgr jdsterr;
-    struct longjmp_error_mgr jsrcerr;
-    
-    /* setup src */
-    src.err = jpeg_std_error(&jsrcerr.jpeg);
-    jsrcerr.jpeg.error_exit = longjmp_error_exit;
-    if (setjmp(jsrcerr.setjmp_buffer))
-	/* something went wrong within the jpeg library ... */
-	goto oops;
-    jpeg_create_decompress(&src);
-    jpeg_stdio_src(&src, in);
-    
-    /* setup dst */
-    dst.err = jpeg_std_error(&jdsterr);
-    jpeg_create_compress(&dst);
-    jpeg_stdio_dest(&dst, out);
-
-    /* transform image */
-    do_transform(&src,&dst,transform,comment,thumbnail,tsize,flags);
-
-    /* cleanup */
-    jpeg_destroy_decompress(&src);
-    jpeg_destroy_compress(&dst);
-    return 0;
-
- oops:
-    jpeg_destroy_decompress(&src);
-    jpeg_destroy_compress(&dst);
-    return -1;
-}
-
-int jpeg_transform_files(char *infile, char *outfile,
-			 JXFORM_CODE transform,
-			 unsigned char *comment,
-			 char *thumbnail, int tsize,
-			 unsigned int flags)
-{
-    int rc;
-    FILE *in;
-    FILE *out;
-    
-    /* open infile */
-    in = fopen(infile,"r");
-    if (NULL == in) {
-	fprintf(stderr,"open %s: %s\n",infile,strerror(errno));
-	return -1;
-    }
-    
-    /* open outfile */
-    out = fopen(outfile,"w");
-    if (NULL == out) {
-	fprintf(stderr,"open %s: %s\n",outfile,strerror(errno));
-	fclose(in);
-	return -1;
-    }
-
-    /* go! */
-    rc = jpeg_transform_fp(in,out,transform,comment,thumbnail,tsize,flags);
-    fclose(in);
-    fclose(out);
-
-    return rc;
-}
-
-int jpeg_transform_inplace(char *file,
-			   JXFORM_CODE transform,
-			   unsigned char *comment,
-			   char *thumbnail, int tsize,
-			   unsigned int flags)
-{
-    char *tmpfile;
-    char *bakfile;
-    struct stat st;
-    int fd;
-    FILE *in  = NULL;
-    FILE *out = NULL;
-
-    /* are we allowed to write to the file? */
-    if (0 != access(file,W_OK)) {
-	fprintf(stderr,"access %s: %s\n",file,strerror(errno));
-	return -1;
-    }
-
-    /* open infile */
-    in = fopen(file,"r");
-    if (NULL == in) {
-	fprintf(stderr,"open %s: %s\n",file,strerror(errno));
-	return -1;
-    }
-    
-    /* open tmpfile */
-    tmpfile = malloc(strlen(file)+10);
-    sprintf(tmpfile,"%s.XXXXXX",file);
-    fd = mkstemp(tmpfile);
-    if (-1 == fd) {
-	fprintf(stderr,"mkstemp(%s): %s\n",tmpfile,strerror(errno));
-	goto oops;
-    }
-    out = fdopen(fd,"w");
-
-    /* copy owner and permissions */
-    if (-1 == fstat(fileno(in),&st)) {
-	fprintf(stderr,"fstat(%s): %s\n",file,strerror(errno));
-	goto oops;
-    }
-    if (-1 == fchown(fileno(out),st.st_uid,st.st_gid)) {
-	fprintf(stderr,"fchown(%s): %s\n",tmpfile,strerror(errno));
-	goto oops;
-    }
-    if (-1 == fchmod(fileno(out),st.st_mode)) {
-	fprintf(stderr,"fchmod(%s): %s\n",tmpfile,strerror(errno));
-	goto oops;
-    }
-
-    /* transform */
-    if (0 != jpeg_transform_fp(in,out,transform,comment,thumbnail,tsize,flags))
-	goto oops;
-
-    /* worked ok -- commit */
-    fclose(in);
-    fclose(out);
-    if (flags & JFLAG_FILE_BACKUP) {
-	bakfile = malloc(strlen(file)+2);
-	sprintf(bakfile,"%s~",file);
-	rename(file,bakfile);
-	free(bakfile);
-    }
-    rename(tmpfile,file);
-    if (flags & JFLAG_FILE_KEEP_TIME) {
-	struct utimbuf u;
-	u.actime = st.st_atime;
-	u.modtime = st.st_mtime;
-	utime(file,&u);
-    }
-        
-    /* cleanup & return */
-    free(tmpfile);
-    return 0;
-
- oops:
-    /* something went wrong -- rollback */
-    if (in)
-	fclose(in);
-    if (out) {
-	fclose(out);
-	unlink(tmpfile);
-    }
-    return -1;
-}
diff --git a/src/a2jpeg/jpegtools.h b/src/a2jpeg/jpegtools.h
deleted file mode 100644
index 875b66b..0000000
--- a/src/a2jpeg/jpegtools.h
+++ /dev/null
@@ -1,33 +0,0 @@
-
-/* various flags */
-#define JFLAG_TRANSFORM_IMAGE      0x0001
-#define JFLAG_TRANSFORM_THUMBNAIL  0x0002
-
-#define JFLAG_UPDATE_COMMENT       0x0010
-#define JFLAG_UPDATE_ORIENTATION   0x0020
-#define JFLAG_UPDATE_THUMBNAIL     0x0040
-
-#define JFLAG_FILE_BACKUP          0x0100
-#define JFLAG_FILE_KEEP_TIME       0x0200
-
-#include "transupp.h"
-#include "exif-data.h"
-
-/* functions */
-int jpeg_transform_fp(FILE *in, FILE *out,
-		      JXFORM_CODE transform,
-		      unsigned char *comment,
-		      char *thumbnail, int tsize,
-		      unsigned int flags);
-int jpeg_transform_files(char *infile, char *outfile,
-			 JXFORM_CODE transform,
-			 unsigned char *comment,
-			 char *thumbnail, int tsize,
-			 unsigned int flags);
-int jpeg_transform_inplace(char *file,
-			   JXFORM_CODE transform,
-			   unsigned char *comment,
-			   char *thumbnail, int tsize,
-			   unsigned int flags);
-
-int get_orientation(ExifData *ed);
diff --git a/src/a2jpeg/list.h b/src/a2jpeg/list.h
deleted file mode 100644
index 614d34b..0000000
--- a/src/a2jpeg/list.h
+++ /dev/null
@@ -1,168 +0,0 @@
-#ifndef _LIST_H_
-#define _LIST_H_
-/*
- * Simple doubly linked list implementation.
- *	-- shameless stolen from the linux kernel sources
- *
- * Some of the internal functions ("__xxx") are useful when
- * manipulating whole lists rather than single entries, as
- * sometimes we already know the next/prev entries and we can
- * generate better code by using them directly rather than
- * using the generic single-entry routines.
- */
-
-struct list_head {
-	struct list_head *next, *prev;
-};
-
-#define LIST_HEAD_INIT(name) { &(name), &(name) }
-
-#define LIST_HEAD(name) \
-	struct list_head name = LIST_HEAD_INIT(name)
-
-#define INIT_LIST_HEAD(ptr) do { \
-	(ptr)->next = (ptr); (ptr)->prev = (ptr); \
-} while (0)
-
-/*
- * Insert a new entry between two known consecutive entries. 
- *
- * This is only for internal list manipulation where we know
- * the prev/next entries already!
- */
-static __inline__ void __list_add(struct list_head * new,
-	struct list_head * prev,
-	struct list_head * next)
-{
-	next->prev = new;
-	new->next = next;
-	new->prev = prev;
-	prev->next = new;
-}
-
-/**
- * list_add - add a new entry
- * @new: new entry to be added
- * @head: list head to add it after
- *
- * Insert a new entry after the specified head.
- * This is good for implementing stacks.
- */
-static __inline__ void list_add(struct list_head *new, struct list_head *head)
-{
-	__list_add(new, head, head->next);
-}
-
-/**
- * list_add_tail - add a new entry
- * @new: new entry to be added
- * @head: list head to add it before
- *
- * Insert a new entry before the specified head.
- * This is useful for implementing queues.
- */
-static __inline__ void list_add_tail(struct list_head *new, struct list_head *head)
-{
-	__list_add(new, head->prev, head);
-}
-
-/*
- * Delete a list entry by making the prev/next entries
- * point to each other.
- *
- * This is only for internal list manipulation where we know
- * the prev/next entries already!
- */
-static __inline__ void __list_del(struct list_head * prev,
-				  struct list_head * next)
-{
-	next->prev = prev;
-	prev->next = next;
-}
-
-/**
- * list_del - deletes entry from list.
- * @entry: the element to delete from the list.
- * Note: list_empty on entry does not return true after this, the entry is in an undefined state.
- */
-static __inline__ void list_del(struct list_head *entry)
-{
-	__list_del(entry->prev, entry->next);
-}
-
-/**
- * list_del_init - deletes entry from list and reinitialize it.
- * @entry: the element to delete from the list.
- */
-static __inline__ void list_del_init(struct list_head *entry)
-{
-	__list_del(entry->prev, entry->next);
-	INIT_LIST_HEAD(entry); 
-}
-
-/**
- * list_empty - tests whether a list is empty
- * @head: the list to test.
- */
-static __inline__ int list_empty(struct list_head *head)
-{
-	return head->next == head;
-}
-
-/**
- * list_splice - join two lists
- * @list: the new list to add.
- * @head: the place to add it in the first list.
- */
-static __inline__ void list_splice(struct list_head *list, struct list_head *head)
-{
-	struct list_head *first = list->next;
-
-	if (first != list) {
-		struct list_head *last = list->prev;
-		struct list_head *at = head->next;
-
-		first->prev = head;
-		head->next = first;
-
-		last->next = at;
-		at->prev = last;
-	}
-}
-
-/**
- * list_entry - get the struct for this entry
- * @ptr:	the &struct list_head pointer.
- * @type:	the type of the struct this is embedded in.
- * @member:	the name of the list_struct within the struct.
- */
-#define list_entry(ptr, type, member) \
-	((type *)((char *)(ptr)-(unsigned long)(&((type *)0)->member)))
-
-/**
- * list_for_each	-	iterate over a list
- * @pos:	the &struct list_head to use as a loop counter.
- * @head:	the head for your list.
- */
-#define list_for_each(pos, head) \
-	for (pos = (head)->next; pos != (head); pos = pos->next)
-        	
-/**
- * list_for_each_safe	-	iterate over a list safe against removal of list entry
- * @pos:	the &struct list_head to use as a loop counter.
- * @n:		another &struct list_head to use as temporary storage
- * @head:	the head for your list.
- */
-#define list_for_each_safe(pos, n, head) \
-	for (pos = (head)->next, n = pos->next; pos != (head); \
-		pos = n, n = pos->next)
-
-/**
- * list_for_each_prev	-	iterate over a list in reverse order
- * @pos:	the &struct list_head to use as a loop counter.
- * @head:	the head for your list.
- */
-#define list_for_each_prev(pos, head) \
-	for (pos = (head)->prev; pos != (head); pos = pos->prev)
-
-#endif /* _LIST_H_ */
diff --git a/src/a2jpeg/misc.h b/src/a2jpeg/misc.h
deleted file mode 100644
index 92a66bc..0000000
--- a/src/a2jpeg/misc.h
+++ /dev/null
@@ -1,9 +0,0 @@
-/*
- * misc useful #defines ...
- */
-
-#define container_of(ptr, type, member) ({			\
-        const typeof( ((type *)0)->member ) *__mptr = (ptr);	\
-        (type *)( (char *)__mptr - offsetof(type,member) );})
-
-#define array_size(x) (sizeof(x)/sizeof(x[0]))
diff --git a/src/a2jpeg/op.c b/src/a2jpeg/op.c
deleted file mode 100644
index b4e95fe..0000000
--- a/src/a2jpeg/op.c
+++ /dev/null
@@ -1,289 +0,0 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include "readers.h"
-#include "op.h"
-#include "filter.h"
-
-/* ----------------------------------------------------------------------- */
-/* functions                                                               */
-
-static char op_none_data;
-
-static void
-op_flip_vert(struct ida_image *src, struct ida_rect *rect,
-	     unsigned char *dst, int line, void *data)
-{
-    char *scanline;
-
-    scanline = src->data + (src->i.height - line - 1) * src->i.width * 3;
-    memcpy(dst,scanline,src->i.width*3);
-}
-
-static void
-op_flip_horz(struct ida_image *src, struct ida_rect *rect,
-	     unsigned char *dst, int line, void *data)
-{
-    char *scanline;
-    unsigned int i;
-
-    scanline = src->data + (line+1) * src->i.width * 3;
-    for (i = 0; i < src->i.width; i++) {
-	scanline -= 3;
-	dst[0] = scanline[0];
-	dst[1] = scanline[1];
-	dst[2] = scanline[2];
-	dst += 3;
-    }
-}
-
-static void*
-op_rotate_init(struct ida_image *src, struct ida_rect *rect,
-	       struct ida_image_info *i, void *parm)
-{
-    *i = src->i;
-    i->height = src->i.width;
-    i->width  = src->i.height;
-    i->dpi    = src->i.dpi;
-    return &op_none_data;
-}
-
-static void
-op_rotate_cw(struct ida_image *src, struct ida_rect *rect,
-	     unsigned char *dst, int line, void *data)
-{
-    char *pix;
-    unsigned int i;
-
-    pix = src->data + src->i.width * src->i.height * 3 + line * 3;
-    for (i = 0; i < src->i.height; i++) {
-	pix -= src->i.width * 3;
-	dst[0] = pix[0];
-	dst[1] = pix[1];
-	dst[2] = pix[2];
-	dst += 3;
-    }
-}
-
-static void
-op_rotate_ccw(struct ida_image *src, struct ida_rect *rect,
-	      unsigned char *dst, int line, void *data)
-{
-    char *pix;
-    unsigned int i;
-
-    pix = src->data + (src->i.width-line-1) * 3;
-    for (i = 0; i < src->i.height; i++) {
-	dst[0] = pix[0];
-	dst[1] = pix[1];
-	dst[2] = pix[2];
-	pix += src->i.width * 3;
-	dst += 3;
-    }
-}
-
-static void
-op_invert(struct ida_image *src, struct ida_rect *rect,
-	  unsigned char *dst, int line, void *data)
-{
-    unsigned char *scanline;
-    int i;
-
-    scanline = src->data + line * src->i.width * 3;
-    memcpy(dst,scanline,src->i.width * 3);
-    if (line < rect->y1 || line >= rect->y2)
-	return;
-    dst      += 3*rect->x1;
-    scanline += 3*rect->x1;
-    for (i = rect->x1; i < rect->x2; i++) {
-	dst[0] = 255-scanline[0];
-	dst[1] = 255-scanline[1];
-	dst[2] = 255-scanline[2];
-	scanline += 3;
-	dst += 3;
-    }
-}
-
-static void*
-op_crop_init(struct ida_image *src, struct ida_rect *rect,
-	     struct ida_image_info *i, void *parm)
-{
-    if (rect->x2 - rect->x1 == src->i.width &&
-	rect->y2 - rect->y1 == src->i.height)
-	return NULL;
-    *i = src->i;
-    i->width  = rect->x2 - rect->x1;
-    i->height = rect->y2 - rect->y1;
-    return &op_none_data;
-}
-
-static void
-op_crop_work(struct ida_image *src, struct ida_rect *rect,
-	     unsigned char *dst, int line, void *data)
-{
-    unsigned char *scanline;
-    int i;
-
-    scanline = src->data + (line+rect->y1) * src->i.width * 3 + rect->x1 * 3;
-    for (i = rect->x1; i < rect->x2; i++) {
-	dst[0] = scanline[0];
-	dst[1] = scanline[1];
-	dst[2] = scanline[2];
-	scanline += 3;
-	dst += 3;
-    }
-}
-
-static void*
-op_autocrop_init(struct ida_image *src, struct ida_rect *unused,
-		 struct ida_image_info *i, void *parm)
-{
-    static struct op_3x3_parm filter = {
-	f1: { -1, -1, -1 },
-	f2: { -1,  8, -1 },
-	f3: { -1, -1, -1 },
-    };
-    struct ida_rect rect;
-    struct ida_image img;
-    int x,y,limit;
-    unsigned char *line;
-    void *data;
-    
-    /* detect edges */
-    rect.x1 = 0;
-    rect.x2 = src->i.width;
-    rect.y1 = 0;
-    rect.y2 = src->i.height;
-    data = desc_3x3.init(src, &rect, &img.i, &filter);
-
-    img.data   = malloc(img.i.width * img.i.height * 3);
-    for (y = 0; y < (int)img.i.height; y++)
-	desc_3x3.work(src, &rect, img.data+3*img.i.width*y, y, data);
-    desc_3x3.done(data);
-    limit = 64;
-
-    /* y border */
-    for (y = 0; y < (int)img.i.height; y++) {
-	line = img.data + img.i.width*y*3;
-	for (x = 0; x < (int)img.i.width; x++)
-	    if (line[3*x+0] > limit ||
-		line[3*x+1] > limit ||
-		line[3*x+2] > limit)
-		break;
-	if (x != (int)img.i.width)
-	    break;
-    }
-    rect.y1 = y;
-    for (y = (int)img.i.height-1; y > rect.y1; y--) {
-	line = img.data + img.i.width*y*3;
-	for (x = 0; x < (int)img.i.width; x++)
-	    if (line[3*x+0] > limit ||
-		line[3*x+1] > limit ||
-		line[3*x+2] > limit)
-		break;
-	if (x != (int)img.i.width)
-	    break;
-    }
-    rect.y2 = y+1;
-
-    /* x border */
-    for (x = 0; x < (int)img.i.width; x++) {
-	for (y = 0; y < (int)img.i.height; y++) {
-	    line = img.data + (img.i.width*y+x) * 3;
-	    if (line[0] > limit ||
-		line[1] > limit ||
-		line[2] > limit)
-		break;
-	}
-	if (y != (int)img.i.height)
-	    break;
-    }
-    rect.x1 = x;
-    for (x = (int)img.i.width-1; x > rect.x1; x--) {
-	for (y = 0; y < (int)img.i.height; y++) {
-	    line = img.data + (img.i.width*y+x) * 3;
-	    if (line[0] > limit ||
-		line[1] > limit ||
-		line[2] > limit)
-		break;
-	}
-	if (y != (int)img.i.height)
-	    break;
-    }
-    rect.x2 = x+1;
-
-    free(img.data);
-    if (debug)
-	fprintf(stderr,"y: %d-%d/%d  --  x: %d-%d/%d\n",
-		rect.y1, rect.y2, img.i.height,
-		rect.x1, rect.x2, img.i.width);
-
-    if (0 == rect.x2 - rect.x1  ||  0 == rect.y2 - rect.y1)
-	return NULL;
-    
-    *unused = rect;
-    *i = src->i;
-    i->width  = rect.x2 - rect.x1;
-    i->height = rect.y2 - rect.y1;
-    return &op_none_data;
-}
-
-/* ----------------------------------------------------------------------- */
-
-static char op_none_data;
-
-void* op_none_init(struct ida_image *src,  struct ida_rect *sel,
-		   struct ida_image_info *i, void *parm)
-{
-    *i = src->i;
-    return &op_none_data;
-}
-
-void  op_none_done(void *data) {}
-void  op_free_done(void *data) { free(data); }
-
-/* ----------------------------------------------------------------------- */
-
-struct ida_op desc_flip_vert = {
-    name:  "flip-vert",
-    init:  op_none_init,
-    work:  op_flip_vert,
-    done:  op_none_done,
-};
-struct ida_op desc_flip_horz = {
-    name:  "flip-horz",
-    init:  op_none_init,
-    work:  op_flip_horz,
-    done:  op_none_done,
-};
-struct ida_op desc_rotate_cw = {
-    name:  "rotate-cw",
-    init:  op_rotate_init,
-    work:  op_rotate_cw,
-    done:  op_none_done,
-};
-struct ida_op desc_rotate_ccw = {
-    name:  "rotate-ccw",
-    init:  op_rotate_init,
-    work:  op_rotate_ccw,
-    done:  op_none_done,
-};
-struct ida_op desc_invert = {
-    name:  "invert",
-    init:  op_none_init,
-    work:  op_invert,
-    done:  op_none_done,
-};
-struct ida_op desc_crop = {
-    name:  "crop",
-    init:  op_crop_init,
-    work:  op_crop_work,
-    done:  op_none_done,
-};
-struct ida_op desc_autocrop = {
-    name:  "autocrop",
-    init:  op_autocrop_init,
-    work:  op_crop_work,
-    done:  op_none_done,
-};
diff --git a/src/a2jpeg/op.h b/src/a2jpeg/op.h
deleted file mode 100644
index 4d882f5..0000000
--- a/src/a2jpeg/op.h
+++ /dev/null
@@ -1,7 +0,0 @@
-extern struct ida_op desc_flip_vert;
-extern struct ida_op desc_flip_horz;
-extern struct ida_op desc_rotate_cw;
-extern struct ida_op desc_rotate_ccw;
-extern struct ida_op desc_invert;
-extern struct ida_op desc_crop;
-extern struct ida_op desc_autocrop;
diff --git a/src/a2jpeg/read-jpeg.c b/src/a2jpeg/read-jpeg.c
deleted file mode 100644
index b6b13f6..0000000
--- a/src/a2jpeg/read-jpeg.c
+++ /dev/null
@@ -1,209 +0,0 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <stddef.h>
-#include <string.h>
-#include <errno.h>
-#include <jpeglib.h>
-#include <setjmp.h>
-
-#include <libexif/exif-data.h>
-
-#include "readers.h"
-#include "misc.h"
-
-/* ---------------------------------------------------------------------- */
-/* load                                                                   */
-
-struct jpeg_state {
-    FILE * infile;                /* source file */
-    
-    struct jpeg_decompress_struct cinfo;
-    struct jpeg_error_mgr jerr;
-    jmp_buf errjump;
-    JSAMPARRAY buffer;            /* Output row buffer */
-    int row_stride,linelength;    /* physical row width in output buffer */
-    unsigned char *image,*ptr;
-
-    /* thumbnail */
-    unsigned char  *thumbnail;
-    unsigned int   tpos, tsize;
-};
-
-/* ---------------------------------------------------------------------- */
-/* data source manager for thumbnail images                               */
-
-static void thumbnail_src_init(struct jpeg_decompress_struct *cinfo)
-{
-    struct jpeg_state *h  = container_of(cinfo, struct jpeg_state, cinfo);
-    cinfo->src->next_input_byte = h->thumbnail;
-    cinfo->src->bytes_in_buffer = h->tsize;
-}
-
-static int thumbnail_src_fill(struct jpeg_decompress_struct *cinfo)
-{
-    fprintf(stderr,"jpeg: panic: no more thumbnail input data\n");
-    exit(1);
-}
-
-static void thumbnail_src_skip(struct jpeg_decompress_struct *cinfo,
-			       long num_bytes)
-{
-    cinfo->src->next_input_byte += num_bytes;
-}
-
-static void thumbnail_src_term(struct jpeg_decompress_struct *cinfo)
-{
-    /* nothing */
-}
-
-static struct jpeg_source_mgr thumbnail_mgr = {
-    .init_source         = thumbnail_src_init,
-    .fill_input_buffer   = thumbnail_src_fill,
-    .skip_input_data     = thumbnail_src_skip,
-    .resync_to_restart   = jpeg_resync_to_restart,
-    .term_source         = thumbnail_src_term,
-};
-
-/* ---------------------------------------------------------------------- */
-/* jpeg loader                                                            */
-
-static void jerror_exit(j_common_ptr info)
-{
-    struct jpeg_decompress_struct *cinfo = (struct jpeg_decompress_struct *)info;
-    struct jpeg_state *h  = container_of(cinfo, struct jpeg_state, cinfo);
-    cinfo->err->output_message(info);
-    longjmp(h->errjump, 1);
-    jpeg_destroy_decompress(cinfo);
-    exit(1);
-}
-
-static void*
-jpeg_init(FILE *fp, char *filename, unsigned int page,
-	  struct ida_image_info *i, int thumbnail)
-{
-    struct jpeg_state *h;
-    jpeg_saved_marker_ptr mark;
-    
-    h = malloc(sizeof(*h));
-    memset(h,0,sizeof(*h));
-    h->infile = fp;
-
-    h->cinfo.err = jpeg_std_error(&h->jerr);
-    h->cinfo.err->error_exit = jerror_exit;
-    if(setjmp(h->errjump))
-	return 0;
-
-    jpeg_create_decompress(&h->cinfo);
-    jpeg_save_markers(&h->cinfo, JPEG_COM,    0xffff); /* comment */
-    jpeg_save_markers(&h->cinfo, JPEG_APP0+1, 0xffff); /* EXIF */
-    jpeg_stdio_src(&h->cinfo, h->infile);
-    jpeg_read_header(&h->cinfo, TRUE);
-
-    for (mark = h->cinfo.marker_list; NULL != mark; mark = mark->next) {
-	switch (mark->marker) {
-	case JPEG_COM:
-	    if (debug)
-		fprintf(stderr,"jpeg: comment found (COM marker) [%.*s]\n",
-			(int)mark->data_length, mark->data);
-	    load_add_extra(i,EXTRA_COMMENT,mark->data,mark->data_length);
-	    break;
-	case JPEG_APP0 +1:
-	    if (debug)
-		fprintf(stderr,"jpeg: exif data found (APP1 marker)\n");
-	    load_add_extra(i,EXTRA_COMMENT,mark->data,mark->data_length);
-
-	    if (thumbnail) {
-		ExifData *ed;
-		
-		ed = exif_data_new_from_data(mark->data,mark->data_length);
-		if (ed->data &&
-		    ed->data[0] == 0xff &&
-		    ed->data[1] == 0xd8) {
-		    if (debug)
-			fprintf(stderr,"jpeg: exif thumbnail found\n");
-
-		    /* save away thumbnail data */
-		    h->thumbnail = malloc(ed->size);
-		    h->tsize = ed->size;
-		    memcpy(h->thumbnail,ed->data,ed->size);
-		}
-		exif_data_unref(ed);
-	    }
-	    break;
-	}
-    }
-
-    if (h->thumbnail) {
-	/* save image size */
-	i->thumbnail   = 1;
-	i->real_width  = h->cinfo.image_width;
-	i->real_height = h->cinfo.image_height;
-
-	/* re-setup jpeg */
-	jpeg_destroy_decompress(&h->cinfo);
-	fclose(h->infile);
-	h->infile = NULL;
-	jpeg_create_decompress(&h->cinfo);
-	h->cinfo.src = &thumbnail_mgr;
-	jpeg_read_header(&h->cinfo, TRUE);
-    }
-
-    h->cinfo.out_color_space = JCS_RGB;
-    jpeg_start_decompress(&h->cinfo);
-    i->width  = h->cinfo.image_width;
-    i->height = h->cinfo.image_height;
-    i->npages = 1;
-    switch (h->cinfo.density_unit) {
-    case 0: /* unknown */
-	break;
-    case 1: /* dot per inch */
-	i->dpi = h->cinfo.X_density;
-	break;
-    case 2: /* dot per cm */
-	i->dpi = res_cm_to_inch(h->cinfo.X_density);
-	break;
-    }
-
-    return h;
-}
-
-static void
-jpeg_read(unsigned char *dst, unsigned int line, void *data)
-{
-    struct jpeg_state *h = data;
-    JSAMPROW row = dst;
-
-    if(setjmp(h->errjump))
-	return;
-    jpeg_read_scanlines(&h->cinfo, &row, 1);
-}
-
-static void
-jpeg_done(void *data)
-{
-    struct jpeg_state *h = data;
-
-    if (setjmp(h->errjump))
-	return;
-    jpeg_destroy_decompress(&h->cinfo);
-    if (h->infile)
-	fclose(h->infile);
-    if (h->thumbnail)
-	free(h->thumbnail);
-    free(h);
-}
-
-struct ida_loader jpeg_loader = {
-    magic: "\xff\xd8",
-    moff:  0,
-    mlen:  2,
-    name:  "libjpeg",
-    init:  jpeg_init,
-    read:  jpeg_read,
-    done:  jpeg_done,
-};
-
-static void __init init_rd(void)
-{
-    load_register(&jpeg_loader);
-}
diff --git a/src/a2jpeg/readers.c b/src/a2jpeg/readers.c
deleted file mode 100644
index 065be06..0000000
--- a/src/a2jpeg/readers.c
+++ /dev/null
@@ -1,133 +0,0 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include "readers.h"
-
-/* ----------------------------------------------------------------------- */
-
-void load_bits_lsb(unsigned char *dst, unsigned char *src, int width,
-		   int on, int off)
-{
-    int i,mask,bit;
-    
-    for (i = 0; i < width; i++) {
-	mask = 1 << (i & 0x07);
-	bit  = src[i>>3] & mask;
-	dst[0] = bit ? on : off;
-	dst[1] = bit ? on : off;
-	dst[2] = bit ? on : off;
-	dst += 3;
-    }
-}
-
-void load_bits_msb(unsigned char *dst, unsigned char *src, int width,
-		   int on, int off)
-{
-    int i,mask,bit;
-    
-    for (i = 0; i < width; i++) {
-	mask = 1 << (7 - (i & 0x07));
-	bit  = src[i>>3] & mask;
-	dst[0] = bit ? on : off;
-	dst[1] = bit ? on : off;
-	dst[2] = bit ? on : off;
-	dst += 3;
-    }
-}
-
-void load_gray(unsigned char *dst, unsigned char *src, int width)
-{
-    int i;
-
-    for (i = 0; i < width; i++) {
-	dst[0] = src[0];
-	dst[1] = src[0];
-	dst[2] = src[0];
-	dst += 3;
-	src += 1;
-    }
-}
-
-void load_graya(unsigned char *dst, unsigned char *src, int width)
-{
-    int i;
-
-    for (i = 0; i < width; i++) {
-	dst[0] = src[0];
-	dst[1] = src[0];
-	dst[2] = src[0];
-	dst += 3;
-	src += 2;
-    }
-}
-
-void load_rgba(unsigned char *dst, unsigned char *src, int width)
-{
-    int i;
-
-    for (i = 0; i < width; i++) {
-	dst[0] = src[0];
-	dst[1] = src[1];
-	dst[2] = src[2];
-	dst += 3;
-	src += 4;
-    }
-}
-
-/* ----------------------------------------------------------------------- */
-
-int load_add_extra(struct ida_image_info *info, enum ida_extype type,
-		   unsigned char *data, unsigned int size)
-{
-    struct ida_extra *extra;
-
-    extra = malloc(sizeof(*extra));
-    if (NULL == extra)
-	return -1;
-    memset(extra,0,sizeof(*extra));
-    extra->data = malloc(size);
-    if (NULL == extra->data) {
-	free(extra);
-	return -1;
-    }
-    extra->type = type;
-    extra->size = size;
-    memcpy(extra->data,data,size);
-    extra->next = info->extra;
-    info->extra = extra;
-    return 0;
-};
-
-struct ida_extra* load_find_extra(struct ida_image_info *info,
-				  enum ida_extype type)
-{
-    struct ida_extra *extra;
-
-    for (extra = info->extra; NULL != extra; extra = extra->next)
-	if (type == extra->type)
-	    return extra;
-    return NULL;
-}
-
-int load_free_extras(struct ida_image_info *info)
-{
-    struct ida_extra *next;
-
-    while (NULL != info->extra) {
-	next = info->extra->next;
-	free(info->extra->data);
-	free(info->extra);
-	info->extra = next;
-    }
-    return 0;
-}
-
-/* ----------------------------------------------------------------------- */
-
-LIST_HEAD(loaders);
-
-void load_register(struct ida_loader *loader)
-{
-    list_add_tail(&loader->list, &loaders);
-}
diff --git a/src/a2jpeg/readers.h b/src/a2jpeg/readers.h
deleted file mode 100644
index b54e5b6..0000000
--- a/src/a2jpeg/readers.h
+++ /dev/null
@@ -1,104 +0,0 @@
-#include "list.h"
-
-enum ida_extype {
-    EXTRA_COMMENT = 1,
-    EXTRA_EXIF    = 2,
-};
-
-struct ida_extra {
-    enum ida_extype   type;
-    unsigned char     *data;
-    unsigned int      size;
-    struct ida_extra  *next;
-};
-
-/* image data and metadata */
-struct ida_image_info {
-    unsigned int      width;
-    unsigned int      height;
-    unsigned int      dpi;
-    unsigned int      npages;
-    struct ida_extra  *extra;
-
-    int               thumbnail;
-    unsigned int      real_width;
-    unsigned int      real_height;
-};
-
-struct ida_image {
-    struct ida_image_info  i;
-    unsigned char          *data;
-};
-struct ida_rect {
-    int x1,y1,x2,y2;
-};
-
-/* load image files */
-struct ida_loader {
-    char  *magic;
-    int   moff;
-    int   mlen;
-    char  *name;
-    void* (*init)(FILE *fp, char *filename, unsigned int page,
-		  struct ida_image_info *i, int thumbnail);
-    void  (*read)(unsigned char *dst, unsigned int line, void *data);
-    void  (*done)(void *data);
-    struct list_head list;
-};
-
-/* filter + operations */
-struct ida_op {
-    char  *name;
-    void* (*init)(struct ida_image *src, struct ida_rect *rect,
-		  struct ida_image_info *i, void *parm);
-    void  (*work)(struct ida_image *src, struct ida_rect *rect,
-		  unsigned char *dst, int line,
-		  void *data);
-    void  (*done)(void *data);
-};
-
-void* op_none_init(struct ida_image *src, struct ida_rect *rect,
-		   struct ida_image_info *i, void *parm);
-void  op_none_done(void *data);
-void  op_free_done(void *data);
-
-/* ----------------------------------------------------------------------- */
-/* resolution                                                              */
-
-#define res_cm_to_inch(x) ((x * 2540 + 5) / 1000)
-#define res_m_to_inch(x)  ((x * 2540 + 5) / 100000)
-#define res_inch_to_m(x)  ((x * 100000 + 5) / 2540)
-
-/* ----------------------------------------------------------------------- */
-
-/* helpers */
-void load_bits_lsb(unsigned char *dst, unsigned char *src, int width,
-		   int on, int off);
-void load_bits_msb(unsigned char *dst, unsigned char *src, int width,
-		   int on, int off);
-void load_gray(unsigned char *dst, unsigned char *src, int width);
-void load_graya(unsigned char *dst, unsigned char *src, int width);
-void load_rgba(unsigned char *dst, unsigned char *src, int width);
-
-int load_add_extra(struct ida_image_info *info, enum ida_extype type,
-		   unsigned char *data, unsigned int size);
-struct ida_extra* load_find_extra(struct ida_image_info *info,
-				  enum ida_extype type);
-int load_free_extras(struct ida_image_info *info);
-
-/* ----------------------------------------------------------------------- */
-
-/* other */
-extern int debug;
-extern struct ida_loader ppm_loader;
-extern struct ida_loader jpeg_loader;
-extern struct ida_loader sane_loader;
-extern struct ida_writer ps_writer;
-extern struct ida_writer jpeg_writer;
-
-/* lists */
-#define __init __attribute__ ((constructor))
-#define __fini __attribute__ ((destructor))
-
-extern struct list_head loaders;
-void load_register(struct ida_loader *loader);
diff --git a/src/a2jpeg/transupp.c b/src/a2jpeg/transupp.c
deleted file mode 100644
index e5ec564..0000000
--- a/src/a2jpeg/transupp.c
+++ /dev/null
@@ -1,928 +0,0 @@
-/*
- * transupp.c
- *
- * Copyright (C) 1997, Thomas G. Lane.
- * This file is part of the Independent JPEG Group's software.
- * For conditions of distribution and use, see the accompanying README file.
- *
- * This file contains image transformation routines and other utility code
- * used by the jpegtran sample application.  These are NOT part of the core
- * JPEG library.  But we keep these routines separate from jpegtran.c to
- * ease the task of maintaining jpegtran-like programs that have other user
- * interfaces.
- */
-
-/* Although this file really shouldn't have access to the library internals,
- * it's helpful to let it call jround_up() and jcopy_block_row().
- */
-#define JPEG_INTERNALS
-
-#include "jinclude.h"
-#include "jpeglib.h"
-#include "transupp.h"		/* My own external interface */
-
-
-#if TRANSFORMS_SUPPORTED
-
-/*
- * Lossless image transformation routines.  These routines work on DCT
- * coefficient arrays and thus do not require any lossy decompression
- * or recompression of the image.
- * Thanks to Guido Vollbeding for the initial design and code of this feature.
- *
- * Horizontal flipping is done in-place, using a single top-to-bottom
- * pass through the virtual source array.  It will thus be much the
- * fastest option for images larger than main memory.
- *
- * The other routines require a set of destination virtual arrays, so they
- * need twice as much memory as jpegtran normally does.  The destination
- * arrays are always written in normal scan order (top to bottom) because
- * the virtual array manager expects this.  The source arrays will be scanned
- * in the corresponding order, which means multiple passes through the source
- * arrays for most of the transforms.  That could result in much thrashing
- * if the image is larger than main memory.
- *
- * Some notes about the operating environment of the individual transform
- * routines:
- * 1. Both the source and destination virtual arrays are allocated from the
- *    source JPEG object, and therefore should be manipulated by calling the
- *    source's memory manager.
- * 2. The destination's component count should be used.  It may be smaller
- *    than the source's when forcing to grayscale.
- * 3. Likewise the destination's sampling factors should be used.  When
- *    forcing to grayscale the destination's sampling factors will be all 1,
- *    and we may as well take that as the effective iMCU size.
- * 4. When "trim" is in effect, the destination's dimensions will be the
- *    trimmed values but the source's will be untrimmed.
- * 5. All the routines assume that the source and destination buffers are
- *    padded out to a full iMCU boundary.  This is true, although for the
- *    source buffer it is an undocumented property of jdcoefct.c.
- * Notes 2,3,4 boil down to this: generally we should use the destination's
- * dimensions and ignore the source's.
- */
-
-
-LOCAL(void)
-do_flip_h (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
-	   jvirt_barray_ptr *src_coef_arrays)
-/* Horizontal flip; done in-place, so no separate dest array is required */
-{
-  JDIMENSION MCU_cols, comp_width, blk_x, blk_y;
-  int ci, k, offset_y;
-  JBLOCKARRAY buffer;
-  JCOEFPTR ptr1, ptr2;
-  JCOEF temp1, temp2;
-  jpeg_component_info *compptr;
-
-  /* Horizontal mirroring of DCT blocks is accomplished by swapping
-   * pairs of blocks in-place.  Within a DCT block, we perform horizontal
-   * mirroring by changing the signs of odd-numbered columns.
-   * Partial iMCUs at the right edge are left untouched.
-   */
-  MCU_cols = dstinfo->image_width / (dstinfo->max_h_samp_factor * DCTSIZE);
-
-  for (ci = 0; ci < dstinfo->num_components; ci++) {
-    compptr = dstinfo->comp_info + ci;
-    comp_width = MCU_cols * compptr->h_samp_factor;
-    for (blk_y = 0; blk_y < compptr->height_in_blocks;
-	 blk_y += compptr->v_samp_factor) {
-      buffer = (*srcinfo->mem->access_virt_barray)
-	((j_common_ptr) srcinfo, src_coef_arrays[ci], blk_y,
-	 (JDIMENSION) compptr->v_samp_factor, TRUE);
-      for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
-	for (blk_x = 0; blk_x * 2 < comp_width; blk_x++) {
-	  ptr1 = buffer[offset_y][blk_x];
-	  ptr2 = buffer[offset_y][comp_width - blk_x - 1];
-	  /* this unrolled loop doesn't need to know which row it's on... */
-	  for (k = 0; k < DCTSIZE2; k += 2) {
-	    temp1 = *ptr1;	/* swap even column */
-	    temp2 = *ptr2;
-	    *ptr1++ = temp2;
-	    *ptr2++ = temp1;
-	    temp1 = *ptr1;	/* swap odd column with sign change */
-	    temp2 = *ptr2;
-	    *ptr1++ = -temp2;
-	    *ptr2++ = -temp1;
-	  }
-	}
-      }
-    }
-  }
-}
-
-
-LOCAL(void)
-do_flip_v (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
-	   jvirt_barray_ptr *src_coef_arrays,
-	   jvirt_barray_ptr *dst_coef_arrays)
-/* Vertical flip */
-{
-  JDIMENSION MCU_rows, comp_height, dst_blk_x, dst_blk_y;
-  int ci, i, j, offset_y;
-  JBLOCKARRAY src_buffer, dst_buffer;
-  JBLOCKROW src_row_ptr, dst_row_ptr;
-  JCOEFPTR src_ptr, dst_ptr;
-  jpeg_component_info *compptr;
-
-  /* We output into a separate array because we can't touch different
-   * rows of the source virtual array simultaneously.  Otherwise, this
-   * is a pretty straightforward analog of horizontal flip.
-   * Within a DCT block, vertical mirroring is done by changing the signs
-   * of odd-numbered rows.
-   * Partial iMCUs at the bottom edge are copied verbatim.
-   */
-  MCU_rows = dstinfo->image_height / (dstinfo->max_v_samp_factor * DCTSIZE);
-
-  for (ci = 0; ci < dstinfo->num_components; ci++) {
-    compptr = dstinfo->comp_info + ci;
-    comp_height = MCU_rows * compptr->v_samp_factor;
-    for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;
-	 dst_blk_y += compptr->v_samp_factor) {
-      dst_buffer = (*srcinfo->mem->access_virt_barray)
-	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
-	 (JDIMENSION) compptr->v_samp_factor, TRUE);
-      if (dst_blk_y < comp_height) {
-	/* Row is within the mirrorable area. */
-	src_buffer = (*srcinfo->mem->access_virt_barray)
-	  ((j_common_ptr) srcinfo, src_coef_arrays[ci],
-	   comp_height - dst_blk_y - (JDIMENSION) compptr->v_samp_factor,
-	   (JDIMENSION) compptr->v_samp_factor, FALSE);
-      } else {
-	/* Bottom-edge blocks will be copied verbatim. */
-	src_buffer = (*srcinfo->mem->access_virt_barray)
-	  ((j_common_ptr) srcinfo, src_coef_arrays[ci], dst_blk_y,
-	   (JDIMENSION) compptr->v_samp_factor, FALSE);
-      }
-      for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
-	if (dst_blk_y < comp_height) {
-	  /* Row is within the mirrorable area. */
-	  dst_row_ptr = dst_buffer[offset_y];
-	  src_row_ptr = src_buffer[compptr->v_samp_factor - offset_y - 1];
-	  for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks;
-	       dst_blk_x++) {
-	    dst_ptr = dst_row_ptr[dst_blk_x];
-	    src_ptr = src_row_ptr[dst_blk_x];
-	    for (i = 0; i < DCTSIZE; i += 2) {
-	      /* copy even row */
-	      for (j = 0; j < DCTSIZE; j++)
-		*dst_ptr++ = *src_ptr++;
-	      /* copy odd row with sign change */
-	      for (j = 0; j < DCTSIZE; j++)
-		*dst_ptr++ = - *src_ptr++;
-	    }
-	  }
-	} else {
-	  /* Just copy row verbatim. */
-	  jcopy_block_row(src_buffer[offset_y], dst_buffer[offset_y],
-			  compptr->width_in_blocks);
-	}
-      }
-    }
-  }
-}
-
-
-LOCAL(void)
-do_transpose (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
-	      jvirt_barray_ptr *src_coef_arrays,
-	      jvirt_barray_ptr *dst_coef_arrays)
-/* Transpose source into destination */
-{
-  JDIMENSION dst_blk_x, dst_blk_y;
-  int ci, i, j, offset_x, offset_y;
-  JBLOCKARRAY src_buffer, dst_buffer;
-  JCOEFPTR src_ptr, dst_ptr;
-  jpeg_component_info *compptr;
-
-  /* Transposing pixels within a block just requires transposing the
-   * DCT coefficients.
-   * Partial iMCUs at the edges require no special treatment; we simply
-   * process all the available DCT blocks for every component.
-   */
-  for (ci = 0; ci < dstinfo->num_components; ci++) {
-    compptr = dstinfo->comp_info + ci;
-    for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;
-	 dst_blk_y += compptr->v_samp_factor) {
-      dst_buffer = (*srcinfo->mem->access_virt_barray)
-	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
-	 (JDIMENSION) compptr->v_samp_factor, TRUE);
-      for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
-	for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks;
-	     dst_blk_x += compptr->h_samp_factor) {
-	  src_buffer = (*srcinfo->mem->access_virt_barray)
-	    ((j_common_ptr) srcinfo, src_coef_arrays[ci], dst_blk_x,
-	     (JDIMENSION) compptr->h_samp_factor, FALSE);
-	  for (offset_x = 0; offset_x < compptr->h_samp_factor; offset_x++) {
-	    src_ptr = src_buffer[offset_x][dst_blk_y + offset_y];
-	    dst_ptr = dst_buffer[offset_y][dst_blk_x + offset_x];
-	    for (i = 0; i < DCTSIZE; i++)
-	      for (j = 0; j < DCTSIZE; j++)
-		dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
-	  }
-	}
-      }
-    }
-  }
-}
-
-
-LOCAL(void)
-do_rot_90 (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
-	   jvirt_barray_ptr *src_coef_arrays,
-	   jvirt_barray_ptr *dst_coef_arrays)
-/* 90 degree rotation is equivalent to
- *   1. Transposing the image;
- *   2. Horizontal mirroring.
- * These two steps are merged into a single processing routine.
- */
-{
-  JDIMENSION MCU_cols, comp_width, dst_blk_x, dst_blk_y;
-  int ci, i, j, offset_x, offset_y;
-  JBLOCKARRAY src_buffer, dst_buffer;
-  JCOEFPTR src_ptr, dst_ptr;
-  jpeg_component_info *compptr;
-
-  /* Because of the horizontal mirror step, we can't process partial iMCUs
-   * at the (output) right edge properly.  They just get transposed and
-   * not mirrored.
-   */
-  MCU_cols = dstinfo->image_width / (dstinfo->max_h_samp_factor * DCTSIZE);
-
-  for (ci = 0; ci < dstinfo->num_components; ci++) {
-    compptr = dstinfo->comp_info + ci;
-    comp_width = MCU_cols * compptr->h_samp_factor;
-    for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;
-	 dst_blk_y += compptr->v_samp_factor) {
-      dst_buffer = (*srcinfo->mem->access_virt_barray)
-	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
-	 (JDIMENSION) compptr->v_samp_factor, TRUE);
-      for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
-	for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks;
-	     dst_blk_x += compptr->h_samp_factor) {
-	  src_buffer = (*srcinfo->mem->access_virt_barray)
-	    ((j_common_ptr) srcinfo, src_coef_arrays[ci], dst_blk_x,
-	     (JDIMENSION) compptr->h_samp_factor, FALSE);
-	  for (offset_x = 0; offset_x < compptr->h_samp_factor; offset_x++) {
-	    src_ptr = src_buffer[offset_x][dst_blk_y + offset_y];
-	    if (dst_blk_x < comp_width) {
-	      /* Block is within the mirrorable area. */
-	      dst_ptr = dst_buffer[offset_y]
-		[comp_width - dst_blk_x - offset_x - 1];
-	      for (i = 0; i < DCTSIZE; i++) {
-		for (j = 0; j < DCTSIZE; j++)
-		  dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
-		i++;
-		for (j = 0; j < DCTSIZE; j++)
-		  dst_ptr[j*DCTSIZE+i] = -src_ptr[i*DCTSIZE+j];
-	      }
-	    } else {
-	      /* Edge blocks are transposed but not mirrored. */
-	      dst_ptr = dst_buffer[offset_y][dst_blk_x + offset_x];
-	      for (i = 0; i < DCTSIZE; i++)
-		for (j = 0; j < DCTSIZE; j++)
-		  dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
-	    }
-	  }
-	}
-      }
-    }
-  }
-}
-
-
-LOCAL(void)
-do_rot_270 (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
-	    jvirt_barray_ptr *src_coef_arrays,
-	    jvirt_barray_ptr *dst_coef_arrays)
-/* 270 degree rotation is equivalent to
- *   1. Horizontal mirroring;
- *   2. Transposing the image.
- * These two steps are merged into a single processing routine.
- */
-{
-  JDIMENSION MCU_rows, comp_height, dst_blk_x, dst_blk_y;
-  int ci, i, j, offset_x, offset_y;
-  JBLOCKARRAY src_buffer, dst_buffer;
-  JCOEFPTR src_ptr, dst_ptr;
-  jpeg_component_info *compptr;
-
-  /* Because of the horizontal mirror step, we can't process partial iMCUs
-   * at the (output) bottom edge properly.  They just get transposed and
-   * not mirrored.
-   */
-  MCU_rows = dstinfo->image_height / (dstinfo->max_v_samp_factor * DCTSIZE);
-
-  for (ci = 0; ci < dstinfo->num_components; ci++) {
-    compptr = dstinfo->comp_info + ci;
-    comp_height = MCU_rows * compptr->v_samp_factor;
-    for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;
-	 dst_blk_y += compptr->v_samp_factor) {
-      dst_buffer = (*srcinfo->mem->access_virt_barray)
-	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
-	 (JDIMENSION) compptr->v_samp_factor, TRUE);
-      for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
-	for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks;
-	     dst_blk_x += compptr->h_samp_factor) {
-	  src_buffer = (*srcinfo->mem->access_virt_barray)
-	    ((j_common_ptr) srcinfo, src_coef_arrays[ci], dst_blk_x,
-	     (JDIMENSION) compptr->h_samp_factor, FALSE);
-	  for (offset_x = 0; offset_x < compptr->h_samp_factor; offset_x++) {
-	    dst_ptr = dst_buffer[offset_y][dst_blk_x + offset_x];
-	    if (dst_blk_y < comp_height) {
-	      /* Block is within the mirrorable area. */
-	      src_ptr = src_buffer[offset_x]
-		[comp_height - dst_blk_y - offset_y - 1];
-	      for (i = 0; i < DCTSIZE; i++) {
-		for (j = 0; j < DCTSIZE; j++) {
-		  dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
-		  j++;
-		  dst_ptr[j*DCTSIZE+i] = -src_ptr[i*DCTSIZE+j];
-		}
-	      }
-	    } else {
-	      /* Edge blocks are transposed but not mirrored. */
-	      src_ptr = src_buffer[offset_x][dst_blk_y + offset_y];
-	      for (i = 0; i < DCTSIZE; i++)
-		for (j = 0; j < DCTSIZE; j++)
-		  dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
-	    }
-	  }
-	}
-      }
-    }
-  }
-}
-
-
-LOCAL(void)
-do_rot_180 (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
-	    jvirt_barray_ptr *src_coef_arrays,
-	    jvirt_barray_ptr *dst_coef_arrays)
-/* 180 degree rotation is equivalent to
- *   1. Vertical mirroring;
- *   2. Horizontal mirroring.
- * These two steps are merged into a single processing routine.
- */
-{
-  JDIMENSION MCU_cols, MCU_rows, comp_width, comp_height, dst_blk_x, dst_blk_y;
-  int ci, i, j, offset_y;
-  JBLOCKARRAY src_buffer, dst_buffer;
-  JBLOCKROW src_row_ptr, dst_row_ptr;
-  JCOEFPTR src_ptr, dst_ptr;
-  jpeg_component_info *compptr;
-
-  MCU_cols = dstinfo->image_width / (dstinfo->max_h_samp_factor * DCTSIZE);
-  MCU_rows = dstinfo->image_height / (dstinfo->max_v_samp_factor * DCTSIZE);
-
-  for (ci = 0; ci < dstinfo->num_components; ci++) {
-    compptr = dstinfo->comp_info + ci;
-    comp_width = MCU_cols * compptr->h_samp_factor;
-    comp_height = MCU_rows * compptr->v_samp_factor;
-    for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;
-	 dst_blk_y += compptr->v_samp_factor) {
-      dst_buffer = (*srcinfo->mem->access_virt_barray)
-	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
-	 (JDIMENSION) compptr->v_samp_factor, TRUE);
-      if (dst_blk_y < comp_height) {
-	/* Row is within the vertically mirrorable area. */
-	src_buffer = (*srcinfo->mem->access_virt_barray)
-	  ((j_common_ptr) srcinfo, src_coef_arrays[ci],
-	   comp_height - dst_blk_y - (JDIMENSION) compptr->v_samp_factor,
-	   (JDIMENSION) compptr->v_samp_factor, FALSE);
-      } else {
-	/* Bottom-edge rows are only mirrored horizontally. */
-	src_buffer = (*srcinfo->mem->access_virt_barray)
-	  ((j_common_ptr) srcinfo, src_coef_arrays[ci], dst_blk_y,
-	   (JDIMENSION) compptr->v_samp_factor, FALSE);
-      }
-      for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
-	if (dst_blk_y < comp_height) {
-	  /* Row is within the mirrorable area. */
-	  dst_row_ptr = dst_buffer[offset_y];
-	  src_row_ptr = src_buffer[compptr->v_samp_factor - offset_y - 1];
-	  /* Process the blocks that can be mirrored both ways. */
-	  for (dst_blk_x = 0; dst_blk_x < comp_width; dst_blk_x++) {
-	    dst_ptr = dst_row_ptr[dst_blk_x];
-	    src_ptr = src_row_ptr[comp_width - dst_blk_x - 1];
-	    for (i = 0; i < DCTSIZE; i += 2) {
-	      /* For even row, negate every odd column. */
-	      for (j = 0; j < DCTSIZE; j += 2) {
-		*dst_ptr++ = *src_ptr++;
-		*dst_ptr++ = - *src_ptr++;
-	      }
-	      /* For odd row, negate every even column. */
-	      for (j = 0; j < DCTSIZE; j += 2) {
-		*dst_ptr++ = - *src_ptr++;
-		*dst_ptr++ = *src_ptr++;
-	      }
-	    }
-	  }
-	  /* Any remaining right-edge blocks are only mirrored vertically. */
-	  for (; dst_blk_x < compptr->width_in_blocks; dst_blk_x++) {
-	    dst_ptr = dst_row_ptr[dst_blk_x];
-	    src_ptr = src_row_ptr[dst_blk_x];
-	    for (i = 0; i < DCTSIZE; i += 2) {
-	      for (j = 0; j < DCTSIZE; j++)
-		*dst_ptr++ = *src_ptr++;
-	      for (j = 0; j < DCTSIZE; j++)
-		*dst_ptr++ = - *src_ptr++;
-	    }
-	  }
-	} else {
-	  /* Remaining rows are just mirrored horizontally. */
-	  dst_row_ptr = dst_buffer[offset_y];
-	  src_row_ptr = src_buffer[offset_y];
-	  /* Process the blocks that can be mirrored. */
-	  for (dst_blk_x = 0; dst_blk_x < comp_width; dst_blk_x++) {
-	    dst_ptr = dst_row_ptr[dst_blk_x];
-	    src_ptr = src_row_ptr[comp_width - dst_blk_x - 1];
-	    for (i = 0; i < DCTSIZE2; i += 2) {
-	      *dst_ptr++ = *src_ptr++;
-	      *dst_ptr++ = - *src_ptr++;
-	    }
-	  }
-	  /* Any remaining right-edge blocks are only copied. */
-	  for (; dst_blk_x < compptr->width_in_blocks; dst_blk_x++) {
-	    dst_ptr = dst_row_ptr[dst_blk_x];
-	    src_ptr = src_row_ptr[dst_blk_x];
-	    for (i = 0; i < DCTSIZE2; i++)
-	      *dst_ptr++ = *src_ptr++;
-	  }
-	}
-      }
-    }
-  }
-}
-
-
-LOCAL(void)
-do_transverse (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
-	       jvirt_barray_ptr *src_coef_arrays,
-	       jvirt_barray_ptr *dst_coef_arrays)
-/* Transverse transpose is equivalent to
- *   1. 180 degree rotation;
- *   2. Transposition;
- * or
- *   1. Horizontal mirroring;
- *   2. Transposition;
- *   3. Horizontal mirroring.
- * These steps are merged into a single processing routine.
- */
-{
-  JDIMENSION MCU_cols, MCU_rows, comp_width, comp_height, dst_blk_x, dst_blk_y;
-  int ci, i, j, offset_x, offset_y;
-  JBLOCKARRAY src_buffer, dst_buffer;
-  JCOEFPTR src_ptr, dst_ptr;
-  jpeg_component_info *compptr;
-
-  MCU_cols = dstinfo->image_width / (dstinfo->max_h_samp_factor * DCTSIZE);
-  MCU_rows = dstinfo->image_height / (dstinfo->max_v_samp_factor * DCTSIZE);
-
-  for (ci = 0; ci < dstinfo->num_components; ci++) {
-    compptr = dstinfo->comp_info + ci;
-    comp_width = MCU_cols * compptr->h_samp_factor;
-    comp_height = MCU_rows * compptr->v_samp_factor;
-    for (dst_blk_y = 0; dst_blk_y < compptr->height_in_blocks;
-	 dst_blk_y += compptr->v_samp_factor) {
-      dst_buffer = (*srcinfo->mem->access_virt_barray)
-	((j_common_ptr) srcinfo, dst_coef_arrays[ci], dst_blk_y,
-	 (JDIMENSION) compptr->v_samp_factor, TRUE);
-      for (offset_y = 0; offset_y < compptr->v_samp_factor; offset_y++) {
-	for (dst_blk_x = 0; dst_blk_x < compptr->width_in_blocks;
-	     dst_blk_x += compptr->h_samp_factor) {
-	  src_buffer = (*srcinfo->mem->access_virt_barray)
-	    ((j_common_ptr) srcinfo, src_coef_arrays[ci], dst_blk_x,
-	     (JDIMENSION) compptr->h_samp_factor, FALSE);
-	  for (offset_x = 0; offset_x < compptr->h_samp_factor; offset_x++) {
-	    if (dst_blk_y < comp_height) {
-	      src_ptr = src_buffer[offset_x]
-		[comp_height - dst_blk_y - offset_y - 1];
-	      if (dst_blk_x < comp_width) {
-		/* Block is within the mirrorable area. */
-		dst_ptr = dst_buffer[offset_y]
-		  [comp_width - dst_blk_x - offset_x - 1];
-		for (i = 0; i < DCTSIZE; i++) {
-		  for (j = 0; j < DCTSIZE; j++) {
-		    dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
-		    j++;
-		    dst_ptr[j*DCTSIZE+i] = -src_ptr[i*DCTSIZE+j];
-		  }
-		  i++;
-		  for (j = 0; j < DCTSIZE; j++) {
-		    dst_ptr[j*DCTSIZE+i] = -src_ptr[i*DCTSIZE+j];
-		    j++;
-		    dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
-		  }
-		}
-	      } else {
-		/* Right-edge blocks are mirrored in y only */
-		dst_ptr = dst_buffer[offset_y][dst_blk_x + offset_x];
-		for (i = 0; i < DCTSIZE; i++) {
-		  for (j = 0; j < DCTSIZE; j++) {
-		    dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
-		    j++;
-		    dst_ptr[j*DCTSIZE+i] = -src_ptr[i*DCTSIZE+j];
-		  }
-		}
-	      }
-	    } else {
-	      src_ptr = src_buffer[offset_x][dst_blk_y + offset_y];
-	      if (dst_blk_x < comp_width) {
-		/* Bottom-edge blocks are mirrored in x only */
-		dst_ptr = dst_buffer[offset_y]
-		  [comp_width - dst_blk_x - offset_x - 1];
-		for (i = 0; i < DCTSIZE; i++) {
-		  for (j = 0; j < DCTSIZE; j++)
-		    dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
-		  i++;
-		  for (j = 0; j < DCTSIZE; j++)
-		    dst_ptr[j*DCTSIZE+i] = -src_ptr[i*DCTSIZE+j];
-		}
-	      } else {
-		/* At lower right corner, just transpose, no mirroring */
-		dst_ptr = dst_buffer[offset_y][dst_blk_x + offset_x];
-		for (i = 0; i < DCTSIZE; i++)
-		  for (j = 0; j < DCTSIZE; j++)
-		    dst_ptr[j*DCTSIZE+i] = src_ptr[i*DCTSIZE+j];
-	      }
-	    }
-	  }
-	}
-      }
-    }
-  }
-}
-
-
-/* Request any required workspace.
- *
- * We allocate the workspace virtual arrays from the source decompression
- * object, so that all the arrays (both the original data and the workspace)
- * will be taken into account while making memory management decisions.
- * Hence, this routine must be called after jpeg_read_header (which reads
- * the image dimensions) and before jpeg_read_coefficients (which realizes
- * the source's virtual arrays).
- */
-
-GLOBAL(void)
-jtransform_request_workspace (j_decompress_ptr srcinfo,
-			      jpeg_transform_info *info)
-{
-  jvirt_barray_ptr *coef_arrays = NULL;
-  jpeg_component_info *compptr;
-  int ci;
-
-  if (info->force_grayscale &&
-      srcinfo->jpeg_color_space == JCS_YCbCr &&
-      srcinfo->num_components == 3) {
-    /* We'll only process the first component */
-    info->num_components = 1;
-  } else {
-    /* Process all the components */
-    info->num_components = srcinfo->num_components;
-  }
-
-  switch (info->transform) {
-  case JXFORM_NONE:
-  case JXFORM_FLIP_H:
-    /* Don't need a workspace array */
-    break;
-  case JXFORM_FLIP_V:
-  case JXFORM_ROT_180:
-    /* Need workspace arrays having same dimensions as source image.
-     * Note that we allocate arrays padded out to the next iMCU boundary,
-     * so that transform routines need not worry about missing edge blocks.
-     */
-    coef_arrays = (jvirt_barray_ptr *)
-      (*srcinfo->mem->alloc_small) ((j_common_ptr) srcinfo, JPOOL_IMAGE,
-	SIZEOF(jvirt_barray_ptr) * info->num_components);
-    for (ci = 0; ci < info->num_components; ci++) {
-      compptr = srcinfo->comp_info + ci;
-      coef_arrays[ci] = (*srcinfo->mem->request_virt_barray)
-	((j_common_ptr) srcinfo, JPOOL_IMAGE, FALSE,
-	 (JDIMENSION) jround_up((long) compptr->width_in_blocks,
-				(long) compptr->h_samp_factor),
-	 (JDIMENSION) jround_up((long) compptr->height_in_blocks,
-				(long) compptr->v_samp_factor),
-	 (JDIMENSION) compptr->v_samp_factor);
-    }
-    break;
-  case JXFORM_TRANSPOSE:
-  case JXFORM_TRANSVERSE:
-  case JXFORM_ROT_90:
-  case JXFORM_ROT_270:
-    /* Need workspace arrays having transposed dimensions.
-     * Note that we allocate arrays padded out to the next iMCU boundary,
-     * so that transform routines need not worry about missing edge blocks.
-     */
-    coef_arrays = (jvirt_barray_ptr *)
-      (*srcinfo->mem->alloc_small) ((j_common_ptr) srcinfo, JPOOL_IMAGE,
-	SIZEOF(jvirt_barray_ptr) * info->num_components);
-    for (ci = 0; ci < info->num_components; ci++) {
-      compptr = srcinfo->comp_info + ci;
-      coef_arrays[ci] = (*srcinfo->mem->request_virt_barray)
-	((j_common_ptr) srcinfo, JPOOL_IMAGE, FALSE,
-	 (JDIMENSION) jround_up((long) compptr->height_in_blocks,
-				(long) compptr->v_samp_factor),
-	 (JDIMENSION) jround_up((long) compptr->width_in_blocks,
-				(long) compptr->h_samp_factor),
-	 (JDIMENSION) compptr->h_samp_factor);
-    }
-    break;
-  }
-  info->workspace_coef_arrays = coef_arrays;
-}
-
-
-/* Transpose destination image parameters */
-
-LOCAL(void)
-transpose_critical_parameters (j_compress_ptr dstinfo)
-{
-  int tblno, i, j, ci, itemp;
-  jpeg_component_info *compptr;
-  JQUANT_TBL *qtblptr;
-  JDIMENSION dtemp;
-  UINT16 qtemp;
-
-  /* Transpose basic image dimensions */
-  dtemp = dstinfo->image_width;
-  dstinfo->image_width = dstinfo->image_height;
-  dstinfo->image_height = dtemp;
-
-  /* Transpose sampling factors */
-  for (ci = 0; ci < dstinfo->num_components; ci++) {
-    compptr = dstinfo->comp_info + ci;
-    itemp = compptr->h_samp_factor;
-    compptr->h_samp_factor = compptr->v_samp_factor;
-    compptr->v_samp_factor = itemp;
-  }
-
-  /* Transpose quantization tables */
-  for (tblno = 0; tblno < NUM_QUANT_TBLS; tblno++) {
-    qtblptr = dstinfo->quant_tbl_ptrs[tblno];
-    if (qtblptr != NULL) {
-      for (i = 0; i < DCTSIZE; i++) {
-	for (j = 0; j < i; j++) {
-	  qtemp = qtblptr->quantval[i*DCTSIZE+j];
-	  qtblptr->quantval[i*DCTSIZE+j] = qtblptr->quantval[j*DCTSIZE+i];
-	  qtblptr->quantval[j*DCTSIZE+i] = qtemp;
-	}
-      }
-    }
-  }
-}
-
-
-/* Trim off any partial iMCUs on the indicated destination edge */
-
-LOCAL(void)
-trim_right_edge (j_compress_ptr dstinfo)
-{
-  int ci, max_h_samp_factor;
-  JDIMENSION MCU_cols;
-
-  /* We have to compute max_h_samp_factor ourselves,
-   * because it hasn't been set yet in the destination
-   * (and we don't want to use the source's value).
-   */
-  max_h_samp_factor = 1;
-  for (ci = 0; ci < dstinfo->num_components; ci++) {
-    int h_samp_factor = dstinfo->comp_info[ci].h_samp_factor;
-    max_h_samp_factor = MAX(max_h_samp_factor, h_samp_factor);
-  }
-  MCU_cols = dstinfo->image_width / (max_h_samp_factor * DCTSIZE);
-  if (MCU_cols > 0)		/* can't trim to 0 pixels */
-    dstinfo->image_width = MCU_cols * (max_h_samp_factor * DCTSIZE);
-}
-
-LOCAL(void)
-trim_bottom_edge (j_compress_ptr dstinfo)
-{
-  int ci, max_v_samp_factor;
-  JDIMENSION MCU_rows;
-
-  /* We have to compute max_v_samp_factor ourselves,
-   * because it hasn't been set yet in the destination
-   * (and we don't want to use the source's value).
-   */
-  max_v_samp_factor = 1;
-  for (ci = 0; ci < dstinfo->num_components; ci++) {
-    int v_samp_factor = dstinfo->comp_info[ci].v_samp_factor;
-    max_v_samp_factor = MAX(max_v_samp_factor, v_samp_factor);
-  }
-  MCU_rows = dstinfo->image_height / (max_v_samp_factor * DCTSIZE);
-  if (MCU_rows > 0)		/* can't trim to 0 pixels */
-    dstinfo->image_height = MCU_rows * (max_v_samp_factor * DCTSIZE);
-}
-
-
-/* Adjust output image parameters as needed.
- *
- * This must be called after jpeg_copy_critical_parameters()
- * and before jpeg_write_coefficients().
- *
- * The return value is the set of virtual coefficient arrays to be written
- * (either the ones allocated by jtransform_request_workspace, or the
- * original source data arrays).  The caller will need to pass this value
- * to jpeg_write_coefficients().
- */
-
-GLOBAL(jvirt_barray_ptr *)
-jtransform_adjust_parameters (j_decompress_ptr srcinfo,
-			      j_compress_ptr dstinfo,
-			      jvirt_barray_ptr *src_coef_arrays,
-			      jpeg_transform_info *info)
-{
-  /* If force-to-grayscale is requested, adjust destination parameters */
-  if (info->force_grayscale) {
-    /* We use jpeg_set_colorspace to make sure subsidiary settings get fixed
-     * properly.  Among other things, the target h_samp_factor & v_samp_factor
-     * will get set to 1, which typically won't match the source.
-     * In fact we do this even if the source is already grayscale; that
-     * provides an easy way of coercing a grayscale JPEG with funny sampling
-     * factors to the customary 1,1.  (Some decoders fail on other factors.)
-     */
-    if ((dstinfo->jpeg_color_space == JCS_YCbCr &&
-	 dstinfo->num_components == 3) ||
-	(dstinfo->jpeg_color_space == JCS_GRAYSCALE &&
-	 dstinfo->num_components == 1)) {
-      /* We have to preserve the source's quantization table number. */
-      int sv_quant_tbl_no = dstinfo->comp_info[0].quant_tbl_no;
-      jpeg_set_colorspace(dstinfo, JCS_GRAYSCALE);
-      dstinfo->comp_info[0].quant_tbl_no = sv_quant_tbl_no;
-    } else {
-      /* Sorry, can't do it */
-      ERREXIT(dstinfo, JERR_CONVERSION_NOTIMPL);
-    }
-  }
-
-  /* Correct the destination's image dimensions etc if necessary */
-  switch (info->transform) {
-  case JXFORM_NONE:
-    /* Nothing to do */
-    break;
-  case JXFORM_FLIP_H:
-    if (info->trim)
-      trim_right_edge(dstinfo);
-    break;
-  case JXFORM_FLIP_V:
-    if (info->trim)
-      trim_bottom_edge(dstinfo);
-    break;
-  case JXFORM_TRANSPOSE:
-    transpose_critical_parameters(dstinfo);
-    /* transpose does NOT have to trim anything */
-    break;
-  case JXFORM_TRANSVERSE:
-    transpose_critical_parameters(dstinfo);
-    if (info->trim) {
-      trim_right_edge(dstinfo);
-      trim_bottom_edge(dstinfo);
-    }
-    break;
-  case JXFORM_ROT_90:
-    transpose_critical_parameters(dstinfo);
-    if (info->trim)
-      trim_right_edge(dstinfo);
-    break;
-  case JXFORM_ROT_180:
-    if (info->trim) {
-      trim_right_edge(dstinfo);
-      trim_bottom_edge(dstinfo);
-    }
-    break;
-  case JXFORM_ROT_270:
-    transpose_critical_parameters(dstinfo);
-    if (info->trim)
-      trim_bottom_edge(dstinfo);
-    break;
-  }
-
-  /* Return the appropriate output data set */
-  if (info->workspace_coef_arrays != NULL)
-    return info->workspace_coef_arrays;
-  return src_coef_arrays;
-}
-
-
-/* Execute the actual transformation, if any.
- *
- * This must be called *after* jpeg_write_coefficients, because it depends
- * on jpeg_write_coefficients to have computed subsidiary values such as
- * the per-component width and height fields in the destination object.
- *
- * Note that some transformations will modify the source data arrays!
- */
-
-GLOBAL(void)
-jtransform_execute_transformation (j_decompress_ptr srcinfo,
-				   j_compress_ptr dstinfo,
-				   jvirt_barray_ptr *src_coef_arrays,
-				   jpeg_transform_info *info)
-{
-  jvirt_barray_ptr *dst_coef_arrays = info->workspace_coef_arrays;
-
-  switch (info->transform) {
-  case JXFORM_NONE:
-    break;
-  case JXFORM_FLIP_H:
-    do_flip_h(srcinfo, dstinfo, src_coef_arrays);
-    break;
-  case JXFORM_FLIP_V:
-    do_flip_v(srcinfo, dstinfo, src_coef_arrays, dst_coef_arrays);
-    break;
-  case JXFORM_TRANSPOSE:
-    do_transpose(srcinfo, dstinfo, src_coef_arrays, dst_coef_arrays);
-    break;
-  case JXFORM_TRANSVERSE:
-    do_transverse(srcinfo, dstinfo, src_coef_arrays, dst_coef_arrays);
-    break;
-  case JXFORM_ROT_90:
-    do_rot_90(srcinfo, dstinfo, src_coef_arrays, dst_coef_arrays);
-    break;
-  case JXFORM_ROT_180:
-    do_rot_180(srcinfo, dstinfo, src_coef_arrays, dst_coef_arrays);
-    break;
-  case JXFORM_ROT_270:
-    do_rot_270(srcinfo, dstinfo, src_coef_arrays, dst_coef_arrays);
-    break;
-  }
-}
-
-#endif /* TRANSFORMS_SUPPORTED */
-
-
-/* Setup decompression object to save desired markers in memory.
- * This must be called before jpeg_read_header() to have the desired effect.
- */
-
-GLOBAL(void)
-jcopy_markers_setup (j_decompress_ptr srcinfo, JCOPY_OPTION option)
-{
-#ifdef SAVE_MARKERS_SUPPORTED
-  int m;
-
-  /* Save comments except under NONE option */
-  if (option != JCOPYOPT_NONE) {
-    jpeg_save_markers(srcinfo, JPEG_COM, 0xFFFF);
-  }
-  /* Save all types of APPn markers iff ALL option */
-  if (option == JCOPYOPT_ALL) {
-    for (m = 0; m < 16; m++)
-      jpeg_save_markers(srcinfo, JPEG_APP0 + m, 0xFFFF);
-  }
-#endif /* SAVE_MARKERS_SUPPORTED */
-}
-
-/* Copy markers saved in the given source object to the destination object.
- * This should be called just after jpeg_start_compress() or
- * jpeg_write_coefficients().
- * Note that those routines will have written the SOI, and also the
- * JFIF APP0 or Adobe APP14 markers if selected.
- */
-
-GLOBAL(void)
-jcopy_markers_execute (j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
-		       JCOPY_OPTION option)
-{
-  jpeg_saved_marker_ptr marker;
-
-  /* In the current implementation, we don't actually need to examine the
-   * option flag here; we just copy everything that got saved.
-   * But to avoid confusion, we do not output JFIF and Adobe APP14 markers
-   * if the encoder library already wrote one.
-   */
-  for (marker = srcinfo->marker_list; marker != NULL; marker = marker->next) {
-    if (dstinfo->write_JFIF_header &&
-	marker->marker == JPEG_APP0 &&
-	marker->data_length >= 5 &&
-	GETJOCTET(marker->data[0]) == 0x4A &&
-	GETJOCTET(marker->data[1]) == 0x46 &&
-	GETJOCTET(marker->data[2]) == 0x49 &&
-	GETJOCTET(marker->data[3]) == 0x46 &&
-	GETJOCTET(marker->data[4]) == 0)
-      continue;			/* reject duplicate JFIF */
-    if (dstinfo->write_Adobe_marker &&
-	marker->marker == JPEG_APP0+14 &&
-	marker->data_length >= 5 &&
-	GETJOCTET(marker->data[0]) == 0x41 &&
-	GETJOCTET(marker->data[1]) == 0x64 &&
-	GETJOCTET(marker->data[2]) == 0x6F &&
-	GETJOCTET(marker->data[3]) == 0x62 &&
-	GETJOCTET(marker->data[4]) == 0x65)
-      continue;			/* reject duplicate Adobe */
-#ifdef NEED_FAR_POINTERS
-    /* We could use jpeg_write_marker if the data weren't FAR... */
-    {
-      unsigned int i;
-      jpeg_write_m_header(dstinfo, marker->marker, marker->data_length);
-      for (i = 0; i < marker->data_length; i++)
-	jpeg_write_m_byte(dstinfo, marker->data[i]);
-    }
-#else
-    jpeg_write_marker(dstinfo, marker->marker,
-		      marker->data, marker->data_length);
-#endif
-  }
-}
diff --git a/src/a2jpeg/transupp.h b/src/a2jpeg/transupp.h
deleted file mode 100644
index 5c2d32a..0000000
--- a/src/a2jpeg/transupp.h
+++ /dev/null
@@ -1,135 +0,0 @@
-/*
- * transupp.h
- *
- * Copyright (C) 1997, Thomas G. Lane.
- * This file is part of the Independent JPEG Group's software.
- * For conditions of distribution and use, see the accompanying README file.
- *
- * This file contains declarations for image transformation routines and
- * other utility code used by the jpegtran sample application.  These are
- * NOT part of the core JPEG library.  But we keep these routines separate
- * from jpegtran.c to ease the task of maintaining jpegtran-like programs
- * that have other user interfaces.
- *
- * NOTE: all the routines declared here have very specific requirements
- * about when they are to be executed during the reading and writing of the
- * source and destination files.  See the comments in transupp.c, or see
- * jpegtran.c for an example of correct usage.
- */
-
-/* If you happen not to want the image transform support, disable it here */
-#ifndef TRANSFORMS_SUPPORTED
-#define TRANSFORMS_SUPPORTED 1		/* 0 disables transform code */
-#endif
-
-/* Short forms of external names for systems with brain-damaged linkers. */
-
-#ifdef NEED_SHORT_EXTERNAL_NAMES
-#define jtransform_request_workspace		jTrRequest
-#define jtransform_adjust_parameters		jTrAdjust
-#define jtransform_execute_transformation	jTrExec
-#define jcopy_markers_setup			jCMrkSetup
-#define jcopy_markers_execute			jCMrkExec
-#endif /* NEED_SHORT_EXTERNAL_NAMES */
-
-
-/*
- * Codes for supported types of image transformations.
- */
-
-typedef enum {
-	JXFORM_NONE,		/* no transformation */
-	JXFORM_FLIP_H,		/* horizontal flip */
-	JXFORM_FLIP_V,		/* vertical flip */
-	JXFORM_TRANSPOSE,	/* transpose across UL-to-LR axis */
-	JXFORM_TRANSVERSE,	/* transpose across UR-to-LL axis */
-	JXFORM_ROT_90,		/* 90-degree clockwise rotation */
-	JXFORM_ROT_180,		/* 180-degree rotation */
-	JXFORM_ROT_270		/* 270-degree clockwise (or 90 ccw) */
-} JXFORM_CODE;
-
-/*
- * Although rotating and flipping data expressed as DCT coefficients is not
- * hard, there is an asymmetry in the JPEG format specification for images
- * whose dimensions aren't multiples of the iMCU size.  The right and bottom
- * image edges are padded out to the next iMCU boundary with junk data; but
- * no padding is possible at the top and left edges.  If we were to flip
- * the whole image including the pad data, then pad garbage would become
- * visible at the top and/or left, and real pixels would disappear into the
- * pad margins --- perhaps permanently, since encoders & decoders may not
- * bother to preserve DCT blocks that appear to be completely outside the
- * nominal image area.  So, we have to exclude any partial iMCUs from the
- * basic transformation.
- *
- * Transpose is the only transformation that can handle partial iMCUs at the
- * right and bottom edges completely cleanly.  flip_h can flip partial iMCUs
- * at the bottom, but leaves any partial iMCUs at the right edge untouched.
- * Similarly flip_v leaves any partial iMCUs at the bottom edge untouched.
- * The other transforms are defined as combinations of these basic transforms
- * and process edge blocks in a way that preserves the equivalence.
- *
- * The "trim" option causes untransformable partial iMCUs to be dropped;
- * this is not strictly lossless, but it usually gives the best-looking
- * result for odd-size images.  Note that when this option is active,
- * the expected mathematical equivalences between the transforms may not hold.
- * (For example, -rot 270 -trim trims only the bottom edge, but -rot 90 -trim
- * followed by -rot 180 -trim trims both edges.)
- *
- * We also offer a "force to grayscale" option, which simply discards the
- * chrominance channels of a YCbCr image.  This is lossless in the sense that
- * the luminance channel is preserved exactly.  It's not the same kind of
- * thing as the rotate/flip transformations, but it's convenient to handle it
- * as part of this package, mainly because the transformation routines have to
- * be aware of the option to know how many components to work on.
- */
-
-typedef struct {
-  /* Options: set by caller */
-  JXFORM_CODE transform;	/* image transform operator */
-  boolean trim;			/* if TRUE, trim partial MCUs as needed */
-  boolean force_grayscale;	/* if TRUE, convert color image to grayscale */
-
-  /* Internal workspace: caller should not touch these */
-  int num_components;		/* # of components in workspace */
-  jvirt_barray_ptr * workspace_coef_arrays; /* workspace for transformations */
-} jpeg_transform_info;
-
-
-#if TRANSFORMS_SUPPORTED
-
-/* Request any required workspace */
-EXTERN(void) jtransform_request_workspace
-	JPP((j_decompress_ptr srcinfo, jpeg_transform_info *info));
-/* Adjust output image parameters */
-EXTERN(jvirt_barray_ptr *) jtransform_adjust_parameters
-	JPP((j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
-	     jvirt_barray_ptr *src_coef_arrays,
-	     jpeg_transform_info *info));
-/* Execute the actual transformation, if any */
-EXTERN(void) jtransform_execute_transformation
-	JPP((j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
-	     jvirt_barray_ptr *src_coef_arrays,
-	     jpeg_transform_info *info));
-
-#endif /* TRANSFORMS_SUPPORTED */
-
-
-/*
- * Support for copying optional markers from source to destination file.
- */
-
-typedef enum {
-	JCOPYOPT_NONE,		/* copy no optional markers */
-	JCOPYOPT_COMMENTS,	/* copy only comment (COM) markers */
-	JCOPYOPT_ALL		/* copy all optional markers */
-} JCOPY_OPTION;
-
-#define JCOPYOPT_DEFAULT  JCOPYOPT_COMMENTS	/* recommended default */
-
-/* Setup decompression object to save desired markers in memory */
-EXTERN(void) jcopy_markers_setup
-	JPP((j_decompress_ptr srcinfo, JCOPY_OPTION option));
-/* Copy markers saved in the given source object to the destination object */
-EXTERN(void) jcopy_markers_execute
-	JPP((j_decompress_ptr srcinfo, j_compress_ptr dstinfo,
-	     JCOPY_OPTION option));
diff --git a/src/a2jpeg/write-jpeg.c b/src/a2jpeg/write-jpeg.c
deleted file mode 100644
index 3336a24..0000000
--- a/src/a2jpeg/write-jpeg.c
+++ /dev/null
@@ -1,47 +0,0 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <stddef.h>
-#include <string.h>
-#include <errno.h>
-#include <jpeglib.h>
-
-#include "readers.h"
-#include "writers.h"
-#include "misc.h"
-
-#include "write-jpeg.h"
-
-static int jpeg_quality = 75;
-
-int
-jpeg_write(FILE *fp, struct ida_image *img)
-{
-    struct jpeg_compress_struct cinfo;
-    struct jpeg_error_mgr jerr;
-    unsigned char *line;
-    unsigned int i;
-
-    cinfo.err = jpeg_std_error(&jerr);
-    jpeg_create_compress(&cinfo);
-    jpeg_stdio_dest(&cinfo, fp);
-    cinfo.image_width  = img->i.width;
-    cinfo.image_height = img->i.height;
-    if (img->i.dpi) {
-	cinfo.density_unit = 1;
-	cinfo.X_density = img->i.dpi;
-	cinfo.Y_density = img->i.dpi;
-    }
-    cinfo.input_components = 3;
-    cinfo.in_color_space = JCS_RGB;
-    jpeg_set_defaults(&cinfo);
-    jpeg_set_quality(&cinfo, jpeg_quality, TRUE);
-    jpeg_start_compress(&cinfo, TRUE);
-
-    for (i = 0, line = img->data; i < img->i.height; i++, line += img->i.width*3)
-        jpeg_write_scanlines(&cinfo, &line, 1);
-    
-    jpeg_finish_compress(&(cinfo));
-    jpeg_destroy_compress(&(cinfo));
-    return 0;
-}
-
diff --git a/src/a2jpeg/write-jpeg.h b/src/a2jpeg/write-jpeg.h
deleted file mode 100644
index b774adc..0000000
--- a/src/a2jpeg/write-jpeg.h
+++ /dev/null
@@ -1,24 +0,0 @@
-/* 
- * File:   write-jpeg.h
- * Author: noundou
- *
- * Created on January 30, 2011, 1:40 PM
- */
-
-#ifndef WRITE_JPEG_H
-#define	WRITE_JPEG_H
-
-#ifdef	__cplusplus
-extern "C" {
-#endif
-
-
-int jpeg_write(FILE *fp, struct ida_image *img);
-
-
-#ifdef	__cplusplus
-}
-#endif
-
-#endif	/* WRITE_JPEG_H */
-
diff --git a/src/a2jpeg/writers.c b/src/a2jpeg/writers.c
deleted file mode 100644
index 39e5387..0000000
--- a/src/a2jpeg/writers.c
+++ /dev/null
@@ -1,10 +0,0 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include "readers.h"
-#include "writers.h"
-
-/* ----------------------------------------------------------------------- */
-
-LIST_HEAD(writers);
diff --git a/src/a2jpeg/writers.h b/src/a2jpeg/writers.h
deleted file mode 100644
index 1dde0ba..0000000
--- a/src/a2jpeg/writers.h
+++ /dev/null
@@ -1,3 +0,0 @@
-#include "list.h"
-
-extern struct list_head writers;
diff --git a/src/car.jpg b/src/car.jpg
deleted file mode 100644
index 92eff56..0000000
Binary files a/src/car.jpg and /dev/null differ
diff --git a/src/jpegr.c b/src/jpegr.c
index b189526..162afca 100644
--- a/src/jpegr.c
+++ b/src/jpegr.c
@@ -10,12 +10,12 @@
 
 #include "jpegr.h"
 
-#include "a2jpeg/genthumbnail.h"
+#include "genthumbnail.h"
 
-#include "a2jpeg/write-jpeg.h"
+#include "write-jpeg.h"
 
-#include "a2jpeg/readers.h"
-#include "a2jpeg/dither.h"
+#include "readers.h"
+#include "dither.h"
 
 #include <sys/stat.h>
 #include <unistd.h>
@@ -23,10 +23,11 @@
 #include <math.h>
 
 #include <exif-data.h>
+#include <libgen.h>
 
 #define FALSE 0
-
 #define TRUE 1
+#define THUMBNAIL_WIDTH 70
 
 static JXFORM_CODE transmagic[] = {
   [1] = JXFORM_NONE,
@@ -58,10 +59,10 @@ const char ENDING[SIZE_ENDING] = ".a2";
 
 
 /**
- * You specify the maximum number of row per column
+ * You specify the maximum number of columns per row
  * that will appear in the montage file here.
  */
-static const int MAX_ROW = 5;
+static const int MAX_PER_ROW = 5;
 
 static int createMontageFile (UserRequest * uRequest);
 
@@ -73,7 +74,7 @@ static int createMontageFile (UserRequest * uRequest);
  * You may also want to provide more options to the user.
  */
 
-int main (int argc, char *argv[])
+int main (int argc, char * const* argv)
 {
   UserRequest *uRequest;
   if (FALSE == initUserRequest (&uRequest)) {
@@ -147,7 +148,7 @@ int main (int argc, char *argv[])
  * the rotations of input files and the creation of montage file.
  */
 int processUserRequest (UserRequest * uRequest,
-			char *argv[], int argc, int optind)
+			char * const* argv, int argc, int optind)
 {
 
   int curFile = optind;
@@ -161,10 +162,9 @@ int processUserRequest (UserRequest * uRequest,
       continue;
 
     uRequest->fileIn[i] = (char *) calloc (1, FILENAME_MAX);
-    uRequest->fileRotIn[i] = (char *) calloc (1, FILENAME_MAX);
 
     if (0 == uRequest->fileIn[i]) {
-      printf ("Could not allocate memory to process %s.\n", argv[curFile]);
+      printf ("Could not allocate memory to store filename %s.\n", argv[curFile]);
       abort_message ();
       return FALSE;
     }
@@ -172,14 +172,11 @@ int processUserRequest (UserRequest * uRequest,
     strncat (uRequest->fileIn[i], uRequest->outDir,
 	     strlen (uRequest->outDir));
     strncat (uRequest->fileIn[i], &PATH_SEP, 1);
-    strncat (uRequest->fileIn[i], argv[curFile], strlen (argv[curFile]));
-
-    strcpy (uRequest->fileRotIn[i], uRequest->fileIn[i]);
-    strncat (uRequest->fileRotIn[i], ENDING, SIZE_ENDING);
+    strncat (uRequest->fileIn[i], basename(argv[curFile]), strlen (argv[curFile]));
 
     struct ida_image *curInputJpeg;
 
-    curInputJpeg = read_jpeg (uRequest->fileIn[i]);
+    curInputJpeg = read_jpeg (argv[curFile]);
     if (!curInputJpeg) {
       printf ("Could not read jpeg file %s during montage creation\n",
 	      uRequest->fileIn[i]);
@@ -187,16 +184,16 @@ int processUserRequest (UserRequest * uRequest,
     }
 
     uRequest->thumbnail[i] = calloc (1, THUMB_MAX);
-    memcpy (uRequest->thumbnail[i], curInputJpeg, THUMB_MAX);
-    uRequest->thumbnail[i] =
-      ece459_scale_thumbnail (uRequest->thumbnail[i], 70);
+
+    uRequest->otherthumbnail[i] = 
+	ece459_scale_thumbnail (curInputJpeg, THUMBNAIL_WIDTH);
 
     JXFORM_CODE exif_orientation = JXFORM_NONE;
 
     if (1 == auto_rotate_flag) {
-      if (FALSE == getExifOrientation (uRequest->thumbnail[i],
+      if (FALSE == getExifOrientation (argv[curFile],
 				       &uRequest->auto_rotation[i])) {
-	printf ("Could not read exif data from jpeg %s, so not"
+	printf ("Could not read exif data from jpeg %s, so no "
 		"rotation will be done\n", uRequest->fileIn[i]);
 
 	continue;
@@ -209,14 +206,14 @@ int processUserRequest (UserRequest * uRequest,
 
 
     //Rotate the jpeg file
-    jpeg_transform_files (uRequest->fileIn[i],
-			  uRequest->fileRotIn[i],
+    jpeg_transform_files (argv[curFile],
+			  uRequest->fileIn[i],
 			  exif_orientation,
 			  uRequest->comment,
 			  uRequest->thumbnail[i], THUMB_MAX, uRequest->flags);
 
-    printf ("An input file %s\n", uRequest->fileIn[i]);
-    printf ("An output file %s\n", uRequest->fileRotIn[i]);
+    printf ("An input file %s\n", argv[curFile]);
+    printf ("An output file %s\n", uRequest->fileIn[i]);
 
     ++curFile;
     ++uRequest->nrFiles;
@@ -228,6 +225,8 @@ int processUserRequest (UserRequest * uRequest,
   return transform;
 }
 
+#define max(x,y) (x>y?x:y)
+#define min(x,y) (x<y?x:y)
 /**
  * You may also want to make changes here to to parallelize
  * the creation of the montage file.
@@ -240,63 +239,41 @@ int createMontageFile (UserRequest * uRequest)
     return FALSE;
   }
 
+  // Allocate space for montage.
   struct ida_image *montageJpeg =
     (struct ida_image *) calloc (1, sizeof (struct ida_image));
-
   montageJpeg->data = (unsigned char *) calloc (uRequest->nrFiles, THUMB_MAX);
 
-  //Write input thumbnails data to the montage file.
-     
-  unsigned int y, x;
-
-  int max_width = 0, tmp_width = 0, max_height = 0;
-
-  int step = (uRequest->nrFiles % MAX_ROW);
-
-  int x_max = 0;
-  int y_max = ceil ((float) uRequest->nrFiles / MAX_ROW);
-
-  for (y = 0; y < y_max; ++y) {
-
-    x_max = (step * y) + MAX_ROW;
-    montageJpeg->data += max_width * y;
-    for (x = step * y; x < x_max && x < uRequest->nrFiles; ++x) {
-
-      
-      tmp_width += uRequest->thumbnail[x]->i.width;
-
-      //Determining the max height of the montage file
-      if (max_height < uRequest->thumbnail[x]->i.height)
-	max_height = uRequest->thumbnail[x]->i.height;
-
-      //Adding thumbnail data to the montage file
-      montageJpeg->data = uRequest->thumbnail[x]->data;
-      ++montageJpeg->data;
-      ++uRequest->thumbnail[x]->data;
-    }
-
-    //Determining the max width of the montage file
-    if (max_width < tmp_width)
-      max_width = tmp_width;
-
+  // Copy input thumbnails to the montage file.
+  int fn;
+  int row_width = min(uRequest->nrFiles, MAX_PER_ROW) * THUMBNAIL_WIDTH;
+  montageJpeg->i.width = row_width;
+  montageJpeg->i.height = 
+      ((MAX_PER_ROW-1 + uRequest->nrFiles) / MAX_PER_ROW) * THUMBNAIL_WIDTH;
+  for (fn = 0; fn < uRequest->nrFiles; fn++) {
+      int row = (fn / MAX_PER_ROW),
+	  col = (fn % MAX_PER_ROW);
+      int offX = col*THUMBNAIL_WIDTH, offY = row*THUMBNAIL_WIDTH;
+
+      int x, y, i;
+      int w = uRequest->otherthumbnail[fn]->i.width;
+      for (y = 0; y < uRequest->otherthumbnail[fn]->i.height; y++)
+	  for (x = 0; x < w; x++)
+	      for (i = 0; i < 3; i++)
+		  montageJpeg->data[((y+offY)*row_width+(x+offX))*3+i] = 
+		      uRequest->otherthumbnail[fn]->data[(y*w+x)*3+i];
   }
 
-  max_height *= y_max;
-
-  montageJpeg->i.width = max_width;
-  montageJpeg->i.height = max_height;
-
-  jpeg_write (fp, montageJpeg);
-
+  jpeg_write (fp, montageJpeg); 
   free (montageJpeg);
 
   return TRUE;
 }
 
-int getExifOrientation (struct ida_image *aThumbnail,
+int getExifOrientation (char * fn,
 			JXFORM_CODE * exifOrientation)
 {
-  ExifData *exifData = exif_data_new_from_data (aThumbnail, THUMB_MAX);
+  ExifData *exifData = exif_data_new_from_file (fn);
 
   if (0 == exifData)
     return FALSE;
@@ -448,7 +425,7 @@ char *copyStr (char **dst, char *src)
   return *dst;
 }
 
-inline void help (char *argv[])
+void help (char * const *argv)
 {
   printf ("Usage: %s [options] file(s)\n", argv[0]);
   printf ("\t-h,     --help        Print this message\n"
diff --git a/src/jpegr.h b/src/jpegr.h
index d7328e7..1e4f1c6 100644
--- a/src/jpegr.h
+++ b/src/jpegr.h
@@ -16,12 +16,12 @@
 #include <stdlib.h>
 #include <getopt.h>
 
-#include "a2jpeg/jpeglib.h"
+#include "jpeglib.h"
 
-#include "a2jpeg/jpegtools.h"
+#include "jpegtools.h"
 
 
-#define MAX_INPUT_FILE 50
+#define MAX_INPUT_FILE 500
 
 /*******************************************************
  * Structure to control a user operation request
@@ -33,7 +33,8 @@ typedef struct {
   unsigned int threads;		//Number of threads to be used
   unsigned int flags;
   unsigned char *comment;
-  struct ida_image *thumbnail[MAX_INPUT_FILE];
+  char *thumbnail[MAX_INPUT_FILE];
+  struct ida_image * otherthumbnail[MAX_INPUT_FILE];
   char *outDir;			//output directory
   char *fileIn[MAX_INPUT_FILE];
   char *fileRotIn[MAX_INPUT_FILE];
@@ -63,9 +64,9 @@ void destroyUserRequest(UserRequest ** uRequest);
 int initUserRequest (UserRequest ** uRequest);
 
 int processUserRequest (UserRequest * uRequest,
-			 char *argv[], int argc, int optind);
+			 char * const* argv, int argc, int optind);
 
-int getExifOrientation (struct ida_image *aThumbnail,
+int getExifOrientation (char * fn,
 			JXFORM_CODE * exifOrientation);
 
 void getThreads (UserRequest * uRequest, char *optarg);
@@ -80,7 +81,7 @@ int isValidFile (const char *fName);
 
 char *copyStr (char **dst, char *src);
 
-void help (char *argv[]);
+inline void help (char * const *argv);
 
 void abort_message ();
 
diff --git a/src/makefile b/src/makefile
deleted file mode 100644
index 25879e3..0000000
--- a/src/makefile
+++ /dev/null
@@ -1,58 +0,0 @@
-.PHONY: clean indent
-.SUFFIXES: .c .h .o .a
-
-OBJLIB=a2jpeg/transupp.o\
-       a2jpeg/jpegtools.o\
-       a2jpeg/readers.o\
-       a2jpeg/op.o\
-       a2jpeg/filter.o\
-       a2jpeg/read-jpeg.o\
-       a2jpeg/write-jpeg.o\
-       a2jpeg/dither.o\
-       a2jpeg/genthumbnail.o
-
-FBIDA_DIR=../fbida-2.07
-
-HEADERS=-I/usr/include/glib-2.0\
-	-I/usr/lib/glib-2.0/include\
-	-I/usr/include/libexif\
-	-Ia2jpeg
-
-
-SRC=jpegr.c
-
-CPPFLAGS=-Wall -c -g\
-	 $(HEADERS)
-
-LIBS=-L . -ljpega2 -lglib-2.0 -lexif -ljpeg 
-
-CC=gcc
-
-all: libjpega2 main
-
-main: $(SRC)
-	$(CC) $(CPPFLAGS) jpegr.c
-	$(CC) -o jpegr jpegr.o $(LIBS)
-
-jpeg:
-	$(CC) -c -g -Ia2jpeg a2jpeg/transupp.c
-	$(CC) -c -g $(HEADERS) a2jpeg/jpegtools.c
-	$(CC) -c -g -Ia2jpeg a2jpeg/readers.c
-	$(CC) -c -g -Ia2jpeg a2jpeg/filter.c
-	$(CC) -c -g -Ia2jpeg a2jpeg/op.c
-	$(CC) -c -g -Ia2jpeg a2jpeg/read-jpeg.c
-	$(CC) -c -g -Ia2jpeg a2jpeg/writers.c
-	$(CC) -c -g -Ia2jpeg a2jpeg/write-jpeg.c
-	$(CC) -c -g -Ia2jpeg a2jpeg/dither.c
-	$(CC) -c -g $(HEADERS) a2jpeg/genthumbnail.c
-
-libjpega2: jpeg $(OBJLIB)
-	$(AR) crsu libjpega2.a $(OBJLIB)
-
-
-indent:
-	indent -br -nce -ncdw -brs -lp -ip5 -npsl -nbad -pcs -saf -sai -saw $S
-
-clean:
-	-rm *.o
-	-rm libjpega2.a
