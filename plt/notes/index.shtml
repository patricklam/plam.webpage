
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<!--Automatically generated by Erik Demaine's notes.py script-->
<head>
<title>
ECE251: Programming Languages and Translators -- PDF Lecture notes -- Patrick Lam
</title>
<style type="text/css">
 li { padding-bottom:1em }
</style>
<!--#include virtual="/plt/includes/header.html" -->

<div id="primarycontarea">
  <div id="primarycontent">
    <!-- InstanceBeginEditable name="primarycontent" -->
<H1><A HREF="http://www.patricklam.ca/plt">ECE251: Programming Languages and Translators</A>
    (Fall 2010)</H1>
<H2><A HREF="http://www.patricklam.ca">Patrick Lam</A></H2>
<DIV STYLE="background-color: #FFFF80; color: black">
<H2>Lecture notes</H2>
</DIV>
<!-- <p>You can check out all lecture notes' sources with the following command:</p>
<p>&nbsp;&nbsp;&nbsp;<code>git clone http://patricklam.ca/stqam/stqam-lectures.git/</code></p>
<p>The usual <code>git</code> commands will work for pulling updates from my repository.</p>
-->

<p>You may use these lecture notes however you like. I am placing no
restrictions on their use. As far as I'm concerned, feel free to remix and
share. I'll make the git repository available shortly.</p>

<P>
<UL>
<li> <a href="pdf/L01.pdf"><strong>Lecture 1</strong></a>: Introduction. Bootstrapping. Parts of a compiler.</li>
<li> <a href="pdf/L02.pdf"><strong>Lecture 2</strong></a>: <i>(version 2)</i> <strong>Scanners</strong>: learning objectives. Regular expressions: Motivating applications, scanner example, what versus how, finite automata.</li>
<li> <a href="pdf/L03.pdf"><strong>Lecture 3</strong></a>: <i>(version 2)</i> Regular expressions: Syntax and semantics. Deterministic Finite Automata. Nondeterministic Finite Automata. Executing NFAs and DFAs. Expressive power. Efficiency.</li>
<li> <a href="pdf/L04.pdf"><strong>Lecture 4</strong></a>: Executing regular expressions (compilation to NFAs). Summary of regular expressions, NFAs and DFAs.</li>
<li> <a href="pdf/L05.pdf"><strong>Lecture 5</strong></a>: String-processing applications of regular expressions. Using the string matching API. Operational vs. declarative semantics in language design. Regular expressions vs. regexps. </li>
<li> <a href="pdf/L06.pdf"><strong>Lecture 6</strong></a>: Interlude on (writing) Interpreters and Domain-Specific Languages (internal and external).</li>
<li> <a href="pdf/L07.pdf"><strong>Lecture 7</strong></a>: <strong>Parsers</strong>: learning objectives. Parsing example. </li>
<li> <a href="pdf/L08.pdf"><strong>Lecture 8</strong></a>: Context-free grammars. Backus-Naur form (and EBNF, railroad syntax diagrams). More parsing examples. Regexps vs CFGs. </li>
<li> <a href="pdf/L09.pdf"><strong>Lecture 9</strong></a>: Crash course on object-oriented programming. Types, inheritance, polymorphism, and type casting. Back to parsing: ambiguity, parse trees example. Recursive descent parser example.</li>
<li> <a href="pdf/L10.pdf"><strong>Lecture 10</strong></a>: Parsing an expression. Building recursive-descent top-down parsers: basic scheme; FIRST and FOLLOW set examples. </li>
<li> <a href="pdf/L11.pdf"><strong>Lecture 11</strong></a>: General algorithm for computing FIRST sets. Where to use them.</li>
<li> <a href="pdf/L12.pdf"><strong>Lecture 12</strong></a>: Fixing grammars to work with top-down parsing: eliminating ambiguity and left-recursion. About common prefixes.</li>
<li> <a href="pdf/L13.pdf"><strong>Lecture 13</strong></a>: Recap of parser generators. Bottom-up parsing and common ailments with it. Four examples.</li>
<li> <a href="pdf/L14.pdf"><strong>Lecture 14</strong></a>: Interlude: Abstract Syntax Trees, Visitor Pattern.</li>
<li> <a href="pdf/L15.pdf"><strong>Lecture 15</strong></a>: Scoping. Static versus Dynamic. Issues in static scoping.</li>
<li> <a href="pdf/L16.pdf"><strong>Lecture 16</strong></a>: How to build a symbol table with a list of tables. Symbol table operations and their uses.</li>
<li> <a href="pdf/L17.pdf"><strong>Lecture 17</strong></a>: <b>Execution: interpreters, virtual machines, native code</b>. Big picture (what you can do with what). Interpreting ASTs.</li>
<li> <a href="pdf/L18.pdf"><strong>Lecture 18</strong></a>: <i>(version 2)</i> Interpreting bytecodes. Three-address code and virtual machine implementation. Quadratic formula example.</li>
<li> <a href="pdf/L19.pdf"><strong>Lecture 19</strong></a>: Other uses of ASTs: source-to-source transformations, generating three-address code.</li>
<li> <a href="pdf/L20.pdf"><strong>Lecture 20</strong></a>: Code optimization, register allocation, object headers. Native code generation intro.</li>
<li> <a href="pdf/L21.pdf"><strong>Lecture 21</strong></a>: Recap of the course so far. JIT compilation and dynamic binary translation.</li>
<li> <a href="pdf/L22.pdf"><strong>Lecture 22</strong></a>: <strong>Type checking</strong>. Definitions. Type checking examples. Type coercion.</li>
<li> <a href="pdf/L23.pdf"><strong>Lecture 23</strong></a>: Coercion example. Type equivalence. Formalism for type checking (type rules, environments). Implementation issues.</li>
<li> <a href="pdf/L24.pdf"><strong>Lecture 24</strong></a>: <strong>Intro to programming paradigms</strong>: functional, logic, scripting.</li>
<li> <a href="pdf/L25.pdf"><strong>Lecture 25</strong></a>: <i>(version 2)</i> Scala quicksort example: imperative and functional styles. Higher-order functions: map, filter.</li>
<li> <a href="pdf/L26.pdf"><strong>Lecture 26</strong></a>: More higher-order functions: fixing a parameter; currying and uncurrying; fold and reduce.</li>
<li> <a href="pdf/L27.pdf"><strong>Lecture 27</strong></a>: MapReduce. Introduction to logic programming.</li>
<li> <a href="pdf/L28.pdf"><strong>Lecture 28</strong></a>: Prolog (a superficial view).</li>
<li> <a href="pdf/L29.pdf"><strong>Lecture 29</strong></a>: Overview of scripting languages: use cases, common characteristics, application domains.</li>
<li> <a href="pdf/L30.pdf"><strong>Lecture 30</strong></a>: Domain-specific languages for the Web. How the Web works. Apache server-side includes as a DSL. CGIs. Languages for dynamic webpages.</li>
<li> <a href="pdf/L31.pdf"><strong>Lecture 31</strong></a>: PHP and compiler techniques. Client-side Web programming.</li>
<li> <a href="pdf/L32.pdf"><strong>Lecture 32</strong></a>: Other domain-specific languages: protein structures, drawing languages, XML, Java extensions.</li>
<li> <a href="pdf/L33.pdf"><strong>Lecture 33</strong></a>: Course summary: relating the parts of the course to the course goals.</li>
</UL>
</BODY>
</HTML>
