<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
"http://www.w3.org/TR/html4/strict.dtd">
<html>

<head>
 <meta http-equiv="content-type" content="text/html;charset=ISO-8859-1" />
 <link rel="stylesheet" href="/ui/style.css" type="text/css" />
 <title>Hob Plugins</title>
</head>

<body>

<!-- thanks Drew McLellan, support transparent PNG for email -->
<!--[if lte IE 6]>
	<script type="text/javascript" src="/ui/supersleight-min.js"></script>
<![endif]-->

<?php include('../../top.php') ?>
<?php include('../../menu.php') ?>

<div id="main">     
<p>We have implemented four plugins in our module pluggable analysis
framework.</p>

<ul>

<li>A <em>flag</em> plugin, which assigns abstract set membership
(and therefore typestate) according to integer or boolean flag values;</li>

<li>A <em>PALE</em> plugin, which assigns abstract
set membership based on shape properties of tree-like pointer-based
data structures using the <a
href="http://www.brics.dk/PALE">Pointer Analysis Logic Engine</a> tool
by Anders M&oslash;ller and Michael I. Schwartzbach.</li>

<li>A <em>Bohne</em> plugin, which implements 
<a href="arxiv.org/abs/cs.PL/0609104">field constraint analysis</a>,
a sophisticated shape analysis that is more powerful than PALE and
less brittle.

<li>A <em>theorem proving</em> plugin, which assigns abstract set
membership arbitrarily, for example, according to membership in array-based data structures.  It
generates verification conditions to be discharged using the <a
href="http://www.cl.cam.ac.uk/Research/HVG/Isabelle/">Isabelle</a>
theorem proving environment.</li>

</ul>

<p>A plugin's basic obligation is to show
1) that every procedure's <code>ensures</code> is implied at all of its 
exit points, given the <code>requires</code> clause and the statements in
the procedure; and 2) the <code>requires</code> clause of all callees is
satisfied at the callsite.  A plugin may discharge its obligations however
it chooses to.</p>

<h2>Flag Plugin</h2>

<p>
The flag analysis plugin is designed to verify modules that use
integer or boolean flags to indicate the typestates of the objects
that they manipulate, and propagates boolean formulas through
<code>requires</code> and <code>ensures</code> clauses of callee
procedures.  Flag abstraction sections specify the correspondence
between the concrete flag values and the abstract sets from the
specification, as well as the correspondence between the concrete and
the abstract boolean variables.
</p>

<p>
The flag plugin uses the boolean algebra libraries implemented in <a
href="/svn/repos-code/trunk/module-language/src/typestate/BA.ml"><code>BA.ml</code></a>
and the transfer function itself is implemented in <a
href="/svn/repos-code/trunk/module-language/src/typestate/typestate.ml"><code>typestate.ml</code></a>.
The main loop is in the <code>analyze_module</code> procedure, and the
per-statement transfer functions are in <code>analyze_stmt</code>.
It's a big <code>match</code> statement, and takes advantage of the
fact that we have an Abstract Syntax Tree.  This analysis propagates
boolean formulas directly (the same language we use in the
<code>requires</code> and <code>ensures</code> clauses), and it updates
the value of abstract sets whenever values are assigned to fields of
objects.</p>

<h2>PALE Plugin</h2>

<p>Unlike the flag analysis, which we designed to operate
within our analysis framework, the PALE analysis is a
previously implemented analysis package that we integrated
into our framework. During the course of this adaptation,
we did not modify the PALE analysis package itself &mdash;
our plugin instead takes the form of a translator that enables PALE
to work within our analysis framework.</p>

<p>The bulk of the PALE plugin's implementation is in <a 
href="/svn/repos-code/trunk/module-language/src/pale/pale.ml"><code>pale.ml</code></a>.  For each procedure in the module to be analyzed, this 
plugin creates a separate PALE output file, which is then fed to the 
PALE analysis tool.  The common headers for PALE input files are generated by
<a 
href="/svn/repos-code/trunk/module-language/src/pale/palestd.ml"><code>palestd.ml</code></a>, while the code is emitted by
<a 
href="/svn/repos-code/trunk/module-language/src/pale/paleprinter.ml"><code>paleprinter.ml</code></a>.  After emitting PALE output, we spawn
the PALE binary on the emitted output.  We did modify PALE to return an output
code of 42 upon success, so that we don't have to parse the output to
figure out whether PALE succeeded or not.</p>
 
<h2>Theorem Proving Plugin</h2>

<p>
The theorem proving plugin generates verification conditions using
weakest preconditions and discharges them using the Isabelle theorem
prover.  We have chosen this technique as a last resort for verifying
arbitrarily complicated data structure implementations.  The logic for
specifying abstraction functions is based on typed set theory and
proof obligations can be discharged using automated theorem proving or
a proof checker for manually generated proofs, which means that there
is no \emph{a priori} bound on the complexity of the data structures
(and data structure consistency properties) that can be verified.
</p>

<p>
The verification condition generator is implemented in
<a 
href="/svn/repos-code/trunk/module-language/src/vc/vcgen.ml"><code>vcgen.ml</code></a>.  It uses verification condition formula parsing
libraries (we have a <a href="/svn/repos-code/trunk/module-language/src/vc/vcformparse.mly">ocamlyacc grammar</a> for these formulas, and the
formula manipulation library is in <a href="/svn/repos-code/trunk/module-language/src/vc/vcform.ml"><code>vcform.ml</code></a>).  The engine is the
<code>decide_sq</code> procedure of <code>vcgen.ml</code>; given
a verification condition, it uses the <a href="/svn/repos-code/trunk/module-language/src/vc/vclemmas.ml"><code>vclemmas.ml</code></a> library to verify
whether the condition is cached as being true.  If not, it invokes Isabelle
to attempt to automatically discharge the verification condition.
When using this plugin to prove arbitrarily complicated properties, one
adds lemmas to the proof base until the property goes through.</p>

<?php include('../../bottom.php') ?>

</div>

</body>
</html>
