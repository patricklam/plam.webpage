<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<!--Automatically generated by Erik Demaine's notes.py script-->
<head>
<title>
ECE459: Programming for Performance -- PDF Lecture notes -- Patrick Lam
</title>
<style type="text/css">
 li { padding-bottom:1em }
</style>
<!--#include virtual="/p4p/2011/includes/header.html" -->

<div id="primarycontarea">
  <div id="primarycontent">
    <!-- InstanceBeginEditable name="primarycontent" -->
<h1><a href="http://www.patricklam.ca/p4p">ECE459: Programming for Performance</a>
    (Winter 2011)</h1>
<h2><a href="http://www.patricklam.ca">Patrick Lam</a></h2>
<div style="background-color: #FFFF80; color: black">
<h2>Lecture notes</h2>
</div>
<p>You can check out all lecture notes' sources with the following command:</p>
<p>&nbsp;&nbsp;&nbsp;<code>git clone http://patricklam.ca/p4p/p4p.git/</code></p>
<p>The usual <code>git</code> commands will work for pulling updates from my repository.</p>


<p>You may use these lecture notes however you like. I am placing no
restrictions on their use. As far as I'm concerned, feel free to remix and
share. I'll make the git repository available shortly.</p>

<ul>
<li> <a href="pdf/L01.pdf"><strong>Lecture 1</strong></a>: Introduction: making programs faster; measures of performance (bandwidth vs. latency). Improving latency: doing each thing faster. Improving bandwidth: doing more things at a time (parallelism). Challenges to parallelism.</li>
<li> <a href="pdf/L02.pdf"><strong>Lecture 2</strong></a>: Reference to Cliff Click's talk on modern hardware.</li>
<li> <a href="pdf/L03.pdf"><strong>Lecture 3</strong></a>: Profiling 1: principles of profiling, per-process profiling (e.g. <code>gprof</code>/Google CPU profiler), system-level profiling (e.g. Solaris Studio Performance Analyzer, VTune), digression on web pages.</li>
<li> <a href="pdf/L04.pdf"><strong>Lecture 4</strong></a>: Profiling 2: CodeAnalyst, oprofile, Shark; DTrace (instrumentation-based system-wide profiling); WAIT (analysis of Java wait states).</li>
<li> <a href="pdf/L05.pdf"><strong>Lecture 5</strong></a>: Amdahl's Law, Gustafson's Law, Multicore Processors I.</li>
<li> <a href="pdf/L06.pdf"><strong>Lecture 6</strong></a>: concurrency/parallelism, processor design issues: implementing hardware threads (CMT), using CMT effectively, caches, virtual memory, TLBs.</li>
<li> <a href="pdf/L07.pdf"><strong>Lecture 7</strong></a>: parallelization patterns (data vs task, SIMD, survey of patterns.)</li>
<li> <a href="pdf/L08.pdf"><strong>Lecture 8</strong></a>: Dependencies. Loop- and memory-carried. RAW/WAR/WAW/RAR.</li>
<li> <a href="pdf/L09.pdf"><strong>Lecture 9</strong></a>: Breaking dependencies with speculation: speculative execution, value speculation. Critical Paths. How to Parallelize Code. Creating and Using Threads, including thread pools.</li>
<li> <a href="pdf/L10.pdf"><strong>Lecture 10</strong></a>: Implementing thread pools. Calculating maximum useful threads.</li>
<li> <a href="pdf/L11.pdf"><strong>Lecture 11</strong></a>: Race conditions (and detection). Synchronization Primitives: mutexes, spinlocks, RW locks, semaphores/condition variables, barriers, lock-free code.</li>
<li> <a href="pdf/L12.pdf"><strong>Lecture 12</strong></a>: automatic parallelization: when it works and when it doesn't. NB: Replace "commutative" with "associative".</li>
<li> <a href="pdf/L13.pdf"><strong>Lecture 13</strong></a>: <i>(v2)</i> OpenMP basics; variable scoping (private vs shared); better performance through scheduling; parallel sections and tasks.</li>
<li> <a href="pdf/L14.pdf"><strong>Lecture 14</strong></a>: Midterm. <i>(v2)</i> Notes on OpenMP barriers and taskwait.</li>
<li> <a href="pdf/L15.pdf"><strong>Lecture 15</strong></a>: More on using locks.</li>
<li> <a href="pdf/L16.pdf"><strong>Lecture 16</strong></a>: Memory consistency, barriers/fences, reordering. Compiler optimizations.</li>
<li> <a href="pdf/L17.pdf"><strong>Lecture 17</strong></a>: Laundry list of compiler optimizations.</li>
<li> <a href="pdf/L18.pdf"><strong>Lecture 18</strong></a>: GPU programming 1: features of OpenCL.</li>
<li> <a href="pdf/L19.pdf"><strong>Lecture 19</strong></a>: GPU programming 2: two working examples.</li>
<li> <a href="pdf/L20.pdf"><strong>Lecture 20</strong></a>: Clusters (programming distributed systems with MPI) and Clouds.</li>
<li> <a href="pdf/L21.pdf"><strong>Lecture 21</strong></a>: MapReduce.</li>
<li> <a href="pdf/L22.pdf"><strong>Lecture 22</strong></a>: Reduced-resource computing: discarding tasks, loop perforation.</li>
<li> <a href="pdf/L23.pdf"><strong>Lecture 23</strong></a>: Languages for high-performance computing. (note: there may be a v2 coming later).</li>
<li> <a href="pdf/L24.pdf"><strong>Lecture 24</strong></a>: Course summary.</li>
<li> <a href="pdf/L25.pdf"><strong>Lecture 25</strong></a>: Bonus lecture (not on exam): software transactions.</li>
</ul>

</div>
</div>
</body>
</html>
